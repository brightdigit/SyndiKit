<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Swift by Sundell</title><description>Weekly Swift articles, podcasts and tips by John Sundell</description><link>https://www.swiftbysundell.com</link><language>en-us</language><lastBuildDate>Tue, 30 Jun 2020 19:31:23 +0200</lastBuildDate><pubDate>Tue, 30 Jun 2020 19:31:23 +0200</pubDate><ttl>250</ttl><atom:link href="https://www.swiftbysundell.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/76</guid><title>Podcast: ‚ÄúA huge year for SwiftUI‚Äù, a WWDC20 special with Josh Shaffer and Eliza Block</title><description>Josh Shaffer and Eliza Block from Apple join John to talk about what‚Äôs new in SwiftUI, how Xcode Previews work under the hood, the new home screen widget system, Apple‚Äôs internal process of adopting and improving SwiftUI, and much more.</description><link>https://www.swiftbysundell.com/podcast/76</link><pubDate>Tue, 30 Jun 2020 18:50:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell76.mp3" type="audio/mpeg"/></audio><p>Josh Shaffer and Eliza Block from Apple join John to talk about what‚Äôs new in SwiftUI, how Xcode Previews work under the hood, the new home screen widget system, Apple‚Äôs internal process of adopting and improving SwiftUI, and much more.</p><h2>Sponsors</h2><ul><li><strong><a href="https://instabug.com/sundell">Instabug</a>:</strong> Join thousands of companies, including Lyft and eBay, who use Instabug to enhance their app quality and iterate faster. It‚Äôs perfect for teams that are working remotely. Go to <a href="https://instabug.com/sundell">instabug.com/sundell</a> to try it for free for 3 months.</li><li><strong><a href="https://clubhouse.io/sundell">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that‚Äôs fantastic for remote collaboration. Built specifically for software teams. Sign up for free at <a href="https://clubhouse.io/sundell">clubhouse.io/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/joshshaffer">Josh on Twitter</a></li><li><a href="https://twitter.com/elizablock">Eliza on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://www.swiftbysundell.com/podcast/59/">Last year‚Äôs episode with Josh</a></li><li><a href="https://developer.apple.com/documentation/swiftui">SwiftUI‚Äôs documentation</a></li><li><a href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable">UIViewRepresentable</a></li><li><a href="https://developer.apple.com/documentation/swiftui/app">App</a></li><li><a href="https://developer.apple.com/documentation/swiftui/scene">Scene</a></li><li><a href="https://developer.apple.com/documentation/swiftui/colorpicker">The new ColorPicker</a></li><li><a href="https://developer.apple.com/documentation/swiftui/stateobject">StateObject</a></li><li><a href="https://developer.apple.com/documentation/clockkit/creating_complications_for_your_watchos_app">watchOS complications</a></li><li><a href="https://developer.apple.com/documentation/swiftui/scrollview/drawinggroup(opaque:colormode:)">DrawingGroup</a></li><li><a href="https://developer.apple.com/documentation/widgetkit/creating-a-widget-extension">Widgets</a></li><li><a href="https://developer.apple.com/documentation/swiftui/scene/commands(content:)">The new commands modifier</a></li><li><a href="https://developer.apple.com/documentation/appkit/nsdocument">NSDocument</a></li><li><a href="https://developer.apple.com/documentation/swiftui/documentgroup">DocumentGroup</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/learning-swiftui-by-building-tools-and-prototypes</guid><title>Learning SwiftUI by building tools and prototypes</title><description>Let‚Äôs take a look at one possible venue for learning and exploring SwiftUI without having to necessarily deploy it directly into production ‚Äî by building internal tools and various prototypes.</description><link>https://www.swiftbysundell.com/articles/learning-swiftui-by-building-tools-and-prototypes</link><pubDate>Sun, 28 Jun 2020 21:15:00 +0200</pubDate><content:encoded><![CDATA[<p>A year ago, before WWDC 2019 kicked off, there was a lot of speculation and debate within the Apple developer community as to whether Apple would finally start shipping <em>Swift-only frameworks</em>.</p><p>At the time, the notion that Apple would depart from its established strategy of maintaining full backward compatibility with Objective-C might‚Äôve seemed like a quite radical idea, but nonetheless, that‚Äôs what ended up happening ‚Äî with the introduction of frameworks like <a href="https://www.swiftbysundell.com/basics/combine">Combine</a>, <a href="https://www.swiftbysundell.com/basics/swiftui">SwiftUI</a> and <a href="https://developer.apple.com/documentation/cryptokit">CryptoKit</a>.</p><p>Fast-forward to now, June of 2020, and the concept of Swift-only frameworks is now not just a possibility ‚Äî it‚Äôs quite arguably the <em>new normal</em>, at least for new additions to Apple‚Äôs various SDKs. But Apple didn‚Äôt stop there. This year, at WWDC20, we saw the introduction of Apple‚Äôs first-ever <em>SwiftUI-only</em> framework ‚Äî <a href="https://wwdcbysundell.com/2020/getting-started-with-widgetkit">WidgetKit</a>.</p><p>Now, depending on who you ask, the fact that the new home screen widgets that Apple announced during the WWDC20 keynote can <em>only</em> be built with SwiftUI might sound anywhere from amazing, to terrible, to downright scary. While it‚Äôs fair to say that SwiftUI has in many ways taken the Apple developer community by storm, and has enabled a lot of new developers to start building their first apps, the current opinions on SwiftUI are divisive to say the least.</p><p>However, whether you consider SwiftUI to be a fantastic new way of building apps, or something that‚Äôs not quite production-ready, one thing has been made quite clear ‚Äî SwiftUI is here to stay.</p><p>So this week, let‚Äôs take a look at <em>one possible venue</em> for learning and exploring SwiftUI ‚Äî one that I‚Äôve personally taken during the past year ‚Äî by building internal tools and various prototypes.</p><h2>Learning doesn‚Äôt necessarily mean deploying</h2><p><em>‚ÄúShould I learn SwiftUI?‚Äù</em> is, without a doubt, one of the most common questions that I‚Äôve been asked over the past year.</p><p>Now, I always try to be incredibly careful when answering questions like that, since it‚Äôs very difficult to give any sort of concrete advice as to what any given developer should or shouldn‚Äôt do, without being familiar with their personal context. For example, what kind of app are they working on, what does their user base look like, and how does their team or company operate?</p><p>However, this year‚Äôs announcements from Apple have significantly shifted my default answer as to whether a developer working on Apple‚Äôs platforms should learn SwiftUI ‚Äî towards simply being <em>‚Äùyes‚Äù</em>.</p><p>It‚Äôs important to remember that you don‚Äôt have to deploy something within your main production code base in order to learn it. In fact, I personally try to do as much of my learning as possible <em>outside</em> of my shipping code, not just when it comes to SwiftUI, but in general.</p><p>While it‚Äôs often great to have a concrete use case in mind when learning something, there are so many ways to write highly valuable code without actually shipping it to customers, which heavily reduces the inherent risk associated with shipping apps or features using technologies that we haven‚Äôt yet fully familiarized ourselves with.</p><h2>Building internal tools and prototypes</h2><p>When it comes to SwiftUI in particular, its very lightweight syntax in many ways makes it ideal for tasks like prototyping, building internal tools and utilities, user testing, and hobby projects. For example, let‚Äôs say that we wanted to add a view to internal builds of our app that lets both developers and designers preview all colors within a set of themes, and that those themes are defined using a struct that looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Theme {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> isDark: <span class="s-type">Bool</span>
    <span class="s-keyword">var</span> brandColor: <span class="s-type">UIColor</span>
    <span class="s-keyword">var</span> activeButtonColor: <span class="s-type">UIColor</span>
    <span class="s-keyword">var</span> titleColor: <span class="s-type">UIColor</span>
    ...
}</code></pre><p>To make those previews happen, we can use a bit of <a href="https://www.swiftbysundell.com/articles/reflection-in-swift">reflection</a> to extract all of the colors from an instance of the above <code>Theme</code> type, and then render a list of them by writing just a tiny amount of SwiftUI code ‚Äî like this:</p><pre class="splash"><code><span class="s-preprocessing">#if INTERNAL_BUILD</span>
<span class="s-keyword">struct</span> ColorList {
    <span class="s-keyword">var</span> entries = [(color: <span class="s-type">UIColor</span>, name: <span class="s-type">String</span>)]()
}

<span class="s-keyword">extension</span> <span class="s-type">Theme</span> {
    <span class="s-keyword">func</span> makeColorList() -&gt; <span class="s-type">ColorList</span> {
        <span class="s-keyword">let</span> mirror = <span class="s-type">Mirror</span>(reflecting: <span class="s-keyword">self</span>)
        <span class="s-keyword">var</span> list = <span class="s-type">ColorList</span>()

        <span class="s-keyword">for</span> (label, value) <span class="s-keyword">in</span> mirror.<span class="s-property">children</span> {
            <span class="s-keyword">guard let</span> color = value <span class="s-keyword">as</span>? <span class="s-type">UIColor</span>,
                  <span class="s-keyword">let</span> name = label <span class="s-keyword">else</span> {
                <span class="s-keyword">continue</span>
            }

            list.<span class="s-property">entries</span>.<span class="s-call">append</span>((color, name))
        }

        <span class="s-keyword">return</span> list
    }
}

<span class="s-keyword">struct</span> ColorListView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> list: <span class="s-type">ColorList</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(list.<span class="s-property">entries</span>, id: \.<span class="s-property">name</span>) { entry <span class="s-keyword">in</span>
            <span class="s-type">HStack</span> {
                <span class="s-type">Circle</span>()
                    .<span class="s-call">fill</span>(<span class="s-type">Color</span>(entry.<span class="s-property">color</span>))
                    .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
                <span class="s-type">Text</span>(entry.<span class="s-property">name</span>)
            }
        }
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p class="info">Note how all of the above code is wrapped within a custom <code>INTERNAL_BUILD</code> <a href="https://www.swiftbysundell.com/articles/feature-flags-in-swift/%23conditional-compilation">compiler flag</a>, which lets us avoid including that code in App Store builds of our app.</p><p>Let‚Äôs say that our app currently ships with two themes ‚Äî one for light mode and one for dark mode ‚Äî so let‚Äôs also add a list view that lets us select which of those two themes to preview. We‚Äôll also modify each theme‚Äôs <code>ColorListView</code> instance to match its corresponding system color scheme, in order to make our previews even more accurate:</p><pre class="splash"><code><span class="s-preprocessing">#if INTERNAL_BUILD</span>
<span class="s-keyword">struct</span> ThemeListView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> themes: [<span class="s-type">Theme</span>] = [.<span class="s-dotAccess">light</span>, .<span class="s-dotAccess">dark</span>]

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(themes, id: \.<span class="s-property">name</span>) { theme <span class="s-keyword">in</span>
                <span class="s-type">NavigationLink</span>(theme.<span class="s-property">name</span>,
                    destination: <span class="s-type">ColorListView</span>(
                        list: theme.<span class="s-call">makeColorList</span>()
                    )
                    .<span class="s-call">colorScheme</span>(theme.<span class="s-property">isDark</span> ? .<span class="s-dotAccess">dark</span> : .<span class="s-dotAccess">light</span>)
                    .<span class="s-call">navigationBarTitle</span>(<span class="s-type">Text</span>(theme.<span class="s-property">name</span>),
                        displayMode: .<span class="s-dotAccess">inline</span>
                    )
                )
            }
            .<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Select a theme"</span>)
        }
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p class="info">Note that if the above code was meant to go into production, or used to render a large list of themes, then we probably wouldn‚Äôt want to perform our <code>makeColorList</code> conversion inline within our view‚Äôs <code>body</code>. But that‚Äôs the beauty of building internal tools and prototypes ‚Äî we can take shortcuts!</p><p>The above is of course just an example, but if we think about it, just by writing that small amount of SwiftUI code we‚Äôve already had to learn about some of its fundamental concepts ‚Äî like <a href="https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views">view composition</a>, <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">layout</a>, <a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views/%23modifier-types">modifiers</a>, navigation, and so on. Plus, besides the learning aspect, we also ended up with a super useful tool for both the developers and designers on our team ‚Äî pretty great!</p><p>SwiftUI is also excellent for prototyping. Just like when building an internal tool, we typically want to spend as little time as possible on any given prototype, since the point of doing prototyping to begin with is to quickly learn whether a given idea or feature is viable.</p><p>What makes SwiftUI so great in this context is that, since it relies on strong defaults and platform conventions, it lets us get down to building our prototype right away ‚Äî with almost no setup required. Just look at the following code sample ‚Äî that‚Äôs everything that‚Äôs now (as of Xcode 12) required to get started with a fully functional SwiftUI-based app:</p><pre class="splash"><code><span class="s-keyword">@main struct</span> MyPrototype: <span class="s-type">App</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">Scene</span> {
        <span class="s-type">WindowGroup</span> {
            <span class="s-type">Text</span>(<span class="s-string">"Let's start prototyping!"</span>)
        }
    }
}</code></pre><h2>Easing our way into production</h2><p>Of course, SwiftUI is not just a prototyping tool, it‚Äôs a powerful UI framework that‚Äôs increasingly used to ship projects ranging from smaller indie apps to large-scale production software. So when and how could it be a good idea to use it within the code that we actually ship to our customers?</p><p>Besides it being a young framework, perhaps the most major limiting factor when it comes to SwiftUI adoption is the fact that it won‚Äôt run on operating systems older than iOS 13 or macOS Catalina ‚Äî which might not be acceptable for a large number of projects, even though that‚Äôll most likely change when Apple‚Äôs upcoming OS versions are released later this year.</p><p>However, as mentioned in last year‚Äôs post-WWDC article <em><a href="https://www.swiftbysundell.com/articles/shifting-paradigms-in-swift">‚ÄúShifting paradigms in Swift‚Äù</a></em>, SwiftUI is far from an ‚Äúall-or-nothing‚Äù type of proposition. Its <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match">interoperability with UIKit and AppKit</a> is really strong, meaning that we might be able to just use SwiftUI to build a small feature that we only make available to users running iOS 13 and above (which at this point should be the vast majority for most apps). Or, we might use it to implement features that rely on newer system APIs, such as <a href="https://wwdcbysundell.com/2020/getting-started-with-widgetkit">widgets</a> or <a href="https://wwdcbysundell.com/2020/a-first-look-at-app-clips-in-ios-14">app clips</a>.</p><p>Just like how building tools, prototypes and hobby projects can let us learn a new framework in a ‚Äúsafer environment‚Äù ‚Äî if we start adopting SwiftUI in just a small part of an existing app, we‚Äôre also likely to discover whether or not it‚Äôs <em><a href="https://www.swiftbysundell.com/articles/deciding-whether-to-adopt-new-swift-technologies/%23to-be-or-not-to-be-production-ready">production-ready</a></em> for our particular use cases much quicker. Because even though both Apple and many third party developers are already deploying SwiftUI in production doesn‚Äôt mean that it‚Äôs going to be the perfect tool for every single app, at least not until it‚Äôs had more time to mature as a framework.</p><h2>Conclusion</h2><p>Now the big question is ‚Äî why spend all of the time and effort required to learn a brand new UI framework when UIKit and AppKit already has everything that‚Äôs needed to build a great app?</p><p>For me, besides the excitement to learn new technologies and the fact that SwiftUI has made me a lot more productive when building many different kinds of UIs, it all comes down to <em>future-proofing</em>.</p><p>If it‚Äôs one thing I‚Äôve learned from a decade of app development for Apple‚Äôs platforms, it‚Äôs that the more you align your projects with Apple‚Äôs vision for where their platforms are headed, the better. UIKit and AppKit might not be going away anytime soon, but WidgetKit is likely not going to be the last SwiftUI-only framework that Apple will ever release.</p><p>SwiftUI might still have ways to go in order to become the ultimate UI development framework, and it still has rough edges here and there, but ‚Äî at least in my opinion ‚Äî it‚Äôs definitely worth learning, even if you‚Äôll just end up using it to build tools and prototypes for now.</p><p>Got questions, comments or feedback? Feel free to <a href="https://www.swiftbysundell.com/contact">send me an email</a> or find me <a href="https://twitter.com/johnsundell">on Twitter @johnsundell</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/workingcopy-june-2020</guid><title>Sponsor: Working Copy</title><description>Thanks a lot to Working Copy for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/workingcopy-june-2020</link><pubDate>Thu, 25 Jun 2020 22:22:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to indie developer Anders Borum for sponsoring Swift by Sundell this week to promote his fantastic iOS Git client <em><a href="https://itunes.apple.com/app/apple-store/id896694807?pt=15897&ct=swiftbysundell&mt=8">Working Copy</a></em>.</p><p>If you do any sort of Git-related work on your iPad, then I really recommend trying out Working Copy. It‚Äôs fast, easy to use, and gives you access to many powerful Git features through an elegant, iOS-native UI. Clone repos, create branches and commits, view diffs, and push changes ‚Äî all from your iPad!</p><p>Working Copy also connects beautifully to many different system features ‚Äî such as the Files app, Shortcuts, and the iOS share sheet ‚Äî and Anders has been constantly improving the app ever since it was launched just after WWDC 2014.</p><p>During the week of WWDC20, you‚Äôll get <strong>25% off the Pro version</strong> of Working Copy, so <a href="https://itunes.apple.com/app/apple-store/id896694807?pt=15897&ct=swiftbysundell&mt=8">check it out today</a>, and make sure to unlock the Pro version before the week is over to get that really nice discount, and to support two indie developers ‚Äî both Anders and me ‚Äî at the same time.</p><p><strong><a href="https://itunes.apple.com/app/apple-store/id896694807?pt=15897&ct=swiftbysundell&mt=8">Download Working Copy from the App Store</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/a-first-look-at-swiftui-stateobject</guid><title>Tip: A first look at SwiftUI‚Äôs new StateObject property wrapper</title><description>How SwiftUI‚Äôs new StateObject property wrapper works, and how it compares to ObservedObject.</description><link>https://www.swiftbysundell.com/tips/a-first-look-at-swiftui-stateobject</link><pubDate>Thu, 25 Jun 2020 13:10:00 +0200</pubDate><content:encoded><![CDATA[<p>Being a declarative UI framework, state and data management is an incredibly important part of SwiftUI. Since day one, it has been shipping with a suite of protocols and property wrappers that let us define, update and observe our view‚Äôs data in various ways ‚Äî and this year, there‚Äôs a new member of that family: <code>StateObject</code>.</p><p class="info">‚ö†Ô∏è This article is covering technologies that are currently in beta as part of Xcode 12, so it‚Äôs possible that some of the APIs used will change during the beta period.</p><p>Let‚Äôs say that we‚Äôre working on an app for browsing movies, and that we‚Äôre storing those movies using a <code>MovieStore</code> class ‚Äî which is an <code>ObservableObject</code> that exposes an array of <code>Movie</code> values using the <code>Published</code> property wrapper:</p><pre class="splash"><code><span class="s-keyword">class</span> MovieStore: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">@Published private(set) var</span> movies: [<span class="s-type">Movie</span>]
    
    ...
}</code></pre><p>Before the version of SwiftUI included in Xcode 12, we might‚Äôve then used the <code>ObservedObject</code> property wrapper to enable a <code>MovieListView</code> to observe an injected instance of the above store class ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieListView: <span class="s-type">View</span> {
    <span class="highlight offset-adjust"><span class="s-keyword">@ObservedObject var</span> store: <span class="s-type">MovieStore</span></span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(store.<span class="s-property">movies</span>) { movie <span class="s-keyword">in</span>
                <span class="s-type">NavigationLink</span>(movie.<span class="s-property">name</span>,
                    destination: <span class="s-type">MovieDetailsView</span>(
                        store: store,
                        movieID: movie.<span class="s-property">id</span>
                    )
                )
            }
            .<span class="s-call">navigationTitle</span>(<span class="s-string">"My movies"</span>)
        }
    }
}</code></pre><p>Although the above <code>MovieListView</code> does hold a reference to the <code>MovieStore</code> that it was injected with, and can pass that store instance along to any child views that it creates (such as the above <code>MovieDetailsView</code>), our view is actually <em>not the owner</em> of that store object.</p><p>It‚Äôs important to remember that SwiftUI views are <em>not</em> view objects in the ‚Äúclassic sense‚Äù, but rather lightweight value <em>descriptions</em> of our UI, which means that our view instances don‚Äôt really have lifecycles like class instances do. Therefore, we always need to make sure to retain any <code>ObservableObject</code> instances that we inject into our views elsewhere ‚Äî for example within some form of dependency container.</p><p>This is where <code>StateObject</code> comes in, which provides a built-in way to have one of our views <em>assume ownership</em> over an <code>ObservableObject</code>. That way, we no longer need to retain that object elsewhere, since SwiftUI will manage it for us automatically, even as our views get updated and their values recreated.</p><p>Something that‚Äôs really nice is that if we wanted to change our above <code>MovieListView</code> to now use <code>StateObject</code> instead, we can actually keep the whole <code>body</code> of our view exactly the same ‚Äî all that we need to do is replace <code>ObservedObject</code> with <code>StateObject</code>, and give our <code>store</code> property a default value ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieListView: <span class="s-type">View</span> {
    <span class="highlight offset-adjust"><span class="s-keyword">@StateObject private var</span> store = <span class="s-type">MovieStore</span>()</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        ...
    }
}</code></pre><p>Now, this doesn‚Äôt mean that <code>StateObject</code> is always a better alternative compared to <code>ObservedObject</code> ‚Äî both have pros and cons. We should still keep using <code>ObservedObject</code> for injected dependencies that are retained and managed outside of our view hierarchy, while <code>StateObject</code> can be a great alternative for reference types that are used to keep track of a view‚Äôs internal state.</p>]]></content:encoded></item><item><guid isPermaLink="false">swiftbysundell/links/daily-wwdc20-coverage</guid><title>Link: WWDC by Sundell &amp; Friends</title><description></description><link>https://wwdcbysundell.com</link><pubDate>Mon, 22 Jun 2020 14:30:00 +0200</pubDate><content:encoded><![CDATA[<p>Just like last year, I‚Äôll be covering WWDC and its key announcements on my spin-off site <em><a href="https://wwdcbysundell.com">WWDC by Sundell</a></em>. The coverage will be highly technical, feature code samples and first looks at some of the new APIs and frameworks, and everything will be completely free for anyone to access.</p><p>What‚Äôs new this year, though, is that I‚Äôve invited some of my friends from around the Apple developer community to share their thoughts and first impressions on the site as well, so this year it‚Äôs not just <em>WWDC by Sundell</em> ‚Äî it‚Äôs <em>WWDC by Sundell &amp; Friends</em>.</p><p>I hope you‚Äôll <a href="https://wwdcbysundell.com">enjoy the site</a>, and have a great WWDC week!</p><p class="info">Just like Swift by Sundell, the WWDC site also has its <a href="https://wwdcbysundell.com/feed.rss">own RSS feed</a> that you can subscribe to, if you‚Äôd like.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2020</guid><title>A Swift developer‚Äôs WWDC dreams - 2020 edition</title><description>With just a few hours to go until WWDC20 kicks off with the first ever online-only Apple keynote, I thought I‚Äôd do the same thing as I did last year, and share a few of my biggest Swift-related dreams for this upcoming WWDC.</description><link>https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2020</link><pubDate>Sun, 21 Jun 2020 17:25:00 +0200</pubDate><content:encoded><![CDATA[<p>With just a few hours to go until WWDC20 kicks off with the first ever online-only Apple keynote, I thought I‚Äôd do the same thing as I did <a href="https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams">last year</a>, and share a few of my biggest Swift-related dreams for this upcoming WWDC.</p><p>These are not really predictions, nor are they based on any form of insider information ‚Äî instead they‚Äôre simply my biggest wishes for Apple‚Äôs upcoming conference when it comes to Swift and its related tooling. Let‚Äôs jump right in!</p><h2>SwiftUI 2.0</h2><p>Whether or not you consider SwiftUI in its current state to be ‚Äúproduction ready‚Äù, I think it‚Äôs fair to say that a lot of developers are anticipating significant upgrades to Apple‚Äôs new UI framework during this year‚Äôs conference.</p><p>While I know from speaking to <a href="https://www.swiftbysundell.com/podcast/59">Josh Shaffer on the podcast</a> that Apple deliberately kept the initial API of SwiftUI narrow, in order to focus on its core set of building blocks during its first year as a public framework, I‚Äôd expect its scope to grow significantly with this year‚Äôs release.</p><p>Besides the classic ‚Äúbug fixes and performance improvements‚Äù, I‚Äôd personally like to see changes such as a SwiftUI-native equivalent to UIKit‚Äôs <code>UICollectionView</code>, built-in support for other common views (such as activity indicators and map views), and a more powerful, <code>NSAttributedString</code>-style text API.</p><p>Although we‚Äôve already been able to add support for the above types of views ourselves ‚Äî for example by bringing existing <code>UIKit</code>-based views into SwiftUI using <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match"><code>UIViewRepresentable</code></a>, or by building brand new ones using SwiftUI itself ‚Äî having a wider set of commonly used views built into the framework would be incredibly convenient.</p><p>Let‚Äôs take a closer look at <code>UICollectionView</code> as an example. While it‚Äôs totally possible to quickly create a very basic version of of a grid-based SwiftUI view, recreating the entire collection view API would require a lot more work. Here‚Äôs what such a basic grid implementation could look like, using SwiftUI‚Äôs <code>ViewBuilder</code> <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/%23function-builders">function builder</a>, along with nested instances of <code>HStack</code> and <code>VStack</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Grid&lt;Cell: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">typealias</span> Position = (x: <span class="s-type">Int</span>, y: <span class="s-type">Int</span>)

    <span class="s-keyword">private let</span> content: (<span class="s-type">Position</span>) -&gt; <span class="s-type">Cell</span>
    <span class="s-keyword">private let</span> size: (width: <span class="s-type">Int</span>, height: <span class="s-type">Int</span>)

    <span class="s-keyword">init</span>(width: <span class="s-type">Int</span>,
         height: <span class="s-type">Int</span>,
         <span class="s-keyword">@ViewBuilder</span> content: <span class="s-keyword">@escaping</span> (<span class="s-type">Position</span>) -&gt; <span class="s-type">Cell</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = content
        <span class="s-keyword">self</span>.<span class="s-property">size</span> = (width, height)
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">ForEach</span>(<span class="s-number">0</span>..&lt;size.<span class="s-property">width</span>) { x <span class="s-keyword">in</span>
                <span class="s-type">VStack</span> {
                    <span class="s-type">ForEach</span>(<span class="s-number">0</span>..&lt;<span class="s-keyword">self</span>.<span class="s-property">size</span>.<span class="s-property">height</span>) { y <span class="s-keyword">in
                        self</span>.<span class="s-call">content</span>((x, y))
                    }
                }
            }
        }
    }
}</code></pre><p class="info">The above implementation uses tuples as lightweight types. Check out <a href="https://www.swiftbysundell.com/articles/using-tuples-as-lightweight-types-in-swift">this article</a> to learn more.</p><p>The fact that the above is all that it takes to create a basic grid view is really a testament to just how powerful SwiftUI‚Äôs API already is, but the above implementation is still a <em>far cry</em> from all of the flexibility that <code>UICollectionView</code> (and its AppKit equivalent) offers, especially when it comes to things like flow layouts and dynamic item sizes.</p><h2>Swift Package Manager for apps and playgrounds</h2><p>Ever since Xcode started offering <a href="https://wwdcbysundell.com/2019/xcode-swiftpm-first-look">built-in support</a> for the Swift Package Manager as part of last year‚Äôs release of Xcode 11, I think it‚Äôs fair to say that Swift‚Äôs official dependency manager has been significantly growing in both power and popularity.</p><p>While it‚Äôs always been possible to <em>build</em> a Swift package using Xcode (using the <code>generate-xcodeproj</code> command), this new built-in support both meant that apps could now easily import Swift packages as dependencies, and that package authors could directly open their projects in Xcode without first having to generate a separate project file for them.</p><p>Now, imagine if Apple took this a step further by enabling entire iOS or Mac apps to be defined as Swift packages ‚Äî for example like this:</p><pre class="splash"><code><span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    name: <span class="s-string">"MyApp"</span>,
    products: [
        .<span class="s-call">application</span>(
            name: <span class="s-string">"MyApp"</span>,
            targets: [<span class="s-string">"MyApp-iOS"</span>, <span class="s-string">"MyApp-macOS"</span>]
        )
    ],
    dependencies: [
        .<span class="s-call">package</span>(
            name: <span class="s-string">"Files"</span>,
            url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
            from: <span class="s-string">"4.0.0"</span>
        ),
        .<span class="s-call">package</span>(
            name: <span class="s-string">"Codextended"</span>,
            url: <span class="s-string">"https://github.com/johnsundell/codextended.git"</span>,
            from: <span class="s-string">"0.3.0"</span>
        )
    ],
    targets: [
        .<span class="s-call">target</span>(
            name: <span class="s-string">"MyApp-iOS"</span>,
            dependencies: [<span class="s-string">"Files"</span>, <span class="s-string">"Codextended"</span>],
            platform: .<span class="s-dotAccess">iOS</span>
        ),
        .<span class="s-call">target</span>(
            name: <span class="s-string">"MyApp-macOS"</span>,
            dependencies: [<span class="s-string">"Files"</span>, <span class="s-string">"Codextended"</span>],
            platform: .<span class="s-dotAccess">macOS</span>
        ),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"MyAppTests-iOS"</span>,
            dependencies: [<span class="s-string">"MyApp-iOS"</span>]
        ),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"MyAppTests-macOS"</span>,
            dependencies: [<span class="s-string">"MyApp-macOS"</span>]
        )
    ]
)</code></pre><p>Apart from my wishful <code>.application</code> product, and the ability to declare platform constraints for individual targets, the above is a perfectly valid <code>Package.swift</code> manifest. So while I‚Äôm sure that the underlying changes needed to make the above kind of feature possible would be quite substantial, it wouldn‚Äôt necessarily require a ton of changes to the package description API itself ‚Äî since all of the pieces required to define targets and import dependencies are already there.</p><p>Combine that with the fact that SwiftPM is about to start supporting bundled resources (such as images, XIBs, or any other sort of custom files) as part of the upcoming Swift 5.3 release, and the package manager could become quite a capable tool for building entire (non-command line, non-server-side) applications.</p><p>While I‚Äôd expect an initial release of such a feature to just support a very limited amount of customization options and build settings, I think many teams would happily take that tradeoff in order to be able to completely say goodbye to Xcode project file conflicts, once and for all.</p><p>I would also really like to see the Swift Playgrounds app adopt SwiftPM as its module management tool. While I absolutely love the very lightweight way in which modules can be created within a playground ‚Äî which I also mentioned in <a href="https://www.swiftbysundell.com/articles/review-swift-playgrounds-30-for-ipad">my review of the 3.0 version of the app</a> ‚Äî being able to instantly open a Swift package (and all of its dependencies) within the Playgrounds app would be incredible, and would make it so much easier to move code between the Mac and the iPad.</p><p class="info">For more details on Swift Playgrounds‚Äô module system, listen to my <a href="https://www.swiftbysundell.com/podcast/69">podcast conversation with Holly Borla and Grace Kendall from Apple</a>, during which they went into lots of details about how the Playgrounds app was built.</p><h2>Xcode on iPad</h2><p>Along those same lines, I don‚Äôt think I would be able to put together any kind of WWDC wishlist without mentioning Xcode on iPad. As someone who loves working on both the Mac and the iPad (the Mac when I‚Äôm at my desk, the iPad everywhere else), I would love to be able to seamlessly move all of my projects between those two devices.</p><p>So often when Xcode on iPad is discussed, the conversation tends to end up with the question of whether either the iPad or the Mac is the best device for development, but I personally think that‚Äôs beside the point. I don‚Äôt want Xcode for Mac to be discontinued, and I don‚Äôt want to do <em>all</em> of my development work on the iPad ‚Äî but wouldn‚Äôt it be wonderful if we were all free to choose which device to work on at any given time, without having to jump through a ton of hoops?</p><p>Will this be the year we‚Äôll see Xcode on iPad? I honestly don‚Äôt know, but I <em>really</em> hope so. The current iPad Pro hardware (even the 2018 model, which I own) is more than capable of compiling and running Swift code, there‚Äôs now support for both hardware keyboards and pointing devices, and Swift Playgrounds has shown me and many others that building iOS UIs on an actual iOS device is <em>amazing</em>. The iteration speed between testing and interacting with a piece of UI, and making tweaks to it, when everything is running right directly on a touch-capable device, is simply outstanding.</p><p>Now, like I‚Äôve <a href="https://twitter.com/johnsundell/status/1252944192243937280">mentioned earlier on Twitter</a>, I don‚Äôt expect this hypothetical iPad-version of Xcode to have nearly the same amount of features as its Mac equivalent. Instead I would expect it to be a more <em>lightweight</em> version of Xcode focused on SwiftUI-based iOS app development, at least for the first iteration of it.</p><h2>End-to-end Swift</h2><p>Finally, I would love for Apple to more clearly embrace server-side Swift within Xcode and their various platform SDKs. While Apple have <a href="https://www.swiftbysundell.com/podcast/42">confirmed that they‚Äôre using server-side Swift in production themselves</a>, and while they‚Äôve made substantial investments in server-side technologies like <a href="https://github.com/apple/swift-nio">SwiftNIO</a> and <a href="https://github.com/apple/swift-crypto">Swift Crypto</a>, I have a few wishes as to how they could take things to the next level.</p><p>One significant trend within the server-side world over the past few years has been the rise of cloud (or ‚Äúserverless‚Äù) functions. It‚Äôs the idea that, rather than running any kind of server yourself, you instead just submit a piece of code to a cloud service, and then that service will automatically run that code for you and manage all required system resources ‚Äî completely automatically.</p><p>Just a few weeks ago (at the time of writing), Amazon officially launched their <em><a href="https://swift.org/blog/aws-lambda-runtime">Swift AWS Lambda Runtime</a></em>, which lets developers write such cloud functions in Swift, and then deploy and run them on Amazon‚Äôs vast AWS infrastructure. That‚Äôs incredibly cool, but I‚Äôd also love to see Apple‚Äôs own take on such a system.</p><p>As an example, imagine being able to run custom cloud functions as part of CloudKit ‚Äî for example in order to perform server-side validation of records that were sent from an iOS or Mac app, using the same <code>CKRecord</code> API that CloudKit uses on the client-side, like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> ValidationError: <span class="s-type">Error</span> {
    <span class="s-keyword">case</span> invalidRecordType
    <span class="s-keyword">case</span> missingIngredients
    ...
}

<span class="s-comment">// This function would be automatically invoked server-side by
// the CloudKit servers, and passed any CKRecord instance that
// was submitted from a client app. The function either throws
// an error, or allows the record to be saved to the database:</span>
<span class="s-keyword">func</span> validate(<span class="s-keyword">_</span> record: <span class="s-type">CKRecord</span>) <span class="s-keyword">throws</span> {
    <span class="s-keyword">guard</span> record.<span class="s-property">recordType</span> == <span class="s-string">"Recipe"</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">throw</span> <span class="s-type">ValidationError</span>.<span class="s-property">invalidRecordType</span>
    }

    <span class="s-keyword">guard let</span> ingredients = record[<span class="s-string">"ingredients"</span>] <span class="s-keyword">as</span>? [<span class="s-type">String</span>],
          !ingredients.<span class="s-property">isEmpty</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">throw</span> <span class="s-type">ValidationError</span>.<span class="s-property">missingIngredients</span>
    }
    
    ...
}</code></pre><p class="info">The above function uses Swift‚Äôs built-in error mechanism as part of its control flow. Check out <a href="https://www.swiftbysundell.com/articles/using-errors-as-control-flow-in-swift">this article</a> for more on that topic.</p><p>While the above kind of CloudKit and iCloud customization would be incredibly cool, and enable developers to iterate on their iCloud-based code without having to ship new versions of their apps ‚Äî it would perhaps be even cooler if we would be able to build <em>completely custom</em> function-based backends that would be automatically deployed on Apple‚Äôs servers.</p><p>Don‚Äôt get me wrong, projects like SwiftNIO and <a href="https://vapor.codes">Vapor</a> are incredible, and already enable server-side applications to be built in Swift ‚Äî but my final dream (for this article) is to be able to simply write a request handler like the one below, as part of an app project, and then have it be automatically synced to an Apple-provided cloud service that would host it and run it for me:</p><pre class="splash"><code><span class="s-comment">// This function returns a note based on a parameter that was
// sent from the client, and uses Combine to facilitate the
// communication between the server and the client:</span>
<span class="s-keyword">func</span> handleRequest(<span class="s-keyword">_</span> request: <span class="s-type">Request</span>,
                   responder: <span class="s-type">ResponderPublisher</span>) {
    <span class="s-keyword">guard let</span> noteID = request.<span class="s-call">parameter</span>(named: <span class="s-string">"id"</span>) <span class="s-keyword">else</span> {
        <span class="s-keyword">let</span> error = <span class="s-type">MissingParameterError</span>(name: <span class="s-string">"id"</span>)
        <span class="s-keyword">return</span> responder.<span class="s-call">send</span>(completion: .<span class="s-call">failure</span>(error))
    }

    <span class="s-keyword">guard let</span> data = <span class="s-type">KeyValueStore</span>.<span class="s-call">data</span>(forKey: noteID) <span class="s-keyword">else</span> {
        <span class="s-keyword">let</span> error = <span class="s-type">UnknownNoteError</span>(id: noteID)
        <span class="s-keyword">return</span> responder.<span class="s-call">send</span>(completion: .<span class="s-call">failure</span>(error))
    }

    responder.<span class="s-call">send</span>(data)
    responder.<span class="s-call">send</span>(completion: .<span class="s-dotAccess">finished</span>)
}</code></pre><p>While the above is a really simple example in the grand scheme of things, I think if app developers would be able to write and deploy small cloud functions using a language and set of frameworks that they‚Äôre already familiar with (such as <a href="https://www.swiftbysundell.com/basics/combine">Combine</a>), then that could enable many kinds of apps to utilize dynamic, server-side functionality ‚Äî without requiring those developers to either maintain their own servers, or rely on a third-party service.</p><h2>Conclusion</h2><p>So those are my biggest Swift-related dreams for this year‚Äôs WWDC. Hope you enjoyed reading this article, and if you did, then make sure to check out <a href="https://wwdcbysundell.com">WWDC by Sundell &amp; Friends</a> ‚Äî a brand new website on which me and some of my friends will cover WWDC20 in great detail all throughout next week.</p><p>What do you think? Do you share some of my dreams, or do you have any other Swift-related things that you‚Äôd like to see Apple introduce next week? Let me know, either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/organizing-default-argument-values</guid><title>Tip: Organizing default argument values</title><description></description><link>https://www.swiftbysundell.com/tips/organizing-default-argument-values</link><pubDate>Sat, 20 Jun 2020 15:45:00 +0200</pubDate><content:encoded><![CDATA[<p>Using <a href="https://www.swiftbysundell.com/articles/default-arguments-in-swift">default arguments</a> can be a great way to make a given type or function easier to use, and can let us achieve a certain level of consistency between call sites that don‚Äôt require any form of customization.</p><p>As an example, let‚Äôs say that we‚Äôre working on an <code>ImageLoader</code>, which is initialized with a <code>ImageLoadingSettings</code> value that determines how each image loader instance should behave. Since we don‚Äôt want to <em>require</em> such a settings value to be explicitly passed, we‚Äôll default to creating a new instance of it as a convenience ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    <span class="s-keyword">private let</span> settings: <span class="s-type">ImageLoadingSettings</span>

    <span class="s-keyword">init</span>(settings: <span class="s-type">ImageLoadingSettings</span> = .<span class="s-keyword">init</span>()) {
        <span class="s-keyword">self</span>.<span class="s-property">settings</span> = settings
    }
    
    ...
}</code></pre><p>For structs, such as the <code>ImageLoadingSettings</code> type that we used above, we can also make use of default parameter values ‚Äî which will automatically get translated into default initializer arguments by the compiler:</p><pre class="splash"><code><span class="s-keyword">struct</span> ImageLoadingSettings {
    <span class="s-keyword">var</span> baseURL = <span class="s-type">URL</span>(string: <span class="s-string">"https://my-cdn.com"</span>)!
    <span class="s-keyword">var</span> timeoutInterval: <span class="s-type">TimeInterval</span> = <span class="s-number">120</span>
    <span class="s-keyword">var</span> defaultFormat = <span class="s-type">ImageFormat</span>.<span class="s-property">png</span>
}</code></pre><p class="info">Note that the memberwise initializers that the compiler automatically synthesizes are only visible internally within the same module that a given type is defined in. To learn more, check out <a href="https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used">‚ÄúWhen can a struct‚Äôs memberwise initializer be used?‚Äù</a>.</p><p>Another option, which also works for public APIs that should be accessible outside of the module that they‚Äôre defined in, is to use <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static properties or factory methods</a>. For example, here‚Äôs how we could extend <code>ImageLoadingSettings</code> with a static <code>default</code> property that returns a new instance populated with the default settings values:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ImageLoadingSettings</span> {
    <span class="s-keyword">static var</span> `default`: <span class="s-type">ImageLoadingSettings</span> {
        <span class="s-type">ImageLoadingSettings</span>(
            baseURL: <span class="s-type">URL</span>(string: <span class="s-string">"https://my-cdn.com"</span>)!,
            timeoutInterval: <span class="s-number">120</span>,
            defaultFormat: .<span class="s-dotAccess">png</span>
        )
    }
}</code></pre><p>With the above in place, we can now use this really neat dot-syntax to define our default argument from before:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    <span class="s-keyword">private let</span> settings: <span class="s-type">ImageLoadingSettings</span>

    <span class="s-keyword">init</span>(settings: <span class="s-type">ImageLoadingSettings</span> = .<span class="s-dotAccess">default</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">settings</span> = settings
    }
    
    ...
}</code></pre><p>While either of the above two approaches tend to work great for types that we‚Äôve created ourselves ‚Äî they can be a bit tricky to use when it comes to types that ship as part of the standard library.</p><p>For example, let‚Äôs now say that we‚Äôre looking to provide a convenient way to initialize an <code>ImageTransformer</code> with an array of default <code>ImageEffect</code> values. One way to model those values would be to use a slight twist on the static property approach that we took above, and add such a property to the <code>Array</code> type itself, using a <a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4/%23same-type-constraints">same-type constrained</a> extension:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Array</span> <span class="s-keyword">where</span> <span class="s-type">Element</span> == <span class="s-type">ImageEffect</span> {
    <span class="s-keyword">static var</span> defaultEffects: <span class="s-type">Self</span> {
        [.<span class="s-dotAccess">increaseContrast</span>, .<span class="s-dotAccess">normalizeColors</span>, .<span class="s-dotAccess">cropToSquare</span>]
    }
}

<span class="s-keyword">class</span> ImageTransformer {
    <span class="s-keyword">private let</span> effects: [<span class="s-type">ImageEffect</span>]

    <span class="s-comment">// We can again use this really nice dot-syntax to specify
    // our default argument value:</span>
    <span class="s-keyword">init</span>(effects: [<span class="s-type">ImageEffect</span>] = .<span class="s-dotAccess">defaultEffects</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">effects</span> = effects
    }
    
    ...
}</code></pre><p>However, while the above initializer looks really nice, it‚Äôs arguably a bit strange to have the <code>Array</code> type be aware of what our image transformer‚Äôs defaults are ‚Äî even if we make that extension private (which works as long as our <code>ImageTransformer</code> remains internal in terms of <a href="https://www.swiftbysundell.com/basics/access-control">access level</a>).</p><p>So an alternative way to accomplish the exact same thing would be to instead add that static property to our <code>ImageTransformer</code> type itself ‚Äî because it turns out that we can reference a type‚Äôs static properties directly within its initializer parameter list, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageTransformer {
    <span class="s-keyword">private let</span> effects: [<span class="s-type">ImageEffect</span>]

    <span class="s-keyword">init</span>(effects: [<span class="s-type">ImageEffect</span>] = defaultEffects) {
        <span class="s-keyword">self</span>.<span class="s-property">effects</span> = effects
    }
    
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">ImageTransformer</span> {
    <span class="s-keyword">static var</span> defaultEffects: [<span class="s-type">ImageEffect</span>] {
        [.<span class="s-dotAccess">increaseContrast</span>, .<span class="s-dotAccess">normalizeColors</span>, .<span class="s-dotAccess">cropToSquare</span>]
    }
}</code></pre><p>Of course, we could‚Äôve also defined the above <code>defaultEffects</code> property within our main type declaration, rather than using an extension ‚Äî but the above approach sort of gives us a nice separation between our main type declaration and its default values.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/uidesignmanager-june-2020</guid><title>Sponsor: UIDesignManager</title><description>Thanks a lot to UIDesignManager for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/uidesignmanager-june-2020</link><pubDate>Fri, 19 Jun 2020 12:45:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to the team behind <a href="https://uidesignmanager.com/?utm_source=swiftbysundell">UIDesignManager</a> for sponsoring Swift by Sundell this week, which helps me keep the site free and available to everyone around the world.</p><p>UIDesignManager is a tool that lets developers and designers quickly iterate on an app‚Äôs UI components ‚Äî completely visually ‚Äî without having to release a new version of it, whether that‚Äôs to TestFlight, or to the App Store.</p><p>If you‚Äôre building apps for clients, UIDesignManager can enable your clients to make tweaks to their apps on the fly, right on an iOS device, using the UIDesignStudio app. It works with both UIKit and SwiftUI, and you can try it for free for 30 days ‚Äî so give it a go, and see just how fast it could let you iterate on your app‚Äôs UI.</p><p><a href="https://uidesignmanager.com/?utm_source=swiftbysundell">Try UIDesignManager for free</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/75</guid><title>Podcast: ‚ÄúThe Swift package ecosystem‚Äù, with special guests Dave Verwer and Sven A. Schmidt</title><description>Dave Verwer and Sven A. Schmidt join John to talk about their newly launched Swift Package Index, and what the overall state of Swift‚Äôs package ecosystem currently is. Also, dependency management, composing libraries, deploying server-side Swift in production, and much more.</description><link>https://www.swiftbysundell.com/podcast/75</link><pubDate>Fri, 19 Jun 2020 10:45:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell75.mp3" type="audio/mpeg"/></audio><p>Dave Verwer and Sven A. Schmidt join John to talk about their newly launched Swift Package Index, and what the overall state of Swift‚Äôs package ecosystem currently is. Also, dependency management, composing libraries, deploying server-side Swift in production, and much more.</p><h2>Sponsors</h2><ul><li><strong><a href="https://nordvpn.com/sundell">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you‚Äôre on. Get 50% off their one-year plan at <a href="https://nordvpn.com/sundell">nordvpn.com/sundell</a>, or when using offer code <em>SUNDELL</em>.</li><li><strong><a href="https://bitrise.io/swift">Bitrise</a>:</strong> Fast, stable and highly customizable continuous integration. Automatically build, test and distribute your app on every single commit that you make. Get started for free at <a href="https://bitrise.io/swift">bitrise.io/swift</a>, and also check out their new podcast <a href="https://blog.bitrise.io/mobile-devops-is-a-thing-a-podcast-by-bitrise">‚ÄúMobile DevOps is a Thing!‚Äù</a>.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/daveverwer">Dave on Twitter</a></li><li><a href="https://twitter.com/_sa_s">Sven on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://iosdevweekly.com">iOS Dev Weekly</a></li><li><a href="https://swiftpackageindex.com">The Swift Package Index</a></li><li><a href="https://finestructure.co/hummingbird">Hummingbird</a></li><li><a href="https://finestructure.co/revisor">Revisor</a></li><li><a href="https://github.com/JohnSundell/Plot">Plot</a></li><li><a href="https://github.com/finestructure/Arena">Arena</a></li><li><a href="https://vapor.codes">Vapor</a></li><li><a href="https://www.docker.com">Docker</a></li><li><a href="https://www.macstadium.com/orka">Orka</a></li><li><a href="https://forums.swift.org/t/swift-package-registry-service/37219">The GitHub package registry pitch on the Swift forums</a></li><li><a href="http://flask.pocoo.org">Flask</a></li><li><a href="https://www.djangoproject.com">Django</a></li><li><a href="https://daveverwer.com">Dave‚Äôs website</a></li><li><a href="https://finestructure.co">Sven‚Äôs website</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/useful-apis-when-writing-scripts-and-tools-in-swift</guid><title>Useful APIs when writing scripts and tools in Swift</title><description>Let‚Äôs take a look at a few key APIs and techniques that can be really useful when building custom developer tools, scripts, or other kinds of automation, in Swift.</description><link>https://www.swiftbysundell.com/articles/useful-apis-when-writing-scripts-and-tools-in-swift</link><pubDate>Sun, 14 Jun 2020 21:50:00 +0200</pubDate><content:encoded><![CDATA[<p>When building apps, it‚Äôs really common to rely on various kinds of scripts and custom developer tools in order to build, ship, and debug a code base. From formatting or validating both code-level symbols and linked resources, to running different kinds of tests, and even generating code ‚Äî there are so many different tasks that can be automated one way or another.</p><p>While Swift‚Äôs heavy focus on compile-time safety and strong types might initially make it seem like an odd choice for writing scripts and automation, it does bring a lot of quite unique advantages to the table ‚Äî such as enabling us to share code between an app and the scripts used to develop it, or just the fact that there‚Äôs no <em>context switching</em> needed to jump between working on a tool and an app that uses it.</p><p>So this week, let‚Äôs take a look at a few key APIs that can come very much in handy when using Swift in the context of scripting and tooling ‚Äî focusing on those that come built-in as part of either the Swift standard library, or macOS as a platform.</p><p class="info">This article assumes that you are somewhat familiar with the Swift Package Manager, and won‚Äôt go into details when it comes to how to set up a Swift package for writing a script or custom developer tool, since that was covered in <a href="https://www.swiftbysundell.com/articles/building-a-command-line-tool-using-the-swift-package-manager"><em>‚ÄúBuilding a command line tool using the Swift Package Manager‚Äù</em></a>.</p><h2>Accepting arguments</h2><p>Let‚Äôs start by taking a look at a few different ways of handling input within command line tools ‚Äî with the most basic of which being to simply access the static <code>arguments</code> property on the built-in <code>CommandLine</code> type. That property contains an array of strings representing the various arguments that were passed when invoking our script or tool on the command line, and also includes the tool‚Äôs own <em>execution path</em> as the first element.</p><p>Here‚Äôs how we might use that API to extract a few parameters within a tool used to resize a given image:</p><pre class="splash"><code><span class="s-keyword">let</span> arguments = <span class="s-type">CommandLine</span>.<span class="s-property">arguments</span>

<span class="s-comment">// Since the first element is our tool's execution path, we'll
// start extracting our arguments from index 1, rather than 0:</span>
<span class="s-keyword">let</span> imagePath = arguments[<span class="s-number">1</span>]
<span class="s-keyword">let</span> width = <span class="s-type">Double</span>(arguments[<span class="s-number">2</span>])
<span class="s-keyword">let</span> height = <span class="s-type">Double</span>(arguments[<span class="s-number">3</span>])</code></pre><p class="info">Tip: When working on a script or tool in Xcode, we can specify what arguments to send to our program by editing its <code>Run</code> scheme (which can be opened by pressing <code>‚å• + ‚åò + R</code>).</p><p>However, one problem with the above code is that it‚Äôll cause a crash if fewer than three arguments were passed ‚Äî which isn‚Äôt great ‚Äî so let‚Äôs also add a <code>guard</code> statement for handling those situations. If we received fewer arguments than expected, then we‚Äôll use the <code>exit</code> function to terminate our program with a given <em>exit code</em>, after printing an error message:</p><pre class="splash"><code><span class="s-keyword">let</span> arguments = <span class="s-type">CommandLine</span>.<span class="s-property">arguments</span>

<span class="s-keyword">guard</span> arguments.<span class="s-property">count</span> &gt; <span class="s-number">3</span> <span class="s-keyword">else</span> {
    <span class="s-call">print</span>(<span class="s-string">"""
    Error: Expected 3 arguments: imagePath, width, and height.
    """</span>)
    <span class="s-call">exit</span>(<span class="s-number">1</span>)
}

...</code></pre><p>While using <code>CommandLine.arguments</code> is a really convenient way of accessing all of a program‚Äôs arguments in a linear fashion, sometimes we might want to retrieve the value for a <em>named argument</em> ‚Äî that is, two arguments that make up a key/value pair.</p><p>While we could of course iterate through each argument and create a key/value map manually, we can actually use Foundation‚Äôs <a href="https://www.swiftbysundell.com/articles/the-power-of-userdefaults-in-swift"><code>UserDefaults</code></a> type to retrieve any named command line argument passed into our program ‚Äî completely automatically:</p><pre class="splash"><code><span class="s-comment">// This will parse the values passed for "-width" and "-height" on
// the command line (that is, each key name prefixed with a dash):</span>
<span class="s-keyword">let</span> namedArguments = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>
<span class="s-keyword">let</span> width = namedArguments.<span class="s-call">double</span>(forKey: <span class="s-string">"width"</span>)
<span class="s-keyword">let</span> height = namedArguments.<span class="s-call">double</span>(forKey: <span class="s-string">"height"</span>)</code></pre><p>What‚Äôs great about using <code>UserDefaults</code> to parse command line arguments (besides the fact that it‚Äôs a built-in API), is that we can choose whether we want it to return a specific type (such as <code>Double</code>, like above), or an optional raw <code>String</code>. Here‚Äôs how we might extract such a string, then transform it into a URL (using <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap"><code>flatMap</code></a>), and finally map any non-<code>nil</code> value into a <code>downloadHTML</code> function:</p><pre class="splash"><code><span class="s-comment">// When calling a throwing function within the global scope of
// a command line tool, we can simply prefix it with 'try', without
// first having to wrap it within a 'do' clause (unless we want
// to customize exactly how an error gets presented to the user):</span>
<span class="s-keyword">let</span> html = <span class="s-keyword">try</span> namedArguments
    .<span class="s-call">string</span>(forKey: <span class="s-string">"url"</span>)
    .<span class="s-call">flatMap</span>(<span class="s-type">URL</span>.<span class="s-property">init</span>)
    .<span class="s-call">map</span>(downloadHTML)</code></pre><p>Although <code>UserDefaults</code> also offers a <code>url</code> API that returns a <code>URL</code> value, those URLs are assumed to be local file URLs ‚Äî so in case we‚Äôre looking to use remote web URLs, then extracting raw strings is typically a better option.</p><p class="info">While this article is focused on APIs that ship as part of the system, it‚Äôs also worth pointing out that Apple offers a much more powerful framework for parsing command line arguments, called <em>Swift Argument Parser</em>, which is available as a Swift package <a href="https://github.com/apple/swift-argument-parser">on GitHub</a>.</p><h2>Networking and other asynchronous tasks</h2><p>Next, let‚Äôs take a look at a few ways of implementing that <code>downloadHTML</code> function that we called above.</p><p>Networking, and other tasks that are highly asynchronous, can at first seem a bit tricky to perform within the context of a script or tool, since ‚Äî unlike apps ‚Äî command line tools are executed synchronously from top to bottom, and then immediately terminated. So how can we ensure that our program keeps running while we wait for an asynchronous task to complete?</p><p>One way to do that is to use Grand Central Dispatch‚Äôs <a href="https://www.swiftbysundell.com/articles/a-deep-dive-into-grand-central-dispatch-in-swift/%23waiting-for-asynchronous-tasks-with-dispatchsemaphore"><code>DispatchSempahore</code></a> API, which enables us to synchronously wait for an operation that‚Äôs being performed on a background queue. Using that, along with <code>URLSession</code> and its new <a href="https://www.swiftbysundell.com/basics/combine">Combine-powered</a> <code>dataTaskPublisher</code> API, we could download a string over the network like this:</p><pre class="splash"><code><span class="s-keyword">func</span> downloadHTML(from url: <span class="s-type">URL</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">let</span> semaphore = <span class="s-type">DispatchSemaphore</span>(value: <span class="s-number">0</span>)
    <span class="s-keyword">var</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">String</span>, <span class="s-type">Error</span>&gt;?

    <span class="s-keyword">let</span> publisher = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>
        .<span class="s-call">dataTaskPublisher</span>(for: url)
        .<span class="s-call">map</span>(\.<span class="s-property">data</span>)
        .<span class="s-call">map</span> { <span class="s-type">String</span>(decoding: $0, as: <span class="s-type">UTF8</span>.<span class="s-keyword">self</span>) }

    <span class="s-keyword">let</span> cancellable = publisher.<span class="s-call">sink</span>(
        receiveCompletion: { completion <span class="s-keyword">in
            switch</span> completion {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                result = .<span class="s-call">failure</span>(error)
            <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
                <span class="s-keyword">break</span>
            }

            <span class="s-comment">// Calling 'signal' on our semaphore will cause our
            // program to keep executing from the point at which
            // 'wait' was called.</span>
            semaphore.<span class="s-call">signal</span>()
        },
        receiveValue: { value <span class="s-keyword">in</span>
            result = .<span class="s-call">success</span>(value)
        }
    )

    <span class="s-keyword">_</span> = semaphore.<span class="s-call">wait</span>(timeout: .<span class="s-call">now</span>() + <span class="s-number">20</span>)

    <span class="s-keyword">guard let</span> html = <span class="s-keyword">try</span> result?.<span class="s-call">get</span>() <span class="s-keyword">else</span> {
        <span class="s-comment">// If no result was received after 20 seconds, we'll
        // consider our operation to have timed out, and will
        // both cancel our publisher, and throw a custom error:</span>
        cancellable.<span class="s-call">cancel</span>()
        <span class="s-keyword">throw</span> <span class="s-type">NetworkTimeoutError</span>(url: url)
    }

    <span class="s-keyword">return</span> html
}</code></pre><p class="info">Note that in order to use APIs that were introduced in macOS 10.15 Catalina, such as Combine, we need to add the <code>platforms: [.macOS(.v10_15)]</code> argument to our <code>Package.swift</code> manifest. Also worth noting is that Combine is not (yet) available on Linux, which might not be a problem, depending on how we‚Äôre planning to use the tool that we‚Äôre building.</p><p>While the above code works, there are very few things about it that are network-specific ‚Äî so if we wanted to, we could also generalize it into a method that lets us <em>await</em> the result of any Combine <code>Publisher</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Publisher</span> {
    <span class="s-keyword">private static var</span> defaultTimeoutMessage: <span class="s-type">String</span> {
        <span class="s-string">"An async operation timed out"</span>
    }

    <span class="s-keyword">func</span> awaitOutput(
        withTimeoutMessage timeoutMessage: <span class="s-type">String</span> = defaultTimeoutMessage,
        forTimeInterval timeInterval: <span class="s-type">TimeInterval</span> = <span class="s-number">20</span>
    ) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Output</span> {
        <span class="s-keyword">let</span> semaphore = <span class="s-type">DispatchSemaphore</span>(value: <span class="s-number">0</span>)
        <span class="s-keyword">var</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">Output</span>, <span class="s-type">Failure</span>&gt;?

        <span class="s-keyword">let</span> cancellable = <span class="s-call">sink</span>(
            receiveCompletion: { completion <span class="s-keyword">in
                switch</span> completion {
                <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                    result = .<span class="s-call">failure</span>(error)
                <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
                    <span class="s-keyword">break</span>
                }

                semaphore.<span class="s-call">signal</span>()
            },
            receiveValue: { value <span class="s-keyword">in</span>
                result = .<span class="s-call">success</span>(value)
            }
        )

        <span class="s-keyword">_</span> = semaphore.<span class="s-call">wait</span>(timeout: .<span class="s-call">now</span>() + timeInterval)

        <span class="s-keyword">guard let</span> output = <span class="s-keyword">try</span> result?.<span class="s-call">get</span>() <span class="s-keyword">else</span> {
            cancellable.<span class="s-call">cancel</span>()
            <span class="s-keyword">throw</span> <span class="s-type">TimeoutError</span>(description: timeoutMessage)
        }

        <span class="s-keyword">return</span> output
    }
}</code></pre><p>With the above in place, we can now drastically simplify our <code>downloadHTML</code> function, which can now consist of a single Combine pipeline:</p><pre class="splash"><code><span class="s-keyword">func</span> downloadHTML(from url: <span class="s-type">URL</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">try</span> <span class="s-type">URLSession</span>.<span class="s-property">shared</span>
        .<span class="s-call">dataTaskPublisher</span>(for: url)
        .<span class="s-call">map</span>(\.<span class="s-property">data</span>)
        .<span class="s-call">map</span> { <span class="s-type">String</span>(decoding: $0, as: <span class="s-type">UTF8</span>.<span class="s-keyword">self</span>) }
        .<span class="s-call">awaitOutput</span>(withTimeoutMessage: <span class="s-string">"""
        Downloading HTML from '</span>\(url)<span class="s-string">' timed out.
        """</span>)
}</code></pre><p>Really cool! However, since we‚Äôre not just looking to perform this particular task, but rather our entire program, in a synchronous fashion ‚Äî another option would be to simply initialize a <code>Data</code> instance with the URL that we‚Äôre looking to load, and the system will then take care of the rest, completely synchronously:</p><pre class="splash"><code><span class="s-keyword">func</span> downloadHTML(from url: <span class="s-type">URL</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> <span class="s-type">Data</span>(contentsOf: url)
    <span class="s-keyword">return</span> <span class="s-type">String</span>(decoding: data, as: <span class="s-type">UTF8</span>.<span class="s-keyword">self</span>)
}</code></pre><p>We could even call the above <code>init(contentsOf:)</code> initializer directly on <code>String</code>, which would let us perform our entire HTML loading process inline within our tool‚Äôs global scope, without the need for any additional code ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">let</span> html = <span class="s-keyword">try</span> namedArguments
    .<span class="s-call">string</span>(forKey: <span class="s-string">"url"</span>)
    .<span class="s-call">flatMap</span>(<span class="s-type">URL</span>.<span class="s-property">init</span>)
    .<span class="s-call">map</span>(<span class="s-type">String</span>.<span class="s-property">init</span>)</code></pre><p>Now it might seem like the <code>Publisher</code> extension that we initially wrote is somewhat useless, given that we were able to completely remove it by using the built-in APIs that <code>Data</code> and <code>String</code> ship with, but that‚Äôs not really the case.</p><p>While the above synchronous APIs might be a better choice when writing simpler scripts that perform all of their operations in sequence ‚Äî as soon as we want to perform multiple asynchronous operations in parallel, being able to await the result of any Combine pipeline can be incredibly useful.</p><h2>Reading and writing files</h2><p>Finally, let‚Äôs take a quick look at a few built-in APIs that let us read and write files within a Swift script or tool.</p><p>Going back to <code>UserDefaults</code> for a moment ‚Äî the <code>url</code> method that we avoided earlier when handling remote web URLs is a really neat tool for extracting local file system URLs from our command line arguments ‚Äî since it‚Äôll automatically expand symbols, such as <code>~</code>, in order to give us an absolute file URL that can then be directly passed to the <code>String</code> initializer we previously used to download HTML over the network:</p><pre class="splash"><code><span class="s-keyword">let</span> fileContents = <span class="s-keyword">try</span> namedArguments
    .<span class="s-call">url</span>(forKey: <span class="s-string">"file"</span>)
    .<span class="s-call">map</span>(<span class="s-type">String</span>.<span class="s-property">init</span>)</code></pre><p>If we‚Äôd rather accept a file path based on argument index, rather than using parameter names, then we could also perform the same <em>‚Äútilde expansion‚Äù</em> that <code>UserDefaults</code> performs, using Foundation‚Äôs <code>NSString</code> type:</p><pre class="splash"><code><span class="s-comment">// This will expand the '~' symbol into the absolute path to
// the current user's home directory:</span>
<span class="s-keyword">let</span> path = <span class="s-type">NSString</span>(string: <span class="s-type">CommandLine</span>.<span class="s-property">arguments</span>[<span class="s-number">3</span>]).<span class="s-property">expandingTildeInPath</span></code></pre><p>Not only does Swift‚Äôs <code>Data</code> type let us read files by passing it a <code>URL</code>, it also lets us do the same thing but for writing. All that we have to do to write a file is to initialize a <code>Data</code> value (for example using a string‚Äôs underlying <code>utf8</code> collection) and then call the <code>write</code> method on it with the URL that we want to write our file to:</p><pre class="splash"><code><span class="s-keyword">if let</span> outputURL = namedArguments.<span class="s-call">url</span>(forKey: <span class="s-string">"output"</span>) {
    <span class="s-keyword">let</span> data = <span class="s-type">Data</span>(html.<span class="s-property">utf8</span>)
    <span class="s-keyword">try</span> data.<span class="s-call">write</span>(to: outputURL)
}</code></pre><p>The above call to <code>write</code> will either create a new file (if needed), or overwrite any existing one. Similar to how we explored multiple options for performing asynchronous tasks and networking, there are also several other built-in APIs that offer more customization options and power when it comes to file I/O (such as <code>FileManager</code>), but for simpler write operations, the above might be all that we need.</p><h2>Conclusion</h2><p>Swift can definitely be a great choice for writing scripts and other kinds of command line tools that are used to build and distribute a Swift-based app. While it might not (currently) offer the same amount of dynamism or sheer number of libraries that more established scripting languages do ‚Äî its got a solid foundation (no pun intended), and it gives us access to the same powerful suite of APIs that are used to build fully-featured Mac apps.</p><p>Hopefully, as Swift keeps maturing and its <a href="https://swiftpackageindex.com">package ecosystem</a> keeps expanding, more iOS and Mac developers will be able to quickly build their own, custom tools and augment their development process ‚Äî using a language that they‚Äôre already familiar with. Because while Xcode might be a really capable IDE, and while there are numerous open source tools available to automate a wide range of tasks, sometimes a custom script or tool can be just what we need to make our development workflow faster and more smooth.</p><p>Got questions, comments, or feedback? Feel free to contact me either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/goodnotes-june-2020</guid><title>Sponsor: GoodNotes</title><description>Thanks a lot to GoodNotes for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/goodnotes-june-2020</link><pubDate>Fri, 12 Jun 2020 11:30:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to <a href="https://www.goodnotes.com/careers">GoodNotes</a> for sponsoring Swift by Sundell this week, and I‚Äôm really excited to let you know that they‚Äôre currently hiring multiple iOS/macOS developers to join their team. So if you, or someone you know, is currently looking for a (remote-friendly) job, then make sure to <a href="https://www.goodnotes.com/careers">check out these job offers from GoodNotes</a>.</p><p>GoodNotes is an Apple-featured app that transforms your iPad, iPhone, or Mac into digital paper. It‚Äôs full of interesting and cutting-edge technologies, such as high-performance vector rendering and custom OCR, and makes great use of many of Apple‚Äôs latest OS features as well. In fact, GoodNotes is so good that Apple pre-installs it on all display iPads in their retail stores around the world.</p><p>So if you‚Äôd like to join their team of 21 people, which operates out of Hong Kong, either on-site (with a visa sponsorship) or as a remote developer ‚Äî then this is your chance to get to work on a really high-quality, top-ranking app that uses the latest and greatest technologies from Apple.</p><p><strong><a href="https://www.goodnotes.com/careers">Take a look at their job offers here</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/default-decoding-values</guid><title>Tip: Annotating properties with default decoding values</title><description></description><link>https://www.swiftbysundell.com/tips/default-decoding-values</link><pubDate>Wed, 10 Jun 2020 16:07:00 +0200</pubDate><content:encoded><![CDATA[<p>The introduction of <code>Codable</code> back in 2017 was, without a doubt, a big leap forward for Swift. Although multiple tools for encoding and decoding native Swift values to and from JSON had already been built by the community at that point, <code>Codable</code> offered an unprecedented level of convenience due to its integration with the Swift compiler itself ‚Äî enabling us to define decodable types simply by making them adopt the <code>Decodable</code> protocol, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">String</span>
    <span class="s-keyword">var</span> isFeatured: <span class="s-type">Bool</span>
}</code></pre><p>However, one feature that has been missing from <code>Codable</code> ever since its introduction is the option to add default values to certain properties (without having to make them optionals). So for example, let‚Äôs say that the above <code>isFeatured</code> property won‚Äôt always appear in the JSON data that we‚Äôll decode <code>Article</code> instances from, and that we want it to default to <code>false</code> in that case.</p><p>Even if we add that default value to our property declaration itself, the default decoding process will still fail in case that value is missing from our underlying JSON data:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">String</span>
    <span class="s-keyword">var</span> isFeatured: <span class="s-type">Bool</span> = <span class="s-keyword">false</span> <span class="s-comment">// This value isn't used when decoding</span>
}</code></pre><p>Now, we could always write our own decoding code (by overriding the default implementation of <code>init(from: Decoder)</code>), but that would require us to take over the entire decoding process ‚Äî which kind of ruins the whole convenience aspect of <code>Codable</code>, and would require us to keep updating that code for any change to our model‚Äôs properties.</p><p>The good news is that there‚Äôs another path that we can take, and that‚Äôs to use Swift‚Äôs <em><a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrappers feature</a></em>, which enables us to attach custom logic to any stored property. For example, we could use that feature to implement a <code>DecodableBool</code> wrapper, with <code>false</code> as its default value:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper
struct</span> DecodableBool {
    <span class="s-keyword">var</span> wrappedValue = <span class="s-keyword">false</span>
}</code></pre><p>We could then make our new property wrapper conform to <code>Decodable</code> to enable it <em>‚Äútake over‚Äù</em> the decoding process for any property that it‚Äôs attached to. In this case, we do want to use a manual decoding implementation, as that‚Äôd let us decode instances directly from <code>Bool</code> values ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableBool</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">singleValueContainer</span>()
        wrappedValue = <span class="s-keyword">try</span> container.<span class="s-call">decode</span>(<span class="s-type">Bool</span>.<span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">The reason we conform to <code>Decodable</code> through an extension is to <a href="https://www.swiftbysundell.com/tips/struct-convenience-initializers">not override</a> our type‚Äôs <a href="https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used">memberwise initializer</a>.</p><p>Finally, we‚Äôll also need to make <code>Codable</code> treat instances of the above property wrapper as optional during the decoding process, which can be done by extending the <code>KeyedDecodingContainer</code> type with an overload for decoding <code>DecodableBool</code> specifically ‚Äî in which we only continue decoding in case a value exists for the given key, otherwise we‚Äôll fall back to an empty instance of our wrapper:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">KeyedDecodingContainer</span> {
    <span class="s-keyword">func</span> decode(<span class="s-keyword">_</span> type: <span class="s-type">DecodableBool</span>.<span class="s-type">Type</span>,
                forKey key: <span class="s-type">Key</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">DecodableBool</span> {
        <span class="s-keyword">try</span> <span class="s-call">decodeIfPresent</span>(type, forKey: key) ?? .<span class="s-keyword">init</span>()
    }
}</code></pre><p>With the above in place, we can now simply annotate any <code>Bool</code> property with our new <code>DecodableBool</code> attribute ‚Äî and it‚Äôll default to <code>false</code> when it‚Äôs being decoded:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">String</span>
    <span class="s-keyword">@DecodableBool var</span> isFeatured: <span class="s-type">Bool</span>
}</code></pre><p>Really nice. However, while we‚Äôve now solved this particular problem, our solution isn‚Äôt very flexible. What if we‚Äôd like <code>true</code> to be the default value in some cases, and what if we have non-<code>Bool</code> properties that we‚Äôd also like to provide default decoding values for?</p><p>So let‚Äôs see if we can generalize our solution into something that can be applied within a much larger range of situations. To do that, let‚Äôs start by creating a <a href="https://www.swiftbysundell.com/basics/generics">generic protocol</a> for default value sources ‚Äî which will enable us to define all sorts of defaults, not just boolean ones:</p><pre class="splash"><code><span class="s-keyword">protocol</span> DecodableDefaultSource {
    <span class="s-keyword">associatedtype</span> Value: <span class="s-type">Decodable</span>
    <span class="s-keyword">static var</span> defaultValue: <span class="s-type">Value</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Then, let‚Äôs use an enum to create a <em>namespace</em> for the decoding code that we‚Äôre about to write ‚Äî which will both give us a really nice syntax, and also provide a neat degree of code encapsulation:</p><pre class="splash"><code><span class="s-keyword">enum</span> DecodableDefault {}</code></pre><p class="info">The advantage of using case-less enums to implement namespaces is that they can‚Äôt be initialized, which makes them act as pure wrappers, rather than stand-alone types that can be instantiated.</p><p>The first type that we‚Äôll add to our new namespace is a generic variant of our <code>DecodableBool</code> property wrapper from before ‚Äî which now uses a <code>DecodableDefaultSource</code> to retrieve its default <code>wrappedValue</code>, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span> {
    <span class="s-keyword">@propertyWrapper
    struct</span> Wrapper&lt;Source: <span class="s-type">DecodableDefaultSource</span>&gt; {
        <span class="s-keyword">typealias</span> Value = <span class="s-type">Source</span>.<span class="s-type">Value</span>
        <span class="s-keyword">var</span> wrappedValue = <span class="s-type">Source</span>.<span class="s-property">defaultValue</span>
    }
}</code></pre><p>Next, let‚Äôs make the above property wrapper conform to <code>Decodable</code>, and we‚Äôll also implement another <code>KeyedDecodingContainer</code> overload that‚Äôs specific to our new type:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">singleValueContainer</span>()
        wrappedValue = <span class="s-keyword">try</span> container.<span class="s-call">decode</span>(<span class="s-type">Value</span>.<span class="s-keyword">self</span>)
    }
}

<span class="s-keyword">extension</span> <span class="s-type">KeyedDecodingContainer</span> {
    <span class="s-keyword">func</span> decode&lt;T&gt;(<span class="s-keyword">_</span> type: <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>&lt;<span class="s-type">T</span>&gt;.<span class="s-type">Type</span>,
                   forKey key: <span class="s-type">Key</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>&lt;<span class="s-type">T</span>&gt; {
        <span class="s-keyword">try</span> <span class="s-call">decodeIfPresent</span>(type, forKey: key) ?? .<span class="s-keyword">init</span>()
    }
}</code></pre><p>With the above base infrastructure in place, let‚Äôs now go ahead and implement a few default value sources. We‚Äôll again use an enum to provide an additional level of namespacing for our sources (just like <a href="https://developer.apple.com/documentation/combine/publishers">Combine does for its publishers</a>), and we‚Äôll also add a few <a href="https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift">type aliases</a> to make our code slightly easier to read:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span> {
    <span class="s-keyword">typealias</span> Source = <span class="s-type">DecodableDefaultSource</span>
    <span class="s-keyword">typealias</span> List = <span class="s-type">Decodable</span> &amp; <span class="s-type">ExpressibleByArrayLiteral</span>
    <span class="s-keyword">typealias</span> Map = <span class="s-type">Decodable</span> &amp; <span class="s-type">ExpressibleByDictionaryLiteral</span>

    <span class="s-keyword">enum</span> Sources {
        <span class="s-keyword">enum</span> True: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">Bool</span> { <span class="s-keyword">true</span> }
        }

        <span class="s-keyword">enum</span> False: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">Bool</span> { <span class="s-keyword">false</span> }
        }

        <span class="s-keyword">enum</span> EmptyString: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">String</span> { <span class="s-string">""</span> }
        }

        <span class="s-keyword">enum</span> EmptyList&lt;T: <span class="s-type">List</span>&gt;: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">T</span> { [] }
        }

        <span class="s-keyword">enum</span> EmptyMap&lt;T: <span class="s-type">Map</span>&gt;: <span class="s-type">Source</span> {
            <span class="s-keyword">static var</span> defaultValue: <span class="s-type">T</span> { [:] }
        }
    }
}</code></pre><p class="info">By constraining our <code>EmptyList</code> and <code>EmptyMap</code> types to two of Swift‚Äôs literal protocols, rather than concrete types like <code>Array</code> and <code>Dictionary</code>, we can cover a lot more ground ‚Äî since many different types adopt those protocols, including <code>Set</code>, <code>IndexPath</code>, and more.</p><p>To wrap things up, let‚Äôs also define a series of convenience type aliases that‚Äôll let us reference the above sources as specialized versions of our property wrapper type ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span> {
    <span class="s-keyword">typealias</span> True = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">True</span>&gt;
    <span class="s-keyword">typealias</span> False = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">False</span>&gt;
    <span class="s-keyword">typealias</span> EmptyString = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">EmptyString</span>&gt;
    <span class="s-keyword">typealias</span> EmptyList&lt;T: <span class="s-type">List</span>&gt; = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">EmptyList</span>&lt;<span class="s-type">T</span>&gt;&gt;
    <span class="s-keyword">typealias</span> EmptyMap&lt;T: <span class="s-type">Map</span>&gt; = <span class="s-type">Wrapper</span>&lt;<span class="s-type">Sources</span>.<span class="s-type">EmptyMap</span>&lt;<span class="s-type">T</span>&gt;&gt;
}</code></pre><p>That last piece gives us a really nice syntax for annotating properties with decodable defaults, which can now simply be done like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">EmptyString var</span> body: <span class="s-type">String</span>
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">False var</span> isFeatured: <span class="s-type">Bool</span>
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">True var</span> isActive: <span class="s-type">Bool</span>
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">EmptyList var</span> comments: [<span class="s-type">Comment</span>]
    <span class="s-keyword">@DecodableDefault</span>.<span class="s-keyword">EmptyMap var</span> flags: [<span class="s-type">String</span> : <span class="s-type">Bool</span>]
}</code></pre><p>Really neat, and perhaps the best part is that our solution is now truly generic ‚Äî we can easily add new sources whenever we need to, all while keeping our call sites as clean as possible.</p><p>As a series of finishing touches, let‚Äôs also use Swift‚Äôs <em><a href="https://www.swiftbysundell.com/articles/conditional-conformances-in-swift">conditional conformances feature</a></em> to make our property wrapper conform to common protocols ‚Äî such as <code>Equatable</code>, <code>Hashable</code> and also <code>Encodable</code> ‚Äî whenever its wrapped <code>Value</code> type does:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>: <span class="s-type">Equatable</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Equatable</span> {}
<span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>: <span class="s-type">Hashable</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Hashable</span> {}

<span class="s-keyword">extension</span> <span class="s-type">DecodableDefault</span>.<span class="s-type">Wrapper</span>: <span class="s-type">Encodable</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Encodable</span> {
    <span class="s-keyword">func</span> encode(to encoder: <span class="s-type">Encoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">var</span> container = encoder.<span class="s-call">singleValueContainer</span>()
        <span class="s-keyword">try</span> container.<span class="s-call">encode</span>(wrappedValue)
    }
}</code></pre><p>And with that in place, we now have a finished solution for annotating properties with default decoding values ‚Äî all without requiring any changes to the property types that are being decoded, and with a neatly encapsulated implementation, thanks to our <code>DecodableDefault</code> enum.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/handling-model-variants-in-swift</guid><title>Handling model variants in Swift</title><description>This week, let‚Äôs explore a few different techniques for handling dynamic, polymorphic model data, in ways that still leans into Swift‚Äôs strong emphasis on type-safety.</description><link>https://www.swiftbysundell.com/articles/handling-model-variants-in-swift</link><pubDate>Sun, 7 Jun 2020 20:55:00 +0200</pubDate><content:encoded><![CDATA[<p>As programmers, we‚Äôre often working on apps and systems that consist of multiple parts that need to be connected one way or another ‚Äî and doing so in ways that are elegant, robust, and future proof can often be easier said than done.</p><p>Especially when using highly static languages (such as Swift), it can sometimes be tricky to figure out how to model certain conditions or pieces of data in a way that both satisfies the compiler, and results in code that‚Äôs easy to work with.</p><p>This week, let‚Äôs take a look at one such situation, which involves modeling multiple variants of the same data model, and explore a few different techniques and approaches that can let us handle dynamic data in ways that still leans into Swift‚Äôs strong emphasis on type-safety.</p><h2>Mixed structures</h2><p>As an example, let‚Äôs say that we‚Äôre working on a cooking app that includes both videos and written recipes, and that our content is loaded from a web service that returns JSON formatted like this:</p><pre><code class="no-highlight">{
    "items": [
        {
            "type": "video",
            "title": "Making perfect toast",
            "imageURL": "https://image-cdn.com/toast.png",
            "url": "https://videoservice.com/toast.mp4",
            "duration": "00:12:09",
            "resolution": "720p"
        },
        {
            "type": "recipe",
            "title": "Tasty burritos",
            "imageURL": "https://image-cdn.com/burritos.png",
            "text": "Here's how to make the best burritos...",
            "ingredients": [
                "Tortillas",
                "Salsa",
                ...
            ]
        }
    ]
}</code></pre><p>While the above way of structuring JSON responses is incredibly common, creating Swift representations that match it can prove to be quite challenging. Since we‚Äôre receiving an <code>items</code> array that contains both recipes and videos mixed together, we‚Äôll need to write our model code in a way that lets us decode both of those two variants simultaneously.</p><p>One way to do that would be to create an <code>ItemType</code> enum that includes cases for each of our two variants, as well as a unified <code>Item</code> data model that contains all of the properties that we‚Äôre expecting to encounter, and an <code>ItemCollection</code> wrapper that we‚Äôll be able to decode our JSON into:</p><pre class="splash"><code><span class="s-keyword">enum</span> ItemType: <span class="s-type">String</span>, <span class="s-type">Decodable</span> {
    <span class="s-keyword">case</span> video
    <span class="s-keyword">case</span> recipe
}

<span class="s-keyword">struct</span> Item: <span class="s-type">Decodable</span> {
    <span class="s-keyword">let</span> type: <span class="s-type">ItemType</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>?
    <span class="s-keyword">var</span> duration: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> resolution: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> ingredients: [<span class="s-type">String</span>]?
}

<span class="s-keyword">struct</span> ItemCollection: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> items: [<span class="s-type">Item</span>]
}</code></pre><p class="info">The reason why the above <code>type</code> property is a constant, while all other <code>Item</code> properties remain variables, is because that‚Äôs the only piece of data that we don‚Äôt want to be modified under any circumstances ‚Äî since a recipe shouldn‚Äôt be able to turn into a video, and vice versa. For the other properties, we‚Äôre <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">utilizing Swift‚Äôs value semantics</a> by making them variables.</p><p>While the above approach lets us successfully decode our JSON, it‚Äôs quite far from ideal ‚Äî since we‚Äôre forced to implement the majority of our properties as optionals, given that they‚Äôre unique to one of our two variants. Doing so will in turn require us to constantly unwrap those optionals, even within code that only deals with a single variant, such as this <code>VideoPlayer</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    ...

    <span class="s-keyword">func</span> playVideoItem(<span class="s-keyword">_</span> item: <span class="s-type">Item</span>) {
        <span class="s-comment">// We can't establish a compile-time guarantee that the
        // item passed to this method will, in fact, be a video.</span>
        <span class="s-keyword">guard let</span> url = item.<span class="s-property">url</span> <span class="s-keyword">else</span> {
            <span class="s-call">assertionFailure</span>(<span class="s-string">"Video item doesn't have a URL:</span> \(item)<span class="s-string">"</span>)
            <span class="s-keyword">return</span>
        }

        <span class="s-call">startPlayback</span>(from: url)
    }
}</code></pre><p>So let‚Äôs explore a few ways of solving the above problem, and take a look at what sort of trade-offs that each of those approaches might give us.</p><h2>Complete polymorphism</h2><p>Since we are, at the end of the day, attempting to model a set of <em>polymorphic data</em> (as our models can take on multiple forms), one approach would be to make our Swift representations of that data polymorphic as well.</p><p>To do that, we might create an <code>Item</code> protocol that contains all of the properties that are shared between our two variants, as well as two separate types ‚Äî one for videos and one for recipes ‚Äî that both conform to that new protocol:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Item: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> type: <span class="s-type">ItemType</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">struct</span> Video: <span class="s-type">Item</span> {
    <span class="s-keyword">var</span> type: <span class="s-type">ItemType</span> { .<span class="s-dotAccess">video</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> duration: <span class="s-type">String</span>
    <span class="s-keyword">var</span> resolution: <span class="s-type">String</span>
}

<span class="s-keyword">struct</span> Recipe: <span class="s-type">Item</span> {
    <span class="s-keyword">var</span> type: <span class="s-type">ItemType</span> { .<span class="s-dotAccess">recipe</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>
    <span class="s-keyword">var</span> ingredients: [<span class="s-type">String</span>]
}</code></pre><p>As our items are now represented by two distinct types, we probably also want to modify our <code>ItemCollection</code> wrapper to include separate arrays for each of those two types as well ‚Äî as otherwise we‚Äôd have to constantly type cast <code>Item</code> values to either <code>Video</code> or <code>Recipe</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> ItemCollection: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> videos: [<span class="s-type">Video</span>]
    <span class="s-keyword">var</span> recipes: [<span class="s-type">Recipe</span>]
}</code></pre><p>However, while the above model structure might look great in theory, in practice it‚Äôll require a bit of extra work, since our Swift code no longer matches the format of our JSON responses. That‚Äôs not a huge problem, however, as we can always do what we did in <em><a href="https://www.swiftbysundell.com/articles/customizing-codable-types-in-swift">‚ÄúCustomizing Codable types in Swift‚Äù</a></em> ‚Äî and create dedicated types specifically for decoding, along with a custom <code>Decodable</code> implementation.</p><p>In this case, let‚Äôs reuse our <code>Item</code> and <code>ItemCollection</code> implementations from before, while renaming them to fit their new purpose ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">struct</span> Encoded: <span class="s-type">Decodable</span> {
        <span class="s-keyword">var</span> items: [<span class="s-type">EncodedItem</span>]
    }

    <span class="s-keyword">struct</span> EncodedItem: <span class="s-type">Decodable</span> {
        <span class="s-keyword">let</span> type: <span class="s-type">ItemType</span>
        <span class="s-keyword">var</span> title: <span class="s-type">String</span>
        <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
        <span class="s-keyword">var</span> text: <span class="s-type">String</span>?
        <span class="s-keyword">var</span> url: <span class="s-type">URL</span>?
        <span class="s-keyword">var</span> duration: <span class="s-type">String</span>?
        <span class="s-keyword">var</span> resolution: <span class="s-type">String</span>?
        <span class="s-keyword">var</span> ingredients: [<span class="s-type">String</span>]?
    }
}</code></pre><p>We‚Äôre now <em>almost</em> ready to write our custom <code>Decodable</code> implementation ‚Äî but since we‚Äôre going to need to unwrap quite a few optionals when doing that, let‚Äôs first create a small utility method that‚Äôll make that process much simpler:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">struct</span> MissingEncodedValue: <span class="s-type">Error</span> {
        <span class="s-keyword">var</span> name: <span class="s-type">String</span>
        ...
    }

    <span class="s-keyword">private func</span> unwrap&lt;T&gt;(<span class="s-keyword">_</span> value: <span class="s-type">T</span>?, name: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">T</span> {
        <span class="s-keyword">guard let</span> value = value <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">MissingEncodedValue</span>(name: name)
        }

        <span class="s-keyword">return</span> value
    }
}</code></pre><p class="info">If the above <code>unwrap</code> method looks familiar, it might be because it‚Äôs really similar to <a href="https://www.swiftbysundell.com/tips/unwrapping-an-optional-or-throwing-an-error">this extension</a> on the <code>Optional</code> type itself, which has appeared in several previous articles.</p><p>With the above pieces in place, let‚Äôs now write our actual decoding code. We‚Äôll start by decoding an instance of our new <code>Encoded</code> wrapper, and we‚Äôll then convert its items into <code>Video</code> and <code>Recipe</code> values, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">singleValueContainer</span>()
        <span class="s-keyword">let</span> collection = <span class="s-keyword">try</span> container.<span class="s-call">decode</span>(<span class="s-type">Encoded</span>.<span class="s-keyword">self</span>)

        <span class="s-keyword">for</span> item <span class="s-keyword">in</span> collection.<span class="s-property">items</span> {
            <span class="s-keyword">switch</span> item.<span class="s-property">type</span> {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">video</span>:
                <span class="s-keyword">try</span> videos.<span class="s-call">append</span>(<span class="s-type">Video</span>(
                    type: item.<span class="s-property">type</span>,
                    title: item.<span class="s-property">title</span>,
                    imageURL: item.<span class="s-property">imageURL</span>,
                    url: <span class="s-call">unwrap</span>(item.<span class="s-property">url</span>, name: <span class="s-string">"url"</span>),
                    duration: <span class="s-call">unwrap</span>(item.<span class="s-property">duration</span>, name: <span class="s-string">"duration"</span>),
                    resolution: <span class="s-call">unwrap</span>(item.<span class="s-property">resolution</span>, name: <span class="s-string">"resolution"</span>)
                ))
            <span class="s-keyword">case</span> .<span class="s-dotAccess">recipe</span>:
                <span class="s-keyword">try</span> recipes.<span class="s-call">append</span>(<span class="s-type">Recipe</span>(
                    type: item.<span class="s-property">type</span>,
                    title: item.<span class="s-property">title</span>,
                    imageURL: item.<span class="s-property">imageURL</span>,
                    text: <span class="s-call">unwrap</span>(item.<span class="s-property">text</span>, name: <span class="s-string">"text"</span>),
                    ingredients: <span class="s-call">unwrap</span>(item.<span class="s-property">ingredients</span>, name: <span class="s-string">"ingredients"</span>)
                ))
            }
        }
    }
}</code></pre><p>With that final piece in place, we now have a fully type-safe representation of our JSON data, all without any <em><a href="https://www.swiftbysundell.com/articles/handling-non-optional-optionals-in-swift">non-optional optionals</a></em>. However, not only did the above approach require a fair amount of decoding-specific code, we‚Äôre now also losing track of the overall order of our items (as we‚Äôre splitting them up into two arrays while decoding them).</p><p>While there are of course different ways that we could fix that, including maintaining a separate <code>[Item]</code> array that we could use for sorting and ordering, let‚Äôs also explore a third approach that might turn out to be a neat <em>middle ground</em> between our first two implementations.</p><p>Rather than treating our variants as two separate implementations that share a common interface, let‚Äôs actually treat them as variants of <em>the same model</em> instead. That might seem like a subtle change, but it‚Äôll turn out to have quite a big impact on our final model structure.</p><p>To get started, let‚Äôs rename our previous <code>Item</code> protocol to <code>ItemVariant</code> instead, while also dropping its <code>type</code> property:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ItemVariant: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Then, let‚Äôs model our actual <code>Item</code> type as an enum, with one case for each of our two variants ‚Äî each containing an instance of that variant‚Äôs dedicated model as an associated value:</p><pre class="splash"><code><span class="s-keyword">enum</span> Item {
    <span class="s-keyword">case</span> video(<span class="s-type">Video</span>)
    <span class="s-keyword">case</span> recipe(<span class="s-type">Recipe</span>)
}</code></pre><p>With the above change in place, we can now heavily simplify our custom <code>Decodable</code> implementation ‚Äî which can now take place entirely within our new <code>Item</code> type itself, and just involves inspecting each JSON item‚Äôs <code>type</code> value in order to decide which underlying type to decode:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">struct</span> InvalidTypeError: <span class="s-type">Error</span> {
        <span class="s-keyword">var</span> type: <span class="s-type">String</span>
        ...
    }

    <span class="s-keyword">private enum</span> CodingKeys: <span class="s-type">CodingKey</span> {
        <span class="s-keyword">case</span> type
    }

    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">container</span>(keyedBy: <span class="s-type">CodingKeys</span>.<span class="s-keyword">self</span>)
        <span class="s-keyword">let</span> type = <span class="s-keyword">try</span> container.<span class="s-call">decode</span>(<span class="s-type">String</span>.<span class="s-keyword">self</span>, forKey: .<span class="s-dotAccess">type</span>)

        <span class="s-keyword">switch</span> type {
        <span class="s-keyword">case</span> <span class="s-string">"video"</span>:
            <span class="s-keyword">self</span> = .<span class="s-call">video</span>(<span class="s-keyword">try</span> <span class="s-type">Video</span>(from: decoder))
        <span class="s-keyword">case</span> <span class="s-string">"recipe"</span>:
            <span class="s-keyword">self</span> = .<span class="s-call">recipe</span>(<span class="s-keyword">try</span> <span class="s-type">Recipe</span>(from: decoder))
        <span class="s-keyword">default</span>:
            <span class="s-keyword">throw</span> <span class="s-type">InvalidTypeError</span>(type: type)
        }
    }
}</code></pre><p class="info">An alternative to using raw strings to represent each type would be to keep using our <code>ItemType</code> enum from before. However, given that we‚Äôve now introduced an <code>ItemVariant</code> protocol, keeping that enum around might add some confusion, and doesn‚Äôt really give us any benefits compared to defining our strings inline within the above initializer.</p><p>Since our <code>Item</code> implementation is once again responsible for decoding its own instances, we can now revert our <code>ItemCollection</code> back to simply being a container for an array of <code>Item</code> values ‚Äî which also lets it rely on the default implementation of <code>Decodable</code>, just like before:</p><pre class="splash"><code><span class="s-keyword">struct</span> ItemCollection: <span class="s-type">Decodable</span> {
    <span class="s-keyword">var</span> items: [<span class="s-type">Item</span>]
}</code></pre><p>While this last iteration has the benefit of letting us keep using our dedicated models, while also keeping our decoding code simple, and our overall item order intact, it does come with the downside of requiring us to <em>unpack</em> each <code>Item</code> value before using it ‚Äî for example by using a <code>switch</code> statement, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">func</span> allTitles() -&gt; [<span class="s-type">String</span>] {
        items.<span class="s-call">map</span> { item <span class="s-keyword">in
            switch</span> item {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">video</span>(<span class="s-keyword">let</span> video):
                <span class="s-keyword">return</span> video.<span class="s-property">title</span>
            <span class="s-keyword">case</span> .<span class="s-dotAccess">recipe</span>(<span class="s-keyword">let</span> recipe):
                <span class="s-keyword">return</span> recipe.<span class="s-property">title</span>
            }
        }
    }
}</code></pre><p>While we‚Äôre going to have to keep writing code like the above whenever we need to access data that‚Äôs specific to either <code>Recipe</code> or <code>Video</code> (which is arguably a good thing, since that <em>‚Äúforces‚Äù</em> us to handle both of those two possible cases), there is something we can do to give us direct access to any property defined within our <code>ItemVariant</code> protocol ‚Äî and that‚Äôs to use Swift‚Äôs <em>dynamic member lookup</em> feature.</p><p>Doing that first involves adding the <code>@dynamicMemberLookup</code> attribute to our main <code>Item</code> declaration:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
enum</span> Item {
    <span class="s-keyword">case</span> video(<span class="s-type">Video</span>)
    <span class="s-keyword">case</span> recipe(<span class="s-type">Recipe</span>)
}</code></pre><p>The second part of the puzzle is to implement a <a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift"><code>subscript</code></a> that resolves a value for a given dynamic member. While doing so initially required such a subscript to accept any arbitrary string as input, since Swift 5.1 it‚Äôs possible to <em><a href="https://www.swiftbysundell.com/tips/combining-dynamic-member-lookup-with-key-paths">instead use key paths</a></em> ‚Äî which lets us add support for dynamic members in a fully type-safe manner, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span> {
    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">ItemVariant</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">video</span>(<span class="s-keyword">let</span> video):
            <span class="s-keyword">return</span> video[keyPath: keyPath]
        <span class="s-keyword">case</span> .<span class="s-dotAccess">recipe</span>(<span class="s-keyword">let</span> recipe):
            <span class="s-keyword">return</span> recipe[keyPath: keyPath]
        }
    }
}</code></pre><p>With the above in place, we can now access any property that‚Äôs shared between <code>Video</code> and <code>Recipe</code> (through our <code>ItemVariant</code> protocol) as if that property was defined within our <code>Item</code> type itself. Combine that with the fact that key paths can now <a href="https://www.swiftbysundell.com/tips/passing-key-paths-as-functions">be converted into functions</a> (yes, I love key paths), and we can transform our <code>allTitles</code> method from before to now simply look like this instead:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ItemCollection</span> {
    <span class="s-keyword">func</span> allTitles() -&gt; [<span class="s-type">String</span>] {
        items.<span class="s-call">map</span>(\.<span class="s-property">title</span>)
    }
}</code></pre><p>Really cool! Using the above setup we can sort of achieve the best of both worlds, in that we now get direct access to all of the properties that both of our variants support ‚Äî while also being able to use our specialized <code>Video</code> and <code>Recipe</code> models when we want to write code that‚Äôs specific to any of those two variants.</p><h2>Conclusion</h2><p>While it can occasionally be difficult to cleanly represent dynamic or polymorphic data in Swift, there are often ways to make that happen ‚Äî although finding the right structure within each given situation might require us to try out a few different approaches, just like we did in this article.</p><p>Although that sort of <em>‚Äútrial and error‚Äù</em> might take some extra time, going through that process is often a good investment to make when it comes to model code, as an app‚Äôs data models tend to make up the very foundation of its overall code base.</p><p>Of course, the very best would arguably be for our serialized data to always match the format that we expect within our Swift code, but that‚Äôs not always possible ‚Äî especially when working on a product that ships on multiple platforms.</p><p>What do you think? How do you typically structure models that have multiple variants, and would any of the techniques covered in this article be useful within your code base? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/bitrise-june-2020</guid><title>Sponsor: Bitrise</title><description>Thanks a lot to Bitrise for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/bitrise-june-2020</link><pubDate>Fri, 5 Jun 2020 12:15:00 +0200</pubDate><content:encoded><![CDATA[<p>Thanks a lot to <a href="https://bitrise.io/swift">Bitrise</a>, my favorite continuous integration service, for sponsoring Swift by Sundell this week. I‚Äôve been using Bitrise since long before they became a sponsor, both for my own projects and when working with clients, and it‚Äôs truly a fantastic service.</p><p>Bitrise lets you easily set up all sorts of automation to be run when some form of change is made within your project. For example, you can have it run all of your unit or UI tests when a new Pull Request is opened, or automatically submit a new build to TestFlight or App Store Connect when you create a new release branch.</p><p>The power of Bitrise is that it both has more than 300 common actions built-in, which can be added to your build pipeline with just a few clicks within their web UI, while also providing full command line access as well. And perhaps the best part is that you don‚Äôt need to make <em>any changes</em> to your project to use Bitrise ‚Äî and it‚Äôs completely free to try ‚Äî so take it for a spin, and I think you‚Äôll see why I like it so much.</p><p><strong><a href="https://bitrise.io/swift">Using this link to try out Bitrise also supports Swift by Sundell</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/74</guid><title>Podcast: ‚ÄúLet‚Äôs build a camera app‚Äù, a conversation with the Halide and Spectre team</title><description>On this special episode, John is joined by the entire team behind the award-winning apps Halide and Spectre, Apple‚Äôs 2019 App of the Year. Ben, Sebastiaan and Rebecca share their stories of how these apps came to life, how they‚Äôre working together between design and development, and how technologies like Computational Photography and Augmented Reality are influencing their work.</description><link>https://www.swiftbysundell.com/podcast/74</link><pubDate>Thu, 4 Jun 2020 18:00:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell74.mp3" type="audio/mpeg"/></audio><p>On this special episode, John is joined by the entire team behind the award-winning apps Halide and Spectre, Apple‚Äôs 2019 App of the Year. Ben, Sebastiaan and Rebecca share their stories of how these apps came to life, how they‚Äôre working together between design and development, and how technologies like Computational Photography and Augmented Reality are influencing their work.</p><h2>Sponsor</h2><ul><li><strong><a href="https://clubhouse.io/sundell">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that‚Äôs fantastic for remote collaboration. Built specifically for software teams. Sign up for free at <a href="https://clubhouse.io/sundell">clubhouse.io/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/sandofsky">Ben on Twitter</a></li><li><a href="https://twitter.com/sdw">Sebastiaan on Twitter</a></li><li><a href="https://twitter.com/rebeccaslatkin">Rebecca on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://lux.camera">Lux Optics Inc.</a></li><li><a href="https://blog.halide.cam/lux-year-3-the-end-of-the-beginning-14a271711743">Lux Year 3: The End of the Beginning</a></li><li><a href="https://halide.cam">Halide</a></li><li><a href="https://spectre.cam">Spectre</a></li><li><a href="https://dribbble.com">Dribbble</a></li><li><a href="https://developer.apple.com/documentation/metalperformanceshaders">Metal Performance Shaders</a></li><li><a href="https://developer.apple.com/documentation/vision">The Vision framework</a></li><li><a href="https://developer.apple.com/documentation/coreml">Core ML</a></li><li><a href="https://blog.halide.cam/lidar-peek-into-the-future-with-ipad-pro-11d38910e9f8">The iPad Pro LIDAR sensor and the Esper prototype</a></li><li><a href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview">SF Symbols</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/designing-reusable-swift-libraries</guid><title>Designing reusable Swift libraries</title><description>This week‚Äôs article is about library development, and contains a few techniques and principles that can be good to keep in mind when designing and building reusable Swift libraries.</description><link>https://www.swiftbysundell.com/articles/designing-reusable-swift-libraries</link><pubDate>Sun, 31 May 2020 22:30:00 +0200</pubDate><content:encoded><![CDATA[<p>Code reuse is one of those programming concepts that can be much more complex than what it first might seem like. While it‚Äôs easy to argue that code duplication should be avoided at all costs and that implementations should always be reused and shared whenever possible ‚Äî it‚Äôs important to remember that all abstractions that we end up introducing also come with a certain cost.</p><p>So writing pragmatic, reusable code often comes down to striking a balance between reducing duplication wherever possible, while also trying to avoid having to introduce too many layers of abstraction or complexity in order to unify our various implementations.</p><p>Striking such a balance becomes especially important (and, arguably, difficult) when designing and building reusable libraries ‚Äî so this week, let‚Äôs take a look at a few principles and techniques that can be good to keep in mind when doing just that.</p><h2>Packaging up a generic concept</h2><p>Whether we‚Äôre working on a single code base, or multiple ones, there are often opportunities for us to share code by extracting narrowly scoped pieces of logic into separate libraries. Apart from the code reuse aspect, doing so also enables us to test and iterate on that logic in isolation ‚Äî which can be incredibly useful, especially within larger code bases with long overall build times.</p><p>When deciding what kind of code to extract into a separate library, it‚Äôs usually a good idea to try to pick something that can be implemented as a <em>truly generic concept</em>. That doesn‚Äôt necessarily mean that the code itself needs to be completely <a href="https://www.swiftbysundell.com/basics/generics">generic</a>, but rather that the logic itself isn‚Äôt tied to any specific <em>feature or domain</em>.</p><p>As an example, imagine that we‚Äôre working on an app that makes heavy use of <em>tags</em> in order to sort, filter and provide recommendations for various kinds of content. While the way that we actually use those tags within our app might be really specific to our particular domain, the concept of tags itself is something that could definitely be generalized into a reusable library ‚Äî a <em>TagKit</em>, if you will.</p><p>Let‚Äôs say that a core part of our app‚Äôs tagging logic is implemented using a <code>Tagged</code> protocol, as well as a <code>TaggedCollection</code> that lets us store and retrieve elements based on their tags:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Tagged: <span class="s-type">Hashable</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span>&gt; {
    <span class="s-keyword">private var</span> elements = [<span class="s-type">String</span> : <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;]()

    <span class="s-keyword">mutating func</span> add(<span class="s-keyword">_</span> element: <span class="s-type">Element</span>) {
        <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> element.<span class="s-property">tags</span> {
            elements[tag, default: []].<span class="s-call">insert</span>(element)
        }
    }

    <span class="s-keyword">mutating func</span> remove(<span class="s-keyword">_</span> element: <span class="s-type">Element</span>) {
        <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> element.<span class="s-property">tags</span> {
            elements[tag]?.<span class="s-call">remove</span>(element)
        }
    }

    <span class="s-keyword">func</span> elements(taggedWith tag: <span class="s-type">String</span>) -&gt; <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt; {
        elements[tag] ?? []
    }
}</code></pre><p>Let‚Äôs start the process of creating our TagKit by moving the above protocol and type into a separate library, which we‚Äôll create as a Swift package. Once we‚Äôve <a href="https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager">set up the package itself</a>, the first step would be to mark all of the APIs that we wish to be part of our library‚Äôs <em>public interface</em> as <code>public</code>, so that they‚Äôll be accessible outside of our library module ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> Tagged: <span class="s-type">Hashable</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">public struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span>&gt; {
    <span class="s-keyword">private var</span> elements = [<span class="s-type">String</span> : <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;]()
    
    <span class="s-comment">// Note that we have to explicitly add a public initializer
    // in order to be able to initialize a type outside of
    // the module that it's declared in:</span>
    <span class="s-keyword">public init</span>() {}

    <span class="s-keyword">public mutating func</span> add(<span class="s-keyword">_</span> element: <span class="s-type">Element</span>) {
        <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> element.<span class="s-property">tags</span> {
            elements[tag, default: []].<span class="s-call">insert</span>(element)
        }
    }

    <span class="s-keyword">public mutating func</span> remove(<span class="s-keyword">_</span> element: <span class="s-type">Element</span>) {
        <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> element.<span class="s-property">tags</span> {
            elements[tag]?.<span class="s-call">remove</span>(element)
        }
    }

    <span class="s-keyword">public func</span> elements(taggedWith tag: <span class="s-type">String</span>) -&gt; <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt; {
        elements[tag] ?? []
    }
}</code></pre><p>While the above kind of change is quick and easy to make, a key aspect of library development is to carefully consider what to actually make parts of our public API, versus what to keep internal within the library itself.</p><p>As an example, let‚Äôs say that we now want to enable instances of our <code>TaggedCollection</code> type to be encoded and decoded using Swift‚Äôs built-in <code>Codable</code> API. Since all of our collection‚Äôs elements would also need to be <code>Codable</code> in order to make that happen, one approach would be to add that protocol as an additional requirement for conforming to <code>Tagged</code> ‚Äî which would let us simply mark <code>TaggedCollection</code> as being <code>Codable</code> as well:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> Tagged: <span class="s-type">Hashable</span>, <span class="s-type">Codable</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">public struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span>&gt;: <span class="s-type">Codable</span> {
    ...
}</code></pre><p>However, here‚Äôs where we have to put on our <em>‚ÄúAPI designer hat‚Äù</em> for a second, and think about whether requiring all <code>Tagged</code> types to also conform to <code>Codable</code> is <em>really</em> a good idea. After all, what does encoding and decoding have to do with having support for tags?</p><p>Although making that association might not seem like a big deal, adding more requirements than what‚Äôs absolutely needed could make our library less flexible and harder to adopt ‚Äî especially as we might continue to add more requirements in the future if we choose to follow this design.</p><p>Thankfully, there‚Äôs another approach that we could take in this case, and that‚Äôs to use Swift‚Äôs <em><a href="https://www.swiftbysundell.com/articles/conditional-conformances-in-swift">conditional conformances feature</a></em> ‚Äî which enables us to make our <code>TaggedCollection</code> conform to a given protocol only when its <code>Element</code> type also does.</p><p>Using that ‚Äî while also moving the requirement of conforming to <code>Hashable</code> into our <code>TaggedCollection</code> itself ‚Äî lets us simplify our <code>Tagged</code> protocol to now only require a single property, all without sacrificing any functionality:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> Tagged {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">public struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">TaggedCollection</span>: <span class="s-type">Codable</span> <span class="s-keyword">where</span> <span class="s-type">Element</span>: <span class="s-type">Codable</span> {}</code></pre><p>With the above change in place, our API now scales really nicely ‚Äî from simply adopting our <code>Tagged</code> protocol, to using it within <code>TaggedCollection</code>, to being able to encode and decode collection instances ‚Äî with requirements that are gradually introduced only when needed.</p><h2>Strong types and escape hatches</h2><p>Currently, our tagging system uses raw strings to represent each tag, which might‚Äôve been completely fine when that system was implemented specifically for a single app ‚Äî but since we‚Äôre now looking to turn it into a stand-alone library, we might want to make things a bit more strongly typed.</p><p>An initial idea on how to achieve that might be to model all of the tags that we‚Äôre currently using as an enum, with one case for each tag, and to then update both our <code>Tagged</code> protocol and our <code>TaggedCollection</code> to use that type instead of <code>String</code> values:</p><pre class="splash"><code><span class="s-keyword">public enum</span> Tag: <span class="s-type">String</span>, <span class="s-type">Codable</span> {
    <span class="s-keyword">case</span> newRelease
    <span class="s-keyword">case</span> onSale
    <span class="s-keyword">case</span> promoted
    ...
}

<span class="s-keyword">public protocol</span> Tagged {
    <span class="s-keyword">var</span> tags: [<span class="s-type">Tag</span>] { <span class="s-keyword">get</span> }
}

<span class="s-keyword">public struct</span> TaggedCollection&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    <span class="s-keyword">private var</span> elements = [<span class="s-type">Tag</span> : <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;]()

    ...

    <span class="s-keyword">public func</span> elements(taggedWith tag: <span class="s-type">Tag</span>) -&gt; <span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt; {
        ...
    }
}</code></pre><p>However, while the above approach might‚Äôve worked great within a single app, it‚Äôs quite problematic in the context of a reusable library ‚Äî since the library itself will need to contain all of the tags that any of the apps using it will ever need, which isn‚Äôt very sustainable in the long run.</p><p>One way to fix that problem would be to add an <em>‚Äùescape hatch‚Äù</em> to the above enum ‚Äî that is, an API that enables us to implement our own custom tags when needed ‚Äî for example by introducing a <code>custom</code> case, like this:</p><pre class="splash"><code><span class="s-keyword">public enum</span> Tag: <span class="s-type">Hashable</span>, <span class="s-type">Codable</span> {
    <span class="s-keyword">case</span> newRelease
    <span class="s-keyword">case</span> onSale
    <span class="s-keyword">case</span> promoted
    ...
    <span class="s-keyword">case</span> custom(<span class="s-type">String</span>)
}</code></pre><p>While the above approach does work, and might even be the right design decision in certain situations, it comes with the downsides that we‚Äôd both have to implement our own conversion to and from strings (since our enum is no longer backed by a raw <code>String</code> value), and we‚Äôd also have to manually conform to <code>Codable</code> as well.</p><p>Instead, let‚Äôs take a different approach, and implement our <code>Tag</code> type as a struct ‚Äî which enables us to keep track of each tag‚Äôs underlying <code>String</code> value using a property. We‚Äôll also take this opportunity to enable <code>Tag</code> values to be easily expressed using <a href="https://www.swiftbysundell.com/articles/string-literals-in-swift">string literals</a> as well:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Tag: <span class="s-type">Hashable</span>, <span class="s-type">Codable</span> {
    <span class="s-keyword">public var</span> string: <span class="s-type">String</span>

    <span class="s-keyword">public init</span>(<span class="s-keyword">_</span> string: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">string</span> = string
    }
}

<span class="s-keyword">extension</span> <span class="s-type">Tag</span>: <span class="s-type">ExpressibleByStringLiteral</span> {
    <span class="s-keyword">public init</span>(stringLiteral value: <span class="s-type">String</span>) {
        string = value
    }
}</code></pre><p>The great thing about the above approach is that not only are we now free to define app-specific <code>Tag</code> values in whichever way we want ‚Äî we can still enable the same <em>‚Äúenum-like‚Äù</em> dot-syntax to be used for our most frequent tags by adding static computed properties for them, for example like this:</p><pre class="splash"><code><span class="s-keyword">public extension</span> <span class="s-type">Tag</span> {
    <span class="s-keyword">static var</span> newRelease: <span class="s-type">Self</span> { <span class="s-keyword">#function</span> }
    <span class="s-keyword">static var</span> onSale: <span class="s-type">Self</span> { <span class="s-keyword">#function</span> }
    <span class="s-keyword">static var</span> promoted: <span class="s-type">Self</span> { <span class="s-keyword">#function</span> }
    ...
}</code></pre><p class="info">The above <code>#function</code> symbols will at compile time automatically expand to the name of their enclosing property, giving us the exact same raw string mapping as enums provide.</p><p>With the above in place, we now both get the convenience of being able to easily define our tags using raw strings, while also getting the additional type safety and <a href="https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code/%23dedicated-types">self-documenting qualities</a> that strong types provide.</p><h2>The importance of testing the public API</h2><p>It‚Äôs fair to say that a major part of building a solid library is putting enough automated tests in place to ensure that its various functionality and behaviors will keep working as expected as it continues to evolve.</p><p>As an example, let‚Äôs say that our new tagging library also contains a <code>RecommendationEngine</code> that lets us quickly generate an array of recommendations from a collection of tagged elements. For the sake of simplicity, we‚Äôll use the following implementation ‚Äî which generates its recommendations by shuffling all of the elements that match a given tag, and then returns the first three matches:</p><pre class="splash"><code><span class="s-keyword">public struct</span> RecommendationEngine&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    <span class="s-keyword">private let</span> collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;

    <span class="s-keyword">public init</span>(collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">collection</span> = collection
    }

    <span class="s-keyword">public func</span> recommendations(forTag tag: <span class="s-type">Tag</span>) -&gt; [<span class="s-type">Element</span>] {
        <span class="s-keyword">let</span> elements = collection.<span class="s-call">elements</span>(taggedWith: tag)
        <span class="s-keyword">return</span> <span class="s-type">Array</span>(elements.<span class="s-call">shuffled</span>().<span class="s-call">prefix</span>(<span class="s-number">3</span>))
    }
}</code></pre><p class="info">Fun fact: While the above is just an example, it‚Äôs actually quite close to how the first version of this website‚Äôs recommendation system was implemented. Nothing wrong with using simple algorithms if they end up doing the job.</p><p>While the above implementation is indeed simple, it‚Äôs actually quite problematic from a testing perspective, since it contains an element of randomness (through its use of <code>shuffled()</code>). One way to address that problem would be to extract that source of randomness into a closure that could then be overridden within our tests ‚Äî for example like this:</p><pre class="splash"><code><span class="s-keyword">public struct</span> RecommendationEngine&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    <span class="highlight offset-adjust"><span class="s-keyword">internal var</span> sorting: (<span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;) -&gt; [<span class="s-type">Element</span>] = { $0.<span class="s-call">shuffled</span>() }</span>

    <span class="s-keyword">private let</span> collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;

    <span class="s-keyword">public init</span>(collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">collection</span> = collection
    }

    <span class="s-keyword">public func</span> recommendations(forTag tag: <span class="s-type">Tag</span>) -&gt; [<span class="s-type">Element</span>] {
        <span class="s-keyword">let</span> elements = collection.<span class="s-call">elements</span>(taggedWith: tag)
        <span class="s-keyword">return</span> <span class="s-type">Array</span>(<span class="s-call">sorting</span>(elements).<span class="s-call">prefix</span>(<span class="s-number">3</span>))
    }
}</code></pre><p>Our new <code>sorting</code> property is marked as <code>internal</code>, since we‚Äôre currently considering it an implementation detail of our library, rather than a part of its public API. We could then access that property within our tests using the <code>@testable import</code> command ‚Äî which gives us access to all of the imported module‚Äôs <code>internal</code> APIs, as well as its public ones. That way, we could write tests like this:</p><pre class="splash"><code><span class="s-keyword">@testable import</span> TagKit

<span class="s-keyword">class</span> RecommendationEngineTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testReturningFirstThreeMatchedElements() {
        <span class="s-keyword">let</span> articles = (<span class="s-number">0</span>..&lt;<span class="s-number">5</span>).<span class="s-call">map</span> { index <span class="s-keyword">in</span>
            <span class="s-type">Article</span>(
                title: <span class="s-string">"Article-</span>\(index)<span class="s-string">"</span>,
                tags: [<span class="s-string">"tag"</span>]
            )
        }

        <span class="s-keyword">var</span> collection = <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Article</span>&gt;()
        articles.<span class="s-call">forEach</span> { collection.<span class="s-call">add</span>($0) }

        <span class="s-keyword">var</span> engine = <span class="s-type">RecommendationEngine</span>(collection: collection)

        engine.<span class="s-property">sorting</span> = { array <span class="s-keyword">in</span>
            array.<span class="s-call">sorted</span>(by: { $0.<span class="s-property">title</span> &lt; $1.<span class="s-property">title</span> })
        }

        <span class="s-keyword">let</span> recommendations = engine.<span class="s-call">recommendations</span>(forTag: <span class="s-string">"tag"</span>)
        <span class="s-call">XCTAssertEqual</span>(recommendations, <span class="s-type">Array</span>(articles[..&lt;<span class="s-number">3</span>]))
    }
}</code></pre><p>While the above approach works, and is a very common way of writing unit tests for app targets, it‚Äôs questionable whether it‚Äôs a good approach for testing libraries.</p><p>The problem with using internal APIs to write library tests is that those capabilities won‚Äôt be available to the actual production code that‚Äôll use our library ‚Äî which in turn makes it easy to overlook design flaws and APIs that are too limited. After all, if we need a certain API to be able to test our library, chances are that at least one of the apps using it will need that API too.</p><p>So let‚Äôs turn our new <code>sorting</code> API into a proper public one instead. While we could of course just change that property‚Äôs access level to <code>public</code> and leave things like that, let‚Äôs tweak it a bit before exposing it as a part of our official API.</p><p>Just like how we earlier introduced a dedicated type for representing tags, let‚Äôs do the same thing here ‚Äî and create a <code>Sorting</code> type that‚Äôll act as a thin wrapper around a closure that‚Äôll perform the actually sorting:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Sorting&lt;Element: <span class="s-type">Hashable</span>&gt; {
    <span class="s-keyword">public typealias</span> Body = (<span class="s-type">Set</span>&lt;<span class="s-type">Element</span>&gt;) -&gt; [<span class="s-type">Element</span>]

    <span class="s-keyword">public var</span> body: <span class="s-type">Body</span>

    <span class="s-keyword">public init</span>(body: <span class="s-keyword">@escaping</span> <span class="s-type">Body</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">body</span> = body
    }
}</code></pre><p>For convenience, let‚Äôs also provide a default <code>shuffled</code> implementation of our new <code>Sorting</code> type, using the same static property-based technique that we used earlier:</p><pre class="splash"><code><span class="s-keyword">public extension</span> <span class="s-type">Sorting</span> {
    <span class="s-keyword">static var</span> shuffled: <span class="s-type">Self</span> {
        .<span class="s-keyword">init</span> { $0.<span class="s-call">shuffled</span>() }
    }
}</code></pre><p>With the above in place, let‚Äôs now go back to our <code>RecommendationEngine</code> and make it accept an instance of our new <code>Sorting</code> type as part of its initializer. We‚Äôll also take this opportunity to parameterize our <code>maxElementCount</code> as well ‚Äî further making our public API more customizable and powerful without sacrificing any convenience:</p><pre class="splash"><code><span class="s-keyword">public struct</span> RecommendationEngine&lt;Element: <span class="s-type">Tagged</span> &amp; <span class="s-type">Hashable</span>&gt; {
    <span class="s-keyword">private let</span> collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;
    <span class="s-keyword">private let</span> sorting: <span class="s-type">Sorting</span>&lt;<span class="s-type">Element</span>&gt;
    <span class="s-keyword">private let</span> maxElementCount: <span class="s-type">Int</span>

    <span class="s-keyword">public init</span>(collection: <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Element</span>&gt;,
                sorting: <span class="s-type">Sorting</span>&lt;<span class="s-type">Element</span>&gt; = .<span class="s-dotAccess">shuffled</span>,
                maxElementCount: <span class="s-type">Int</span> = <span class="s-number">3</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">collection</span> = collection
        <span class="s-keyword">self</span>.<span class="s-property">sorting</span> = sorting
        <span class="s-keyword">self</span>.<span class="s-property">maxElementCount</span> = maxElementCount
    }

    <span class="s-keyword">public func</span> recommendations(forTag tag: <span class="s-type">Tag</span>) -&gt; [<span class="s-type">Element</span>] {
        <span class="s-keyword">let</span> elements = collection.<span class="s-call">elements</span>(taggedWith: tag)
        <span class="s-keyword">return</span> <span class="s-type">Array</span>(sorting.<span class="s-call">body</span>(elements).<span class="s-call">prefix</span>(maxElementCount))
    }
}</code></pre><p>A really neat side-effect of the above change is that we can now keep implementing different <code>Sorting</code> variants ‚Äî both within our library itself, and externally within our app projects. For example, here‚Äôs another implementation which sorts the <code>Set</code> that it‚Äôs given based on a key path:</p><pre class="splash"><code><span class="s-keyword">public extension</span> <span class="s-type">Sorting</span> {
    <span class="s-keyword">static func</span> basedOn&lt;V: <span class="s-type">Comparable</span>&gt;(
        <span class="s-keyword">_</span> keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Element</span>, <span class="s-type">V</span>&gt;
    ) -&gt; <span class="s-type">Self</span> {
        .<span class="s-keyword">init</span> { <span class="s-keyword">set in
            set</span>.<span class="s-call">sorted</span> {
                $0[keyPath: keyPath] &lt; $1[keyPath: keyPath]
            }
        }
    }
}</code></pre><p>With the above pieces in place, we can now drop the <code>@testable</code> prefix from our unit test‚Äôs <code>import</code> statement, and write our test using the exact same set of APIs that our production code will have access to ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">import</span> TagKit

<span class="s-keyword">class</span> RecommendationEngineTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testReturningFirstThreeMatchedElements() {
        <span class="s-keyword">let</span> articles = (<span class="s-number">0</span>..&lt;<span class="s-number">5</span>).<span class="s-call">map</span> { index <span class="s-keyword">in</span>
            <span class="s-type">Article</span>(
                title: <span class="s-string">"Article-</span>\(index)<span class="s-string">"</span>,
                tags: [<span class="s-string">"tag"</span>]
            )
        }

        <span class="s-keyword">var</span> collection = <span class="s-type">TaggedCollection</span>&lt;<span class="s-type">Article</span>&gt;()
        articles.<span class="s-call">forEach</span> { collection.<span class="s-call">add</span>($0) }

        <span class="s-keyword">let</span> engine = <span class="s-type">RecommendationEngine</span>(
            collection: collection,
            sorting: .<span class="s-call">basedOn</span>(\.<span class="s-property">title</span>)
        )

        <span class="s-keyword">let</span> recommendations = engine.<span class="s-call">recommendations</span>(forTag: <span class="s-string">"tag"</span>)
        <span class="s-call">XCTAssertEqual</span>(recommendations, <span class="s-type">Array</span>(articles[..&lt;<span class="s-number">3</span>]))
    }
}</code></pre><p>In general, using unit tests while developing libraries is a great way to <em>‚Äúdog-food‚Äù</em> all of our APIs and to work out how to handle various edge cases. Because at the end of the day, if our library is difficult to test, it‚Äôll likely be difficult to use in production as well.</p><h2>Conclusion</h2><p>While this article didn‚Äôt manage to cover every single aspect of library design and development, I hope that it has provided some useful insight into how I approach building stand-alone Swift libraries.</p><p>It‚Äôs also important to point out that not all reusable components need to be implemented as separate libraries ‚Äî sometimes simply sharing a piece of logic as an internal class or struct is more than good enough ‚Äî especially since libraries are also dependencies that need to be managed, updated and maintained. But when warranted, building a completely reusable system as its own library definitely has a ton of benefits.</p><p>What do you think? Do you tend to structure parts of your code as reusable libraries, or is it something that you‚Äôll try out? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="false">swiftbysundell/links/my-origin-story-on-ios-dev-discussions</guid><title>Link: My origin story on Sean Allen‚Äôs podcast</title><description></description><link>https://podcasts.apple.com/us/podcast/origin-story-john-sundell/id1426167395?i=1000476052675</link><pubDate>Fri, 29 May 2020 12:30:00 +0200</pubDate><content:encoded><![CDATA[<p>This week, I joined my friend Sean Allen on his podcast <em>iOS Dev Discussions</em> to share my ‚Äúorigin story‚Äù ‚Äî that is, how I got started with programming, how writing and podcasting ended up becoming my full-time job, how I‚Äôve been progressing through my career, and examples of the mistakes that I‚Äôve learned from along the way.</p><p>Even though I don‚Äôt typically like to spend an hour and a half talking about myself non-stop, I really enjoyed recording this episode, and hope you‚Äôll enjoy it too.</p><p><strong><a href="https://podcasts.apple.com/us/podcast/origin-story-john-sundell/id1426167395?i=1000476052675">Listen to the episode in your podcast player of choice, for example Apple Podcasts</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/instabug-may-2020</guid><title>Sponsor: Instabug</title><description>Thanks a lot to Instabug for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/instabug-may-2020</link><pubDate>Thu, 28 May 2020 19:55:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to Instabug for supporting Swift by Sundell with another two-week sponsorship, and this time they‚Äôve even got a brand new offer, created exclusively for all Swift by Sundell readers.</p><p>If you sign up for a free trial of Instabug using <a href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-may-18-2">this link</a>, then they‚Äôll give you an additional <strong>two months for free</strong> ‚Äî giving you lots of time to try it out to see if it‚Äôs a good fit for you and your team.</p><p>So what‚Äôs Instabug? It started out as a really rock solid crash reporter with a strong focus on both privacy and security, and it still is, but it has also evolved into a complete package for improving an app‚Äôs overall quality and stability.</p><p>Apart from getting detailed crash reports completely automatically, you can use Instabug to run in-app surveys, to provide direct support to your users, and to monitor your app‚Äôs overall performance. Each Instabug report contains a ton of useful debugging information ‚Äî such as network logs, reproduction steps, and much more.</p><p>I‚Äôve used Instabug myself in several projects, and it‚Äôs always been truly great. But don‚Äôt take my word for it ‚Äî <a href="https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-may-18-2">sign up for a completely free trial</a> to try Instabug for yourself. Using that link also helps keep Swift by Sundell free and available to everyone.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/quickly-replacing-singletons-with-functions</guid><title>Tip: Quickly replacing singletons with functions</title><description></description><link>https://www.swiftbysundell.com/tips/quickly-replacing-singletons-with-functions</link><pubDate>Wed, 27 May 2020 16:35:00 +0200</pubDate><content:encoded><![CDATA[<p>The singleton pattern, while incredibly widely used, is a common source of debate within the Apple developer community. On one hand, singletons provide a really convenient way to share state and functionality across an application ‚Äî but on the other hand, they also tend to blur the boundaries between the various layers of a code base, and often make tasks like testing more difficult than they otherwise would be.</p><p>As an example, let‚Äôs say that we‚Äôre working on a <code>UserLoader</code>, which provides a way to load a <code>User</code> with a given ID. Internally, our loader uses two singletons to perform its work ‚Äî a <code>UserCache</code> and a <code>NetworkManager</code> ‚Äî and currently looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">func</span> loadUser(
        withID id: <span class="s-type">User</span>.<span class="s-type">ID</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">User</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        <span class="s-comment">// If our shared cache already contains the user we're
        // about to load, then use that cached value instead:</span>
        <span class="s-keyword">if let</span> user = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-call">user</span>(withID: id) {
            <span class="s-keyword">return</span> <span class="s-call">handler</span>(.<span class="s-call">success</span>(user))
        }

        <span class="s-comment">// Use our application's shared network manager to perform
        // a network call, and then decode the result:</span>
        <span class="s-type">NetworkManager</span>.<span class="s-property">shared</span>.<span class="s-call">loadData</span>(from: .<span class="s-call">user</span>(id: id)) { result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
                <span class="s-keyword">let</span> user = <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">User</span>.<span class="s-keyword">self</span>, from: data)
                <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-call">insert</span>(user)
                <span class="s-call">handler</span>(.<span class="s-call">success</span>(user))
            } <span class="s-keyword">catch</span> {
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>While the above type does everything that we need it to do in terms of our production code, unit testing its internal logic would be quite difficult ‚Äî as it currently offers no way for us to inject <a href="https://www.swiftbysundell.com/articles/mocking-in-swift">mocked versions</a> of its dependencies.</p><p>For example, let‚Äôs say that we wanted to write a test that verifies our caching logic ‚Äî to make sure that we‚Äôre not performing duplicate network requests when loading the same user multiple times. How could we do that using our current singleton-based setup ‚Äî given that there‚Äôs currently no way for us to observe, or otherwise control, what type of networking that our <code>UserLoader</code> is using?</p><p>While there are a number of different approaches that we could take in order to solve this problem, including <a href="https://www.swiftbysundell.com/articles/testing-swift-code-that-uses-system-singletons-in-3-easy-steps">abstracting our dependencies behind protocols</a>, or using some form of mocked networking session ‚Äî it turns out that there‚Äôs a quite easy way to make most singletons mockable, without having to introduce a ton of new abstractions.</p><p>Since Swift supports <a href="https://www.swiftbysundell.com/clips/1">first class functions</a>, we could simply extract each of the functions that we‚Äôre looking to call on our singletons, and store them as properties instead ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">var</span> networking = <span class="s-type">NetworkManager</span>.<span class="s-property">shared</span>.<span class="s-property">loadData</span>
    <span class="s-keyword">var</span> cacheInsertion = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">insert</span>
    <span class="s-keyword">var</span> cacheRetrieval = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">user</span>
    
    ...
}</code></pre><p>What‚Äôs really neat about the above approach is that it barely requires us to change our production code at all. All usages of our <code>UserLoader</code> type can remain identical, there‚Äôs no need for advanced dependency injection techniques, and within the implementation of our type we just need to replace our singleton calls with calls to our stored functions ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">var</span> networking = <span class="s-type">NetworkManager</span>.<span class="s-property">shared</span>.<span class="s-property">loadData</span>
    <span class="s-keyword">var</span> cacheInsertion = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">insert</span>
    <span class="s-keyword">var</span> cacheRetrieval = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">user</span>

    <span class="s-keyword">func</span> loadUser(
        withID id: <span class="s-type">User</span>.<span class="s-type">ID</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">User</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        <span class="s-keyword">if let</span> user = <span class="s-call">cacheRetrieval</span>(id) {
            <span class="s-keyword">return</span> <span class="s-call">handler</span>(.<span class="s-call">success</span>(user))
        }

        <span class="s-call">networking</span>(.<span class="s-call">user</span>(id: id)) { [cacheInsertion] result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
                <span class="s-keyword">let</span> user = <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">User</span>.<span class="s-keyword">self</span>, from: data)
                <span class="s-call">cacheInsertion</span>(user)
                <span class="s-call">handler</span>(.<span class="s-call">success</span>(user))
            } <span class="s-keyword">catch</span> {
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>With just that little tweak in place, our <code>UserLoader</code> has now been transformed from being really difficult to test, to being fully testable. All that we now have to do to write the test that we initially wanted to (for verifying our caching logic) is to replace our real networking code with a local closure within our test ‚Äî for example like this:</p><pre class="splash"><code><span class="s-keyword">class</span> UserLoaderTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testUserCaching() {
        <span class="s-keyword">let</span> user = <span class="s-type">User</span>(id: <span class="s-type">UUID</span>(), name: <span class="s-string">"John"</span>)
        <span class="s-keyword">var</span> loader = <span class="s-type">UserLoader</span>()
        <span class="s-keyword">var</span> networkCallCount = <span class="s-number">0</span>

        <span class="s-comment">// Mock our networking using a closure</span>
        loader.<span class="s-property">networking</span> = { endpoint, handler <span class="s-keyword">in</span>
            networkCallCount += <span class="s-number">1</span>

            <span class="s-call">handler</span>(<span class="s-type">Result</span> {
                <span class="s-keyword">try</span> <span class="s-type">JSONEncoder</span>().<span class="s-call">encode</span>(user)
            })
        }

        <span class="s-comment">// Call our load method twice and capture both results:</span>
        <span class="s-keyword">var</span> results = [<span class="s-type">User</span>?]()
        loader.<span class="s-call">loadUser</span>(withID: user.<span class="s-property">id</span>) { results.<span class="s-call">append</span>(<span class="s-keyword">try</span>? $0.<span class="s-call">get</span>()) }
        loader.<span class="s-call">loadUser</span>(withID: user.<span class="s-property">id</span>) { results.<span class="s-call">append</span>(<span class="s-keyword">try</span>? $0.<span class="s-call">get</span>()) }

        <span class="s-call">XCTAssertEqual</span>(networkCallCount, <span class="s-number">1</span>, <span class="s-string">"""
        Only one network call should have been made,
        as the first one should have been cached.
        """</span>)

        <span class="s-call">XCTAssertEqual</span>(results, [user, user], <span class="s-string">"""
        The same user should have been loaded both times.
        """</span>)
    }
}</code></pre><p class="info">To learn more about the above approach to writing tests, check out <a href="https://www.swiftbysundell.com/articles/mock-free-unit-tests-in-swift">‚ÄúMock-free unit tests in Swift‚Äù</a> and <a href="https://www.swiftbysundell.com/tips/using-test-assertion-messages-as-comments">‚ÄúUsing test assertion messages as comments‚Äù</a>.</p><p>As an added bonus, if we wanted to make sure that our dependencies are only ever overridden within our tests, and other types of debug builds ‚Äî then we could bring in the property wrapper from <em><a href="https://www.swiftbysundell.com/tips/making-properties-overridable-only-in-debug-builds">‚ÄúMaking properties overridable only in debug builds‚Äù</a></em> and annotate each of our functional properties as <code>@DebugOverridable</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">@DebugOverridable
    var</span> networking = <span class="s-type">NetworkManager</span>.<span class="s-property">shared</span>.<span class="s-property">loadData</span>
    <span class="s-keyword">@DebugOverridable
    var</span> cacheInsertion = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">insert</span>
    <span class="s-keyword">@DebugOverridable
    var</span> cacheRetrieval = <span class="s-type">UserCache</span>.<span class="s-property">shared</span>.<span class="s-property">user</span>
    
    ...
}</code></pre><p>Now, is the above technique a <em>‚Äúsilver bullet‚Äù</em> that should always be used to manage singletons? Of course not. Creating proper abstractions and using <a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift">dependency injection</a> to keep track of our various dependencies is often the way to go for larger objects and dependency graphs ‚Äî but if we only want to quickly make a given singleton-reliant type testable, then the above technique can be great to keep in mind.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/getting-the-most-out-of-xcode-previews</guid><title>Getting the most out of Xcode Previews for SwiftUI</title><description>Let‚Äôs take a look at a number of techniques, patterns, and ways of structuring UI code that can help us get the very most out of Xcode‚Äôs SwiftUI-powered preview system.</description><link>https://www.swiftbysundell.com/articles/getting-the-most-out-of-xcode-previews</link><pubDate>Sun, 24 May 2020 18:42:00 +0200</pubDate><content:encoded><![CDATA[<p>Depending on who you ask, the SwiftUI-powered Previews feature introduced in Xcode 11 either provides a revolutionary new way of building UIs, or falls more towards the gimmick end of the usefulness spectrum.</p><p>However, like with most development tools, the amount of utility that Xcode‚Äôs previews can provide is to a large extent determined by how they‚Äôre used, and whether our code is set up in a way that‚Äôs compatible with them. So this week, let‚Äôs take a look at a few techniques, patterns, and ways of structuring UI code that can help us get the very most out of that new preview system.</p><h2>Screens, components, and interactivity</h2><p>Regardless of what framework that‚Äôs used to build a given UI, it‚Äôs typically useful to separate our various views into two main categories ‚Äî <em>screens</em> and <em>components</em>. While each of those can then have any number of subcategories, we‚Äôre often either working on a given app screen as a whole, or on a (more or less reusable) subset of it.</p><p>As an example, let‚Äôs say that we‚Äôre using SwiftUI to build such a reusable component ‚Äî in this case a row for rendering a reminder within something like a todo or reminders list:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRow: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
            <span class="s-type">Text</span>(title)
            <span class="s-type">Text</span>(description)
                .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
                .<span class="s-call">font</span>(.<span class="s-dotAccess">footnote</span>)
        }
    }
}</code></pre><p>Now, as we‚Äôre iterating on the above component, we could of course constantly build and run the app, navigate to a screen that its being used on, and verify that everything renders correctly ‚Äî but that‚Äôs boring, repetitive and error prone <em>(which just so happens to be my three main criteria for tasks that should ideally be automated)</em>.</p><p>This type of automation is exactly what Xcode‚Äôs Previews feature is all about ‚Äî as it lets us set up specific instances of our screens and components that‚Äôll automatically get updated as we iterate on our code.</p><p>To create a preview, all that we have to do is to define a type conforming to the <code>PreviewProvider</code> protocol, and place it within the Swift file that we wish the preview to appear alongside of ‚Äî like this:</p><pre class="splash"><code><span class="s-preprocessing">#if DEBUG</span>
<span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>
        )
    }
}
<span class="s-preprocessing">#endif</span></code></pre><p class="info">Note how we encapsulate the above preview using the <code>DEBUG</code> compiler directive. That‚Äôs to prevent us from accidentally using that type within our production code, as if we did, the compiler would throw an error once we build our app in release mode. You can assume that all preview-specific code within this article would be surrounded by that compiler directive, even if it won‚Äôt be typed out for the sake of brevity.</p><p>The cool thing is that Xcode‚Äôs preview system uses the same <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">DSL-like API</a> that SwiftUI uses, which gives us a lot of power and flexibility when it comes to how we set up our various previews throughout our code base.</p><p>However, the above <code>ReminderRow</code> implementation is currently quite simple, and only relies on read-only data that can easily be passed into its initializer ‚Äî but what if it required a bit more interactivity? For example, let‚Äôs say that we wanted to add a <code>Toggle</code> to our row, to enable our users to easily mark a given reminder as completed:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRow: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>
    <span class="s-keyword">@Binding var</span> isCompleted: <span class="s-type">Bool</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Toggle</span>(isOn: $isCompleted) {
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(title)
                <span class="s-type">Text</span>(description)
                    .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
                    .<span class="s-call">font</span>(.<span class="s-dotAccess">footnote</span>)
            }
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Since we‚Äôre now using the <code>Binding</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a> to set up a <em>two-way binding</em> between our reminder row and any parent that‚Äôll contain it, we also need to pass such a binding when creating our preview as well. One simple (but limited) way to do that would be to use the <code>.constant</code> API, which ‚Äî like the name implies ‚Äî enables us to pass a constant value that‚Äôll act as a preview <em>stand-in</em> for a proper binding:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">constant</span>(<span class="s-keyword">false</span>)
        )
    }
}</code></pre><p>However, as alluded to above, constant bindings do have quite strict limits, and they‚Äôll often prevent us from interacting with our UI as we‚Äôre previewing it. For example, even if we tap our above <code>Toggle</code>, its <code>isCompleted</code> value will always remain constant, which makes our view seem broken.</p><p>One way to fix that problem would be to instead introduce a custom <code>Binding</code> API for creating fully dynamic mocks ‚Äî for example by <a href="https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics/%23capturing-values">capturing a given value</a> within a pair of getter and setter closures, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Binding</span> {
    <span class="s-keyword">static func</span> mock(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">var</span> value = value
        <span class="s-keyword">return</span> <span class="s-type">Binding</span>(get: { value }, set: { value = $0 })
    }
}</code></pre><p>With the above in place, we can now go back to our <code>ReminderRowPreview</code> implementation and make it fully interactive ‚Äî simply by replacing <code><span class="highlight">.constant</code> with <code>.mock</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)</span>
        )
    }
}</code></pre><p>The beauty of the fact that Xcode previews are declared using normal Swift code is that it lets us write our own utilities and abstractions, that in turn can let us use previews in much more powerful ways. But that‚Äôs just the beginning.</p><h2>Specific environments</h2><p>Next, let‚Äôs take a look at how modifying a component‚Äôs surrounding <em>environment</em> can let us preview how it‚Äôll behave under various simulated conditions.</p><p>To get started, let‚Äôs use the built-in <code>.colorScheme</code> <a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views/%23modifier-types">view modifier</a> to preview what our <code>ReminderRow</code> will look like when rendered on a device that‚Äôs running in <em>dark mode</em> ‚Äî like this:</p><pre data-preview="partial-dark-mode"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">colorScheme</span>(.<span class="s-dotAccess">dark</span>)
    }
}</code></pre><p>While the above preview setup will render our component <em>itself</em> in dark mode, its surroundings will still remain in light mode, which (given that our view doesn‚Äôt have a background color) gives us white text rendered on a white background. Not great.</p><p class="info">Tip: you can use the above <code>PREVIEW</code> button to see the result of that code block. <em>A preview of a preview, if you will. Very meta</em>.</p><p>Now, there are two main ways to solve the above problem. One way is to embed our <code>ReminderRow</code> component in a platform-provided container, such as a <code>NavigationView</code>, before previewing it. If we do that, while also hiding that container view‚Äôs navigation bar, then our component will still be rendered using the same layout as before ‚Äî but now in full dark mode:</p><pre data-preview="complete-dark-mode"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">ReminderRow</span>(
                title: <span class="s-string">"Write weekly article"</span>,
                description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
                isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
            )
            .<span class="s-call">navigationBarTitle</span>(<span class="s-string">""</span>)
            .<span class="s-call">navigationBarHidden</span>(<span class="s-keyword">true</span>)
        }
        .<span class="s-call">colorScheme</span>(.<span class="s-dotAccess">dark</span>)
    }
}</code></pre><p class="info">Another variant of the above approach would be to use a <code>TabView</code> instead, and then hide its tab bar in a similar fashion.</p><p>The other way, which doesn‚Äôt involve adding any form of navigation stack, would be to give our component an explicit background color ‚Äî and if we use the <code>systemBackground</code> API on <code>UIColor</code>, then we can mimmic what our component will look like when displayed in dark mode (even if its environment will still remain in light mode):</p><pre data-preview="local-dark-mode"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">background</span>(<span class="s-type">Color</span>(<span class="s-type">UIColor</span>.<span class="s-property">systemBackground</span>))
        .<span class="s-call">colorScheme</span>(.<span class="s-dotAccess">dark</span>)
    }
}</code></pre><p>However, what color scheme that our previews will be rendered using is just one of many different environment parameters that we can tweak. For example, we can also tell SwiftUI to preview our component using a given size category (which is what the system‚Äôs <em>dynamic type</em> settings translate into), and even control what device that the preview will be rendered on:</p><pre class="splash"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">previewDevice</span>(<span class="s-string">"iPhone 11"</span>)
        .<span class="s-call">environment</span>(\.<span class="s-property">sizeCategory</span>, .<span class="s-dotAccess">accessibilityExtraExtraExtraLarge</span>)
    }
}</code></pre><p class="info">No, the above <code>ExtraExtraExtra</code> name is not a typo, that‚Äôs actually what the real API is called, believe it or not.</p><p>So Xcode‚Äôs preview system can be tweaked and adjusted in many different ways ‚Äî which either lets us set up a specific environment for each component, or even create multiple simultaneous ones.</p><h2>Group, iterations, and convenience APIs</h2><p>Just like standard SwiftUI views, multiple preview views can be grouped into a single container using the <code>Group</code> API. However, within Xcode‚Äôs Preview feature, such groups are treated in a special way, as the system will create a separate preview for each group member ‚Äî which in turn enables us to easily preview multiple view configurations at the same time.</p><p>For example, here‚Äôs how we could quickly preview what our <code>ReminderRow</code> will look like when rendered in both light and dark mode, using a single <code>PreviewProvider</code>:</p><pre data-preview="multiple-previews"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-keyword">let</span> row = <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">previewLayout</span>(.<span class="s-dotAccess">sizeThatFits</span>)

        <span class="s-keyword">return</span> <span class="s-type">Group</span> {
            row

            row.<span class="s-call">background</span>(<span class="s-type">Color</span>(<span class="s-type">UIColor</span>.<span class="s-property">systemBackground</span>))
               .<span class="s-call">colorScheme</span>(.<span class="s-dotAccess">dark</span>)
        }
    }
}</code></pre><p class="info">Note how we‚Äôre using the <code>.previewLayout</code> modifier above to tell Xcode to render our previews without any ‚Äúdevice chrome‚Äù, and instead just display each component configuration as a stand-alone view.</p><p>While the above approach is really convenient when we just want to preview a small number of permutations ‚Äî if we want to combine multiple environment modifiers in order to preview more layout variants, then writing the above kind of code each time can start to become a bit tedious.</p><p>But again, we‚Äôre working with normal Swift code here, so just like whenever we discover a repetitive source of boilerplate within our production code, we can build our own custom abstractions on top of the preview system ‚Äî to help us generate a large number of previews with very little effort.</p><p>But before we get started, we‚Äôre going to need a few small extensions that‚Äôll help us label each of the previews that we‚Äôre about to generate. In this case, we‚Äôre going to combine each possible <code>ColorScheme</code> (that is, currently, light and dark mode) with the smallest and largest <code>ContentSizeCategory</code> values ‚Äî so let‚Äôs write the following pair of extensions for generating preview-specific names for those types, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ColorScheme</span> {
    <span class="s-keyword">var</span> previewName: <span class="s-type">String</span> {
        <span class="s-type">String</span>(describing: <span class="s-keyword">self</span>).<span class="s-property">capitalized</span>
    }
}

<span class="s-keyword">extension</span> <span class="s-type">ContentSizeCategory</span> {
    <span class="s-keyword">static let</span> smallestAndLargest = [allCases.<span class="s-property">first</span>!, allCases.<span class="s-property">last</span>!]

    <span class="s-keyword">var</span> previewName: <span class="s-type">String</span> {
        <span class="s-keyword">self</span> == <span class="s-type">Self</span>.<span class="s-property">smallestAndLargest</span>.<span class="s-property">first</span> ? <span class="s-string">"Small"</span> : <span class="s-string">"Large"</span>
    }
}</code></pre><p>Next, let‚Äôs borrow the following <code>ForEach</code> extension from <em><a href="https://www.swiftbysundell.com/tips/using-swiftui-foreach-with-raw-values">‚ÄúUsing SwiftUI‚Äôs ForEach with raw values‚Äù</a></em>, which‚Äôll let us more easily loop over an array of values within our SwiftUI code:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ForEach</span> <span class="s-keyword">where</span> <span class="s-type">Data</span>.<span class="s-type">Element</span>: <span class="s-type">Hashable</span>, <span class="s-type">ID</span> == <span class="s-type">Data</span>.<span class="s-type">Element</span>, <span class="s-type">Content</span>: <span class="s-type">View</span> {
    <span class="s-keyword">init</span>(values: <span class="s-type">Data</span>, content: <span class="s-keyword">@escaping</span> (<span class="s-type">Data</span>.<span class="s-type">Element</span>) -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-keyword">init</span>(values, id: \.<span class="s-keyword">self</span>, content: content)
    }
}</code></pre><p>With the above pieces in place, we can now start building our custom abstractions for generating multiple previews. First, let‚Äôs create one for previewing individual components ‚Äî by implementing a wrapper <code>View</code> that iterates over each possible <code>ColorScheme</code>, as well as the <code>ContentSizeCategory</code> array we defined above, and sets up each preview accordingly:</p><pre class="splash"><code><span class="s-keyword">struct</span> ComponentPreview&lt;Component: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> component: <span class="s-type">Component</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ForEach</span>(values: <span class="s-type">ColorScheme</span>.<span class="s-property">allCases</span>) { scheme <span class="s-keyword">in</span>
            <span class="s-type">ForEach</span>(values: <span class="s-type">ContentSizeCategory</span>.<span class="s-property">smallestAndLargest</span>) { category <span class="s-keyword">in
                self</span>.<span class="s-property">component</span>
                    .<span class="s-call">previewLayout</span>(.<span class="s-dotAccess">sizeThatFits</span>)
                    .<span class="s-call">background</span>(<span class="s-type">Color</span>(<span class="s-type">UIColor</span>.<span class="s-property">systemBackground</span>))
                    .<span class="s-call">colorScheme</span>(scheme)
                    .<span class="s-call">environment</span>(\.<span class="s-property">sizeCategory</span>, category)
                    .<span class="s-call">previewDisplayName</span>(
                        <span class="s-string">"</span>\(scheme.<span class="s-property">previewName</span>) <span class="s-string">+</span> \(category.<span class="s-property">previewName</span>)<span class="s-string">"</span>
                    )
            }
        }
    }
}</code></pre><p class="info">Note that <code>ForEach</code> has the same effect as <code>Group</code> within previews, in that using it generates a separate preview for each value that is being iterated over.</p><p>While the above type is ready to be used as-is, let‚Äôs also create a convenience API that‚Äôll let us easily generate a component preview for any <code>View</code> within our code base:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> previewAsComponent() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ComponentPreview</span>(component: <span class="s-keyword">self</span>)
    }
}</code></pre><p>With that done, we can now go back to our <code>ReminderRowPreview</code> from before and easily make it generate four different previews, simply by calling our new <code>previewAsComponent</code> API on our component:</p><pre data-preview="generated-previews"><code><span class="s-keyword">struct</span> ReminderRowPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ReminderRow</span>(
            title: <span class="s-string">"Write weekly article"</span>,
            description: <span class="s-string">"Think it'll be about Xcode Previews"</span>,
            isCompleted: .<span class="s-call">mock</span>(<span class="s-keyword">false</span>)
        )
        .<span class="s-call">previewAsComponent</span>()
    }
}</code></pre><p>Next, let‚Äôs implement a similar abstraction for previewing complete screens, rather than individual components. While we were primarily interested in seeing how a given component behaves when rendered using different color schemes and content size categories ‚Äî when previewing a whole screen, we might instead want to see how it gets rendered on multiple devices. That way, we‚Äôll be able to get a more wholistic view of our UI, especially if we also combine that list of devices with all possible <code>ColorScheme</code> variants as well ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ScreenPreview&lt;Screen: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> screen: <span class="s-type">Screen</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ForEach</span>(values: deviceNames) { device <span class="s-keyword">in</span>
            <span class="s-type">ForEach</span>(values: <span class="s-type">ColorScheme</span>.<span class="s-property">allCases</span>) { scheme <span class="s-keyword">in</span>
                <span class="s-type">NavigationView</span> {
                    <span class="s-keyword">self</span>.<span class="s-property">screen</span>
                        .<span class="s-call">navigationBarTitle</span>(<span class="s-string">""</span>)
                        .<span class="s-call">navigationBarHidden</span>(<span class="s-keyword">true</span>)
                }
                .<span class="s-call">previewDevice</span>(<span class="s-type">PreviewDevice</span>(rawValue: device))
                .<span class="s-call">colorScheme</span>(scheme)
                .<span class="s-call">previewDisplayName</span>(<span class="s-string">"</span>\(scheme.<span class="s-property">previewName</span>)<span class="s-string">:</span> \(device)<span class="s-string">"</span>)
                .<span class="s-call">navigationViewStyle</span>(<span class="s-type">StackNavigationViewStyle</span>())
            }
        }
    }

    <span class="s-keyword">private var</span> deviceNames: [<span class="s-type">String</span>] {
        [
            <span class="s-string">"iPhone 8"</span>,
            <span class="s-string">"iPhone 11"</span>,
            <span class="s-string">"iPhone 11 Pro Max"</span>,
            <span class="s-string">"iPad (7th generation)"</span>,
            <span class="s-string">"iPad Pro (12.9-inch) (4th generation)"</span>
        ]
    }
}

<span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> previewAsScreen() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ScreenPreview</span>(screen: <span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">Note how the above list of <code>deviceNames</code> need to exactly match the names that appear in Xcode‚Äôs device selector, otherwise the preview system will throw an error.</p><p>With the above abstractions in place, we can now easily generate either a compact or full-screen preview for any of our views with just a single method call ‚Äî with in turn lets us iterate on our UI code while instantly seeing how it‚Äôll get rendered within multiple kinds of environments. Really cool!</p><h2>Previews are not just for SwiftUI views</h2><p>Finally, let‚Äôs take a look at how we can even use Xcode‚Äôs Previews feature to iterate on views that are <em>not</em> built using SwiftUI ‚Äî but rather using any of Apple‚Äôs older UI frameworks, such as UIKit, Core Animation, or AppKit.</p><p>Since each preview is defined as a SwiftUI view, and since there are a built-in <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match">backward compatible APIs</a> that let us bring any <code>UIView</code> or <code>UIViewController</code> (or their AppKit equivalents) into the world of SwiftUI ‚Äî we can connect those two things to make the preview system even more flexible.</p><p>One way to make that happen would be to create specific bridging types for individual views or view controllers ‚Äî for example like this:</p><pre class="splash"><code><span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
<span class="s-keyword">struct</span> SchedulingView: <span class="s-type">UIViewControllerRepresentable</span> {
    <span class="s-keyword">var</span> schedule: <span class="s-type">Schedule</span>

    <span class="s-keyword">func</span> makeUIViewController(context: <span class="s-type">Context</span>) -&gt; <span class="s-type">SchedulingViewController</span> {
        <span class="s-type">SchedulingViewController</span>(schedule: schedule)
    }

    <span class="s-keyword">func</span> updateUIViewController(<span class="s-keyword">_</span> uiViewController: <span class="s-type">SchedulingViewController</span>,
                                context: <span class="s-type">Context</span>) {
        <span class="s-comment">// We don‚Äôt need to write any update code in this case.</span>
    }
}

<span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
<span class="s-keyword">struct</span> SchedulingViewPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">SchedulingView</span>(schedule: <span class="s-type">Schedule</span>())
    }
}</code></pre><p class="info">Note how both of the above types are marked as iOS 13-only, using Swift‚Äôs <code>@available</code> attribute. While that‚Äôs not required for apps that have iOS 13 as their minimum deployment target, many apps that were written using UIKit or AppKit still need to support older versions of Apple‚Äôs operating systems.</p><p>While the above works perfectly fine for previewing a single view controller, having to write a dedicated wrapper type each time that we want to create a new preview can again become a source of boilerplate and friction. So let‚Äôs create one more abstraction ‚Äî this time to enable any <code>UIViewController</code> to easily be turned into a SwiftUI preview, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIViewController</span> {
    <span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
    <span class="s-keyword">private struct</span> Preview: <span class="s-type">UIViewControllerRepresentable</span> {
        <span class="s-keyword">var</span> viewController: <span class="s-type">UIViewController</span>

        <span class="s-keyword">func</span> makeUIViewController(context: <span class="s-type">Context</span>) -&gt; <span class="s-type">UIViewController</span> {
            viewController
        }

        <span class="s-keyword">func</span> updateUIViewController(<span class="s-keyword">_</span> uiViewController: <span class="s-type">UIViewController</span>,
                                    context: <span class="s-type">Context</span>) {
            <span class="s-comment">// No-op</span>
        }
    }

    <span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
    <span class="s-keyword">func</span> asPreview() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Preview</span>(viewController: <span class="s-keyword">self</span>)
    }
}</code></pre><p>With the above in place, we can now easily make any of our view controllers compatible with Xcode Previews. All that we have to do is to create a thin <code>PreviewProvider</code> that calls our new <code>asPreview</code> method on the view controller that we wish to preview:</p><pre class="splash"><code><span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
<span class="s-keyword">struct</span> SchedulingViewPreview: <span class="s-type">PreviewProvider</span> {
    <span class="s-keyword">static var</span> previews: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">SchedulingViewController</span>(schedule: <span class="s-type">Schedule</span>()).<span class="s-call">asPreview</span>()
    }
}</code></pre><p>In general, defining lightweight abstractions through small wrappers and extensions can often be a great way to improve a team‚Äôs overall productivity. Especially when it comes to things like UI previews, and other kinds of tooling, we‚Äôd ideally like to reduce the amount of friction and setup required to the absolute minimum ‚Äî so that we can spend less time configuring our tools, and more time building fantastic UIs.</p><h2>Conclusion</h2><p>Whether you‚Äôve been using Xcode Previews since the first beta of Xcode 11, or whether they‚Äôre completely new to you, I hope that this article has showed you at least one new way of using them. Of course, there are several other ways that these previews can be used, and I‚Äôm sure that Apple will introduce even more previewing capabilities at WWDC20, which (at the time of writing) kicks off in just a few weeks.</p><p>Reducing iteration cycle times can really be a big productivity booster, and that‚Äôs something that Xcode Previews can definitely help us achieve ‚Äî by turning time consuming <em>‚ÄúBuild and run‚Äù</em> cycles into almost instant updates. They‚Äôre not perfect, and can (just like Xcode itself) sometimes be a bit unstable, but ‚Äî at least if you ask me ‚Äî they‚Äôre a big leap forward for UIKit, AppKit and SwiftUI-based UI development.</p><p>What do you think? Do you enjoy using Xcode‚Äôs Preview feature? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/properties</guid><title>Basics: Properties</title><description>In this Basics article, let‚Äôs take a look at a few examples of the various kinds of properties that Swift supports, and what their characteristics are.</description><link>https://www.swiftbysundell.com/basics/properties</link><pubDate>Fri, 22 May 2020 18:10:00 +0200</pubDate><content:encoded><![CDATA[<p>Just like many other programming languages, Swift enables us to organize our in-memory data by storing it in <em>properties</em> ‚Äî constants and variables that are attached to a given type, value, or object. In this Basics article, let‚Äôs take a look at a few examples of various kinds of properties and what their characteristics are.</p><p><em>Mutable properties</em> are declared using the <code>var</code> keyword, along with the type of value that the property is going to store ‚Äî unless the latter can be inferred by the compiler. For example, here we‚Äôre defining three properties within a <code>Book</code> type ‚Äî two of which are manually typed as <code>String</code>, while the third will have its type (<code>Int</code>) inferred from its <em>default value</em>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Book {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> author: <span class="s-type">String</span>
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span>
}</code></pre><p>On the other hand, if we want to <em>prevent</em> one of our properties from being mutated after being initialized, then we can use the <code>let</code> keyword to make it a <em>constant property</em> instead ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Book {
    <span class="highlight offset-adjust"><span class="s-keyword">let</span> id: <span class="s-type">UUID</span></span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> author: <span class="s-type">String</span>
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span>
}</code></pre><p>The above setup lets us create a <code>Book</code> instance using any value for the above four properties (although we can also omit <code>numberOfStars</code> if we‚Äôd like, since it has a default value), but only our mutable properties may be modified afterwards:</p><pre class="splash"><code><span class="s-keyword">var</span> book = <span class="s-type">Book</span>(
    id: <span class="s-type">UUID</span>(),
    name: <span class="s-string">"The Swift Programming Language"</span>,
    author: <span class="s-string">"Apple"</span>
)

book.<span class="s-property">id</span> = <span class="s-type">UUID</span>() <span class="s-comment">// Compiler error</span>
book.<span class="s-property">name</span> = <span class="s-string">"New name"</span> <span class="s-comment">// Allowed</span>
book.<span class="s-property">numberOfStars</span> += <span class="s-number">1</span> <span class="s-comment">// Also allowed</span></code></pre><p>All of the above are examples of <em>stored properties</em> ‚Äî properties which values are stored in memory once assigned. <em>Computed properties</em>, on the other hand, enable us to define convenience APIs in the shape of properties that are recomputed each time that they‚Äôre accessed.</p><p>For example, if different parts of our logic requires us to check if a given book‚Äôs name is longer than 30 characters ‚Äî we might want to encapsulate that calculation within a computed <code>hasLongName</code> property, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Book</span> {
    <span class="s-keyword">var</span> hasLongName: <span class="s-type">Bool</span> {
        name.<span class="s-property">count</span> &gt; <span class="s-number">30</span>
    }
}</code></pre><p class="info">The benefit of computed properties is that we don‚Äôt need to manually sync them with the underlying state that they‚Äôre derived from, since they‚Äôre recomputed each time. However, that also means that we have to be careful not to perform any heavy computation within them. For more on that topic, check out <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift">‚ÄúComputed properties in Swift‚Äù</a>.</p><p>While the above computed property is read-only, we can also define ones that have both a getter and a setter (making them act identical to a <code>var</code>, apart from the fact that their values aren‚Äôt stored). As an example, let‚Äôs say that we wanted to modify our <code>Book</code> type‚Äôs <code>author</code> property to contain an <code>Author</code> value, rather than a <code>String</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Author {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> country: <span class="s-type">String</span>
}

<span class="s-keyword">struct</span> Book {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> author: <span class="s-type">Author</span>
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span>
}</code></pre><p>To still be able to easily access and modify a given book‚Äôs author name, we could then add a computed property with both a getter and setter for doing just that ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Book</span> {
    <span class="s-keyword">var</span> authorName: <span class="s-type">String</span> {
        <span class="s-keyword">get</span> { author.<span class="s-property">name</span> }
        <span class="s-keyword">set</span> { author.<span class="s-property">name</span> = newValue }
    }
}</code></pre><p>Next, let‚Äôs take a look at <em>lazy properties</em>. A property marked with the <code>lazy</code> keyword must be mutable, and have a default value assigned to it ‚Äî however, that default value won‚Äôt be computed until the property is <em>accessed for the first time</em>. That characteristic sort of makes lazy properties act as a <em>‚Äúmiddle ground‚Äù</em> between computed and stored ones, which comes very much in handy when building view controller-based UIs.</p><p>Since view controllers shouldn‚Äôt start creating their subviews until the <code>viewDidLoad</code> method has been called by the system, one really neat way to avoid having to store such subviews as <a href="https://www.swiftbysundell.com/basics/optionals">optionals</a> is to make them lazy instead ‚Äî which will defer their creation until they‚Äôre accessed (for example in <code>viewDidLoad</code>):</p><pre class="splash"><code><span class="s-keyword">class</span> BookViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private lazy var</span> nameLabel = <span class="s-type">UILabel</span>()
    <span class="s-keyword">private lazy var</span> authorLabel = <span class="s-type">UILabel</span>()
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        view.<span class="s-call">addSubview</span>(nameLabel)
        view.<span class="s-call">addSubview</span>(authorLabel)
    }
}</code></pre><p class="info">The above two properties are marked as <code>private</code> to only make them visible within our view controller itself. To learn more about that, check out the <a href="https://www.swiftbysundell.com/basics/access-control">Basics article about access control</a>.</p><p>Lazy properties can also have their value computed by a closure or a function. For example, here we‚Äôre now using a private <code>makeNameLabel</code> method to create and setup the <code>UILabel</code> for our <code>nameLabel</code> property:</p><pre class="splash"><code><span class="s-keyword">class</span> BookViewController: <span class="s-type">UIViewController</span> {
    <span class="highlight offset-adjust"><span class="s-keyword">private lazy var</span> nameLabel = <span class="s-call">makeNameLabel</span>()</span>
    <span class="s-keyword">private lazy var</span> authorLabel = <span class="s-type">UILabel</span>()

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        view.<span class="s-call">addSubview</span>(nameLabel)
        view.<span class="s-call">addSubview</span>(authorLabel)
    }
    
    <span class="s-keyword">private func</span> makeNameLabel() -&gt; <span class="s-type">UILabel</span> {
        <span class="s-keyword">let</span> label = <span class="s-type">UILabel</span>()
        label.<span class="s-property">font</span> = .<span class="s-call">preferredFont</span>(forTextStyle: .<span class="s-dotAccess">largeTitle</span>)
        label.<span class="s-property">textColor</span> = .<span class="s-dotAccess">orange</span>
        <span class="s-keyword">return</span> label
    }
}</code></pre><p>So far, we‚Äôve been focusing on <em>instance properties</em>, which are all associated with a single instance of a type. But we can also define <em>static properties</em> ‚Äî ones that are attached to a type itself, rather than to instances of it. Such properties can be really useful when we want to share a given object across all instances of a type, in order to avoid having to recreate it multiple times.</p><p>For example, here we‚Äôve defined a static <code>dateFormatter</code> property, which is computed through a <em>self-executing <a href="https://www.swiftbysundell.com/basics/closures">closure</a></em>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Book</span> {
    <span class="s-keyword">static let</span> dateFormatter: <span class="s-type">DateFormatter</span> = {
        <span class="s-keyword">let</span> formatter = <span class="s-type">DateFormatter</span>()
        formatter.<span class="s-property">dateFormat</span> = <span class="s-string">"yyyy-MM-dd"</span>
        <span class="s-keyword">return</span> formatter
    }()
}</code></pre><p class="info">Static properties are also implicitly lazy, in that they‚Äôre only computed once they‚Äôre accessed for the first time.</p><p>We can now use the above date formatter whenever we want to convert a <code>Book</code>-related date into a string, or vice versa:</p><pre class="splash"><code><span class="s-keyword">let</span> string = <span class="s-type">Book</span>.<span class="s-property">dateFormatter</span>.<span class="s-call">string</span>(from: date)</code></pre><p>We can also attach <em>observers</em> to any stored property, which enables us to run code each time that a value was (or will be) assigned to that property. For example, here we‚Äôre using the <code>didSet</code> property observer to automatically update a label every time that a <code>numberOfStars</code> property was changed:</p><pre class="splash"><code><span class="s-keyword">class</span> RatingViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span> {
        <span class="s-keyword">didSet</span> { starCountLabel.<span class="s-property">text</span> = <span class="s-type">String</span>(numberOfStars) }
    }

    <span class="s-keyword">private lazy var</span> starCountLabel = <span class="s-type">UILabel</span>()
    
    ...
}</code></pre><p class="info">There‚Äôs also a <code>willSet</code> variant that gets triggered <em>before</em> the property‚Äôs value was assigned, rather than afterwards. To learn more, check out <a href="https://www.swiftbysundell.com/articles/property-observers-in-swift">‚ÄúProperty observers in Swift‚Äù</a>.</p><p>Property observers can also be used to validate or modify each new value ‚Äî for example to make sure that a numeric value stays within a certain range, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Book {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> author: <span class="s-type">Author</span>
    <span class="s-keyword">var</span> numberOfStars = <span class="s-number">0</span> {
        <span class="s-keyword">didSet</span> {
            <span class="s-comment">// If the new value was higher than 9999, we reduce
            // it down to that value, which is our maximum:</span>
            numberOfStars = <span class="s-call">min</span>(<span class="s-number">9999</span>, numberOfStars)
        }
    }
}</code></pre><p>Finally, properties can also be referred to in more dynamic ways using <em>key paths</em> ‚Äî which let us pass a reference to a property <em>itself</em>, rather than to its <em>value</em>.</p><p>Key paths can also automatically be converted into functions (since Swift 5.2), which means that they‚Äôre really useful in situations when we want to extract values for a given property from a collection of instances ‚Äî for example by using <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap"><code>map</code></a> on an array, like this:</p><pre class="splash"><code><span class="s-comment">// Converting an array of books into an array of strings, by
// extracting each book's name:</span>
<span class="s-keyword">let</span> books = <span class="s-call">loadBooks</span>() <span class="s-comment">// [Book]</span>
<span class="s-keyword">let</span> bookNames = books.<span class="s-call">map</span>(\.<span class="s-property">name</span>) <span class="s-comment">// [String]</span></code></pre><p class="info">To learn more about key paths and how they relate to functions, check out <a href="https://www.swiftbysundell.com/clips/6">this episode of Swift Clips</a>.</p><p>Those are just a few examples of the many ways to use properties in Swift, but hopefully this article has either given you a useful recap of some of their basic set of capabilities, or have inspired you to explore some of these topics further ‚Äî for example <a href="https://www.swiftbysundell.com/tags/properties">using these articles</a>, or by downloading this article‚Äôs playground using the link below.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/special/javascript-free</guid><title>Why does Swift by Sundell not use any client-side JavaScript?</title><description>In this article, I‚Äôll aim to explain both why I chose not to use any client-side JavaScript when building Swift by Sundell, and why I thought that it was important to emphasize that fact at the bottom of every page.</description><link>https://www.swiftbysundell.com/special/javascript-free</link><pubDate>Thu, 21 May 2020 16:30:00 +0200</pubDate><content:encoded><![CDATA[<p>You might‚Äôve noticed that this website contains the phrase <em>‚Äù100% JavaScript-free‚Äù</em> at the bottom of every page, which might seem like an odd thing to include ‚Äî given that most of the modern web is, to a large extent, powered by JavaScript.</p><p>So in this article, I‚Äôll aim to explain both why I chose not to use any client-side JavaScript when building this website, and why I thought that it was important to emphasize that fact at the bottom of every page.</p><h2>The good, the bad and the ugly parts of the modern web</h2><p>Over the past few decades, the web has evolved in truly magnificent ways ‚Äî from a limited network of computers exchanging plain text, into a fundamental part of modern life. A major step in that evolution process was, without a doubt, the popularization of dynamic, scriptable websites in the early 2000s ‚Äî so major that it‚Äôs often referred to as the birth of <em>‚ÄúWeb 2.0‚Äù</em>.</p><p>However, while much of that dynamism is used to enable rich user experiences and powerful web applications, it does often come with a cost. As websites went from simple collections of hypertext files and stylesheets into increasingly sophisticated pieces of software ‚Äî they also, in general, became much heavier and slower to load.</p><p>Engineering is all about tradeoffs, and when building web experiences that need to be truly dynamic ‚Äî the tradeoff of having a website be slower to load in order to enable powerful features might be completely worth making. However, even websites that simply display text and images can sometimes take seconds to load and render ‚Äî even if they don‚Äôt (seemingly) include any form of dynamism whatsoever.</p><p>If dynamism is the good, slowness is the bad, then the modern web‚Äôs relentless user tracking is definitely the ugly. From user profiling, to invasive analytics libraries, to data harvesting ‚Äî big data gathering is everywhere, and the same dynamic code execution that‚Äôs used to enable those great user experiences is, sadly, often used for the exact opposite ‚Äî to track visitors, to display disruptive, animated banner ads and autoplaying videos, to interrupt users with growth hacking popups, and much more.</p><p class="info">I‚Äôm not saying that all ads are bad. In fact, this website is kept free and available to everyone thanks to <a href="https://www.swiftbysundell.com/ads">responsible advertising</a>, with referral links as the only means of tracking clicks.</p><p>When I set out to build this latest version of Swift by Sundell, I knew that I wanted to stay as far away from those ugly parts of the modern web as possible. So I started to ask myself: What could my website look like if I went the complete opposite direction ‚Äî if it didn‚Äôt include any form of dynamism, but still looked and felt like a modern web experience?</p><p>Basically, could I build a modern website more or less the same way as websites were built in the late 90s ‚Äî as static collections of HTML, CSS and image files?</p><h2>Back to basics</h2><p>I love a good engineering challenge. In fact, I think that one of the quickest ways to grow as an engineer is to constantly set up small little challenges while doing your daily work. Not only does that encourage you to learn new skills, and to <em>‚Äúthink outside of the box‚Äù</em> ‚Äî it also often improves the end result as well.</p><p><em>Would it be possible to make this algorithm more efficient, how could I simplify this view hierarchy, or what would this API look like if I refined it down to its simplest possible form?</em> Those are all examples of the types of questions that I love to ask myself while writing code on a daily basis, and ‚Äî perhaps even more importantly ‚Äî when starting a new project.</p><p>So, when I set out to build Swift by Sundell 2.0, I expanded that idea of building a website using a basic set of technologies into somewhat of a personal engineering challenge.</p><p>I had initially planned to use client-side JavaScript to implement all of my site‚Äôs interactive features ‚Äî things like theming, search, signing up for my newsletter, podcast audio playback, and more. To me, someone who hadn‚Äôt really done any serious web development for the past five or six years, it seemed like running JavaScript code client-side would be the only way to realistically implement those types of features.</p><p>However, as I kicked off pre-production ‚Äî with prototyping and research as my two main areas of focus ‚Äî I eventually realized that it might be possible to build everything that I wanted my site to include, without using <em>any client-side JavaScript at all</em>. That got me incredibly excited, as not only would that let me make my website blazingly fast (as each web browser could simply download HTML and CSS files from my server and render them directly), it would also let me show (both myself and others) that building a modern-looking, nice website doesn‚Äôt necessarily require any form of dynamic client-side code execution.</p><p>Just like the web itself, both HTML and CSS have evolved so much during the past decade. CSS can now do things like animations, light/dark mode theming, dynamically showing and hiding elements, and much more. HTML also features more built-in components and widgets than ever ‚Äî enabling websites to leverage functionality that‚Äôs built into every modern web browser, rather than having to ship their own JavaScript code that does more or less the exact same thing.</p><p>While using client-side JavaScript to render a website is still a completely valid option, the fact of the matter is, for some use cases ‚Äî it‚Äôs simply not <em>strictly required</em> anymore. Sure, you still might embed external web clips (for example YouTube videos) that execute JavaScript within their own <code>iframe</code>, or use JavaScript server-side, but it turns out that it‚Äôs perfectly possible to render a modern web UI without relying on any sort of client-side code execution.</p><h2>I don‚Äôt hate JavaScript</h2><p>So the reason Swift by Sundell doesn‚Äôt use any client-side JavaScript is not because I hate the language. In fact, making such technical decisions out of some form of spite would, in my opinion, be incredibly short-sighted. This site doesn‚Äôt use client-side code execution simply because I wanted to make it as fast as it possibly could be, because I wanted to get as far away from the slowness and creepiness of the modern web as I could, and because I wanted to set myself an engineering challenge.</p><p>I still use JavaScript for certain tools that are run offline, and for some of my server-side code (such as the backend logic that drives my search feature). I also occasionally embed external web pages (like YouTube and Vimeo videos) that use JavaScript. But I wanted to see if I could realize my vision for this website without using it myself on the client side.</p><p>At the end of the day, this whole thing is not about JavaScript as a language ‚Äî it‚Äôs about the concept of dynamic code execution on websites. Honestly, even if Swift somehow ends up becoming the new scripting language for the web, I‚Äôd still feel the exact same way. I don‚Äôt think every website needs to be a complex <em>‚Äúweb app‚Äù</em>. In fact, I think many websites would become better if they weren‚Äôt.</p><p>So there you have it. That‚Äôs why this website is 100% JavaScript-free, and I felt that it was important to include that fact on the site itself ‚Äî not just because I‚Äôm honestly quite proud of what I‚Äôve built, but also to provide a (in the grand scheme of things, tiny) counterweight to the modern trend of websites relying more and more on client-side JavaScript.</p><p>I don‚Äôt have any delusions of grandeur that my little footer text will change the web as we know it, nor do I claim that I invented this approach in any way ‚Äî but I thought that if I could provide an example of a somewhat complex website that isn‚Äôt rendered using JavaScript, then that could be an interesting point of discussion.</p><p>Now, does this mean that I‚Äôm encouraging other developers to take the same approach as me? Just like anything that‚Äôs remotely interesting to discuss within technology ‚Äî it depends.</p><p>Here‚Äôs what I suggest: If you‚Äôre starting a new website project today, think about what its goals are, and what type of user experience that you‚Äôre looking to provide. Will you exclusively be serving static content, with user interactions that could happen through browser navigation and page reloads? If so, perhaps building things using just HTML and CSS might be a way to go. But if that‚Äôs not the case, then there‚Äôs no shame in using JavaScript either. Use the tools needed to build the products you want to build, and the tools that you and your team prefer. That‚Äôs, at the end of the day, what matters the most.</p><p>Just because building a JavaScript-free website was my challenge to myself, doesn‚Äôt mean that it has to be yours. And if you prefer building websites using JavaScript, or any other language, then that‚Äôs of course fine too. All that matters is that we, collectively as an industry, constantly try to make our software the best, fastest, and most respectful of our users as it possibly can be.</p><p>Thanks for reading! üöÄ</p><p class="info">All of the core tools used to build this website are open source. Check out the <a href="https://github.com/johnsundell/publish">Publish static site generator</a> if you wish to learn more, and you‚Äôre of course more than welcome to contact me with your questions, comments and feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/73</guid><title>Podcast: ‚ÄúTruly a general-purpose language‚Äù, with special guest Kilo Loco</title><description>Kyle Lee, also known as Kilo Loco, joins John to go behind the scenes of Publish ‚Äî the static site generator used to build Swift by Sundell. Also, how to make a code base accessible to new team members, learning from open source, getting started with Swift-based web development, and much more.</description><link>https://www.swiftbysundell.com/podcast/73</link><pubDate>Tue, 19 May 2020 21:20:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell73.mp3" type="audio/mpeg"/></audio><p>Kyle Lee, also known as Kilo Loco, joins John to go behind the scenes of Publish ‚Äî the static site generator used to build Swift by Sundell. Also, how to make a code base accessible to new team members, learning from open source, getting started with Swift-based web development, and much more.</p><h2>Sponsors</h2><ul><li><strong><a href="https://www.goodnotes.com/careers">GoodNotes</a>:</strong> Apply to work on a popular, Apple-featured app, which makes great use of the latest iOS and macOS technologies. GoodNotes is hiring multiple iOS developers to join their team. Check out <a href="https://www.goodnotes.com/careers">goodnotes.com/careers</a> for more info.</li><li><strong><a href="https://instabug.com/sundell">Instabug</a>:</strong> Join thousands of companies, including Lyft and eBay, who use Instabug to enhance their app quality and iterate faster. It‚Äôs perfect for teams that are working remotely. Go to <a href="https://instabug.com/sundell">instabug.com/sundell</a> to start your 14-day free trial.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/kilo_loco">Kyle on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://www.youtube.com/kiloloco">Kilo Loco on YouTube</a></li><li><a href="https://www.youtube.com/watch?v=8IwUMfNpDQI">Kyle‚Äôs video about being hired by AWS</a></li><li><a href="https://youtu.be/JqdS-oi96Gk">Kyle‚Äôs video tutorial on how to get started with Publish</a></li><li><a href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a href="https://github.com/JohnSundell/Plot">Plot</a></li><li><a href="https://github.com/JohnSundell/Ink">Ink</a></li><li><a href="https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/Theme%2BFoundation.swift">The Publish Foundation theme</a></li><li><a href="https://www.swiftbysundell.com/articles/enum-iterations-in-swift-42/%23caseiterable">CaseIterable</a></li><li><a href="https://vapor.codes">Vapor</a></li><li><a href="https://workers.cloudflare.com">Cloudflare Workers</a></li><li><a href="https://www.w3schools.com">W3Schools</a></li><li><a href="https://developer.mozilla.org">The Mozilla Developer Network</a></li><li><a href="https://aws.amazon.com/amplify">AWS Amplify</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/avoiding-deeply-nested-swift-code</guid><title>Avoiding deeply nested Swift code</title><description>This week, let‚Äôs take a look at a few techniques that can help us make our code easier to read, test and maintain, by reducing the amount of indentation within it.</description><link>https://www.swiftbysundell.com/articles/avoiding-deeply-nested-swift-code</link><pubDate>Sun, 17 May 2020 21:15:00 +0200</pubDate><content:encoded><![CDATA[<p>Code style and structure are arguably two of the trickiest topics within programming in general. Not because they require any particular skills or vast experience building software, but because they‚Äôre so incredibly subjective in nature. What one person might consider the most readable and elegantly structured code in the world, another person might find cryptic and complicated.</p><p>However, there are a few techniques that can be employed to make the code that we write more generally accessible to other people (even if they might disagree with our particular choice of style). This week, let‚Äôs take a look at a few such techniques, that all have the same goal ‚Äî reducing the amount of indentation within our code.</p><h2>Early returns and code extraction</h2><p>Let‚Äôs start by taking a look at a relatively simple example of how using early returns within functions can have quite a big impact on the overall readability of our code ‚Äî even without any additional changes to the way our expressions are formed, or the way our APIs are designed.</p><p>As an example, let‚Äôs say that we‚Äôve extended a <code>DocumentLibraryViewController</code> with a short but useful method that filters an array of documents to only include ones that are unread and accessible by the current user:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DocumentLibraryViewController</span> {
    <span class="s-keyword">func</span> unreadDocuments(from list: [<span class="s-type">Document</span>]) -&gt; [<span class="s-type">Document</span>] {
        list.<span class="s-call">filter</span> { document <span class="s-keyword">in
            if</span> user.<span class="s-property">accessLevel</span> &gt;= document.<span class="s-property">requiredAccessLevel</span> {
                <span class="s-keyword">if</span> !user.<span class="s-property">readDocumentIDs</span>.<span class="s-call">contains</span>(document.<span class="s-property">id</span>) {
                    <span class="s-keyword">if</span> document.<span class="s-property">expirationDate</span> &gt; <span class="s-type">Date</span>() {
                        <span class="s-keyword">return true</span>
                    }
                }
            }
    
            <span class="s-keyword">return false</span>
        }
    }
}</code></pre><p>While the above code works as intended, the fact that it‚Äôs quite heavily indented arguably makes it more difficult to <em>‚Äúmentally parse‚Äù</em> than it has to be. So let‚Äôs see if we can fix that by using Swift‚Äôs <code>guard</code> statement to instead exit out of our method as early as possible ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DocumentLibraryViewController</span> {
    <span class="s-keyword">func</span> unreadDocuments(from list: [<span class="s-type">Document</span>]) -&gt; [<span class="s-type">Document</span>] {
        list.<span class="s-call">filter</span> { document <span class="s-keyword">in
            guard</span> user.<span class="s-property">accessLevel</span> &gt;= document.<span class="s-property">requiredAccessLevel</span> <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }
    
            <span class="s-keyword">guard</span> !user.<span class="s-property">readDocumentIDs</span>.<span class="s-call">contains</span>(document.<span class="s-property">id</span>) <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }
    
            <span class="s-keyword">return</span> document.<span class="s-property">expirationDate</span> &gt; date
        }
    }
}</code></pre><p>Although our logic remains exactly the same, it‚Äôs now a bit easier to quickly get an overview of what our function‚Äôs actual conditions are ‚Äî as they‚Äôre now listed from top to bottom at the same level of indentation.</p><p>Apart from making our code easier to read and understand for others, one major benefit of doing the above kind of restructuring is that it often lets us discover new ways in which we could improve the overall structure of our code even further.</p><p>For example, since two of our function‚Äôs three conditions operate on a <code>Document</code> instance, we could move those conditions into a separate extension instead ‚Äî which not only makes it easier for that code to be read and tested in isolation, it also enables us to reuse it within other parts of our code base as well:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Document</span> {
    <span class="s-keyword">func</span> isAccessible(for user: <span class="s-type">User</span>, date: <span class="s-type">Date</span> = .<span class="s-keyword">init</span>()) -&gt; <span class="s-type">Bool</span> {
        <span class="s-keyword">guard</span> user.<span class="s-property">accessLevel</span> &gt;= requiredAccessLevel <span class="s-keyword">else</span> {
            <span class="s-keyword">return false</span>
        }

        <span class="s-keyword">return</span> expirationDate &gt; date
    }
}</code></pre><p class="info">Note how we now also inject the current <code>Date</code>, rather than creating it inline, which further improves the testability of our code (for example through <a href="https://www.swiftbysundell.com/articles/time-traveling-in-swift-unit-tests/">‚Äútime traveling‚Äù</a>).</p><p>Along the same lines, since our main <code>unreadDocuments(from:)</code> method is directly operating on an array of documents ‚Äî and only requires a <code>User</code> instance and the current <code>Date</code> apart from that ‚Äî we could also choose to extract it out from our <code>DocumentLibraryViewController</code>, and instead implement it within an extension on any <code>Sequence</code> that contains <code>Document</code> elements, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Sequence</span> <span class="s-keyword">where</span> <span class="s-type">Element</span> == <span class="s-type">Document</span> {
    <span class="s-keyword">func</span> unread(for user: <span class="s-type">User</span>, date: <span class="s-type">Date</span> = .<span class="s-keyword">init</span>()) -&gt; [<span class="s-type">Document</span>] {
        <span class="s-call">filter</span> { document <span class="s-keyword">in
            guard</span> document.<span class="s-call">isAccessible</span>(for: user, date: date) <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }

            <span class="s-keyword">return</span> !user.<span class="s-property">readDocumentIDs</span>.<span class="s-call">contains</span>(document.<span class="s-property">id</span>)
        }
    }
}</code></pre><p class="info"><a href="https://www.swiftbysundell.com/basics/unit-testing">Unit testing</a> the above API is now simply a matter of creating a collection of <code>Document</code> values, along with a <code>User</code> instance and a date according to what part of our logic that we wish to test, and then verifying that our method returns an array of correctly filtered documents.</p><p>With the above tweaks in place, we‚Äôve now not only modeled our logic as separate functions that can be independently used and tested, we‚Äôve also made our call sites read really nicely as well:</p><pre class="splash"><code><span class="s-keyword">let</span> unreadDocuments = allDocuments.<span class="s-call">unread</span>(for: user)</code></pre><p>While we ended up doing much more than <em>just</em> reducing the amount of indentation above, it all started when we decided to do something about a heavily indented piece of code. That‚Äôs the magic of refactoring ‚Äî in that revising an implementation in order to simplify it often reveals brand new venues for improvement as well.</p><h2>Untangling nested logic branches</h2><p>However, not all logic can be modeled as a simple sequence of boolean conditions ‚Äî sometimes we need to handle a much larger amount of states and permutations, which in turn might require us to branch our logic into several nested <code>if</code> and <code>else</code> statements.</p><p>For example, here we‚Äôre working on a <code>ProductViewController</code> that uses a private <code>update</code> method to populate its views once it received a new <code>Product</code> model. Since the overall state that our UI will end up in depends on a number of factors ‚Äî such as whether a user is currently logged in, if there are any discounts available, and so on ‚Äî we‚Äôve currently ended up with a quite lengthly, nested implementation that looks like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> sessionController: <span class="s-type">SessionController</span>
    <span class="s-keyword">private lazy var</span> descriptionLabel = <span class="s-type">UILabel</span>()
    <span class="s-keyword">private lazy var</span> favoriteButton = <span class="s-type">UIButton</span>()
    <span class="s-keyword">private lazy var</span> priceView = <span class="s-type">PriceView</span>()
    <span class="s-keyword">private lazy var</span> buyButton = <span class="s-type">UIButton</span>()
    
    ...

    <span class="s-keyword">private func</span> update(with product: <span class="s-type">Product</span>) {
        <span class="s-keyword">if let</span> user = sessionController.<span class="s-property">loggedInUser</span> {
            <span class="s-keyword">if let</span> discount = product.<span class="s-call">discount</span>(in: user.<span class="s-property">region</span>) {
                <span class="s-keyword">let</span> lowerPrice = product.<span class="s-property">price</span> - discount
                priceView.<span class="s-property">amountLabel</span>.<span class="s-property">text</span> = <span class="s-type">String</span>(lowerPrice)
                priceView.<span class="s-property">discountLabel</span>.<span class="s-property">text</span> = <span class="s-type">String</span>(discount)
            } <span class="s-keyword">else</span> {
                priceView.<span class="s-property">amountLabel</span>.<span class="s-property">text</span> = <span class="s-type">String</span>(product.<span class="s-property">price</span>)
                priceView.<span class="s-property">discountLabel</span>.<span class="s-property">text</span> = <span class="s-string">""</span>
            }

            <span class="s-keyword">if</span> user.<span class="s-property">favoriteProductIDs</span>.<span class="s-call">contains</span>(product.<span class="s-property">id</span>) {
                favoriteButton.<span class="s-call">setTitle</span>(<span class="s-string">"Remove from favorites"</span>,
                    for: .<span class="s-dotAccess">normal</span>
                )
            } <span class="s-keyword">else</span> {
                favoriteButton.<span class="s-call">setTitle</span>(<span class="s-string">"Add to favorites"</span>,
                    for: .<span class="s-dotAccess">normal</span>
                )
            }

            favoriteButton.<span class="s-property">isHidden</span> = <span class="s-keyword">false</span>
        } <span class="s-keyword">else</span> {
            favoriteButton.<span class="s-property">isHidden</span> = <span class="s-keyword">true</span>
            priceView.<span class="s-property">amountLabel</span>.<span class="s-property">text</span> = <span class="s-type">String</span>(product.<span class="s-property">price</span>)
            priceView.<span class="s-property">discountLabel</span>.<span class="s-property">text</span> = <span class="s-string">""</span>
        }

        priceView.<span class="s-property">currencyLabel</span>.<span class="s-property">text</span> = product.<span class="s-property">currency</span>.<span class="s-property">symbol</span>
        descriptionLabel.<span class="s-property">text</span> = product.<span class="s-property">description</span>
    }
}</code></pre><p>At first glance, it might seem like the above is the best that we can do given the number of conditions and separate states that we need to handle ‚Äî but, just like earlier, once we start breaking our implementation apart into separate pieces, we‚Äôll likely discover new approaches that we could take.</p><p>To get started, let‚Äôs move all of our product-bound logic into a private extension on <code>Product</code> instead. That way, we can perform those computations in isolation, and simply return values that represent the current state that our app is in ‚Äî like this:</p><pre class="splash"><code><span class="s-comment">// By keeping this extension private, we're able to implement
// logic that's specific to our product view within it:</span>
<span class="s-keyword">private extension</span> <span class="s-type">Product</span> {
    <span class="s-keyword">typealias</span> PriceInfo = (price: <span class="s-type">Double</span>, discount: <span class="s-type">Double</span>)

    <span class="s-keyword">func</span> priceInfo(in region: <span class="s-type">Region</span>?) -&gt; <span class="s-type">PriceInfo</span> {
        <span class="s-keyword">guard let</span> discount = region.<span class="s-call">flatMap</span>(discount) <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> (price, <span class="s-number">0</span>)
        }

        <span class="s-keyword">return</span> (price - discount, discount)
    }

    <span class="s-keyword">func</span> favoriteButtonTitle(for user: <span class="s-type">User</span>) -&gt; <span class="s-type">String</span> {
        <span class="s-keyword">if</span> user.<span class="s-property">favoriteProductIDs</span>.<span class="s-call">contains</span>(id) {
            <span class="s-keyword">return</span> <span class="s-string">"Remove from favorites"</span>
        } <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> <span class="s-string">"Add to favorites"</span>
        }
    }
}</code></pre><p class="info">The above <code>ProductInfo</code> type is implemented as a tuple, which provide a great way to <a href="https://www.swiftbysundell.com/articles/using-tuples-as-lightweight-types-in-swift">create lightweight types in Swift</a>.</p><p>Next, let‚Äôs encapsulate all of our <em>view state computation</em> within a dedicated type. We‚Äôll call it <code>ProductViewState</code>, given that its only purpose will be to represent the current state of our product view in a read-only fashion. We‚Äôll initialize it with a <code>Product</code> and an optional <code>User</code>, and will then compute our view‚Äôs current state using the private <code>Product</code> APIs that we just implemented:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductViewState {
    <span class="s-comment">// By making all of our properties constants, the compiler
    // will generate an error if we forget to assign a value to
    // one of them (including those that are optionals):</span>
    <span class="s-keyword">let</span> priceText: <span class="s-type">String</span>
    <span class="s-keyword">let</span> discountText: <span class="s-type">String</span>
    <span class="s-keyword">let</span> currencyText: <span class="s-type">String</span>
    <span class="s-keyword">let</span> favoriteButtonTitle: <span class="s-type">String</span>?
    <span class="s-keyword">let</span> description: <span class="s-type">String</span>

    <span class="s-keyword">init</span>(product: <span class="s-type">Product</span>, user: <span class="s-type">User</span>?) {
        <span class="s-keyword">let</span> priceInfo = product.<span class="s-call">priceInfo</span>(in: user?.<span class="s-property">region</span>)
        priceText = <span class="s-type">String</span>(priceInfo.<span class="s-property">price</span>)
        discountText = priceInfo.<span class="s-property">discount</span> &gt; <span class="s-number">0</span> ? <span class="s-type">String</span>(priceInfo.<span class="s-property">discount</span>) : <span class="s-string">""</span>
        currencyText = product.<span class="s-property">currency</span>.<span class="s-property">symbol</span>
        favoriteButtonTitle = user.<span class="s-call">map</span>(product.<span class="s-property">favoriteButtonTitle</span>) ?? <span class="s-string">""</span>
        description = product.<span class="s-property">description</span>
    }
}</code></pre><p class="info">We could‚Äôve also modeled the above type as a <a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift/%23read-only-structs">read-only view model</a>, by calling it <code>ProductViewModel</code> instead.</p><p>With the above two pieces in place, we can now go back to our view controller‚Äôs <code>update</code> method and <em>heavily</em> simplify it. Gone are all the nested <code>if</code> and <code>else</code> statements, and we no longer have any duplicate assignments to the same property. Plus, our implementation can now easily be read from top to bottom, since we‚Äôve extracted all of the decision-making conditions into separate, smaller functions:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">private func</span> update(with product: <span class="s-type">Product</span>) {
        <span class="s-keyword">let</span> state = <span class="s-type">ProductViewState</span>(
            product: product,
            user: sessionController.<span class="s-property">loggedInUser</span>
        )

        priceView.<span class="s-property">amountLabel</span>.<span class="s-property">text</span> = state.<span class="s-property">priceText</span>
        priceView.<span class="s-property">discountLabel</span>.<span class="s-property">text</span> = state.<span class="s-property">discountText</span>
        priceView.<span class="s-property">currencyLabel</span>.<span class="s-property">text</span> = state.<span class="s-property">currencyText</span>

        favoriteButton.<span class="s-call">setTitle</span>(state.<span class="s-property">favoriteButtonTitle</span>, for: .<span class="s-dotAccess">normal</span>)
        favoriteButton.<span class="s-property">isHidden</span> = (state.<span class="s-property">favoriteButtonTitle</span> == <span class="s-keyword">nil</span>)

        descriptionLabel.<span class="s-property">text</span> = state.<span class="s-property">description</span>
    }
}</code></pre><p>Just like when we previously extracted our <code>Document</code>-related methods into separate APIs, a big benefit of the above kind of refactoring is that it makes unit testing so much simpler ‚Äî as all of our logic is now structured as <a href="https://www.swiftbysundell.com/articles/pure-functions-in-swift">pure functions</a> that can be individually developed and tested.</p><h2>SwiftUI views</h2><p>Finally, let‚Äôs take a look at how we can employ some of the same techniques that we used above when constructing views using SwiftUI.</p><p>Since <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">SwiftUI‚Äôs DSL</a> uses closures to encapsulate the construction of our various views, it‚Äôs quite easy to end up with an implementation that‚Äôs heavily indented, even when building a relatively simple list view ‚Äî such as this one:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventListView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> manager: <span class="s-type">EventManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(manager.<span class="s-property">upcomingEvents</span>) { event <span class="s-keyword">in</span>
                <span class="s-type">NavigationLink</span>(
                    destination: <span class="s-type">EventView</span>(event: event),
                    label: {
                        <span class="s-type">HStack</span> {
                            <span class="s-type">Image</span>(event.<span class="s-property">iconName</span>)
                            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                                <span class="s-type">Text</span>(event.<span class="s-property">title</span>)
                                <span class="s-type">Text</span>(event.<span class="s-property">location</span>.<span class="s-property">name</span>)
                            }
                        }
                    }
                )
            }
            .<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Upcoming events"</span>)
        }
    }
}</code></pre><p>Although it might seem like the above kind of <em>‚Äúcode pyramid‚Äù</em> is inevitable when working with nested SwiftUI views, there are once again a number of ways that we could heavily flatten (and simplify) our code in this case.</p><p>Just like how we previously extracted parts of our various logic into separate types and functions, we can do the same thing here as well ‚Äî for example by creating a dedicated type for rendering the rows that appear within the above list. Since SwiftUI views are just lightweight descriptions of our UI, that can most often be done by simply moving the code in question into a new <code>View</code>-conforming type ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventListRow: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> event: <span class="s-type">Event</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(event.<span class="s-property">iconName</span>)
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(event.<span class="s-property">title</span>)
                <span class="s-type">Text</span>(event.<span class="s-property">location</span>.<span class="s-property">name</span>)
            }
        }
    }
}</code></pre><p>Apart from creating stand-alone view types, using private factory methods can also be a great way to split a SwiftUI view up into separate pieces. For example, here‚Äôs how we could define a method that wraps an instance of our new <code>EventListRow</code> type within a <code>NavigationLink</code>, making it ready to be displayed within our list:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">EventListView</span> {
    <span class="s-keyword">func</span> makeRow(for event: <span class="s-type">Event</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationLink</span>(
            destination: <span class="s-type">EventView</span>(event: event),
            label: {
                <span class="s-type">EventListRow</span>(event: event)
            }
        )
    }
}</code></pre><p>The cool thing is that, with just the above two tweaks in place, we can now remove almost all of the indentation from our <code>EventListView</code> ‚Äî by passing the above <code>makeRow</code> method as a <a href="https://www.swiftbysundell.com/clips/1">first class function</a> when creating our <code>List</code>, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventListView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> manager: <span class="s-type">EventManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(manager.<span class="s-property">upcomingEvents</span>, rowContent: makeRow)
                .<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Upcoming events"</span>)
        }
    }
}</code></pre><p>While always removing all sources of indentation is hardly a good goal to have ‚Äî as the right amount of indentation can also help us <em>improve</em> the readability of a given type or function ‚Äî it‚Äôs interesting to see just how much flexibility Swift gives us in terms of code structure, which in turn lets us adapt our choice of structure within each given situation.</p><h2>Conclusion</h2><p>Although it might seem like a heavy amount of indentation is inevitable within certain parts of a code base, that‚Äôs actually rarely the case ‚Äî as there are often multiple approaches that we can take to structure our logic in ways that not only reduces the amount of indentation needed, but also makes the overall flow of our logic easier to follow.</p><p>Once we start untangling a piece of heavily indented code, it‚Äôs also likely that we‚Äôll discover new ways to structure, reuse and test that code as well ‚Äî which can make refactoring a very natural and neat way to come up with shared abstractions, and to improve the overall testability of a code base.</p><p>But again, not all indentation deserves to be removed, but hopefully this article has given you some insights into how I approach these kinds of refactoring and maintenance tasks. Feel free to let me know what you think ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/loca-studio-may-2020</guid><title>Sponsor: Loca Studio</title><description>Thanks a lot to Loca Studio for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/loca-studio-may-2020</link><pubDate>Thu, 14 May 2020 19:50:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to the team behind <a href="https://www.cunningo.com/locastudio/index.html?campaign=swiftbysundell-202005">Loca Studio</a>, a fantastic app for managing Xcode‚Äôs localization files, for sponsoring Swift by Sundell this week. Their support helps me keep the website, and this RSS feed, free and open to everyone.</p><p>Loca Studio is a fast, native Mac app that can help you detect common mistakes within your localization files, help you find the right format strings to use, and much more. As an example, Loca Studio will validate strings referring to system features (such as the name of the Settings app, or other operating system terms), and will warn you if any of your app‚Äôs translations seem incorrect.</p><p>It also includes features for merging localized strings, for previewing what a formatted string will look like in various locales and languages, and much more.</p><p><a href="https://www.cunningo.com/locastudio/index.html?campaign=swiftbysundell-202005">Try Loca Studio for free</a>, which also helps support Swift by Sundell.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/building-an-observable-type-for-swiftui-views</guid><title>Tip: Building an Observable type for SwiftUI views</title><description></description><link>https://www.swiftbysundell.com/tips/building-an-observable-type-for-swiftui-views</link><pubDate>Thu, 14 May 2020 15:00:00 +0200</pubDate><content:encoded><![CDATA[<p>SwiftUI ships with a number of tools for connecting a view to a piece of state, which in turn makes the framework automatically re-render that view whenever its state was modified.</p><p>For example, the <code>@State</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a> can be used to keep track of a view‚Äôs internal, local state ‚Äî while <code>@Binding</code> enables us to pass mutable state between different views. There‚Äôs also <code>@ObservedObject</code>, which along with its <code>ObservableObject</code> protocol counterpart, enables us to construct custom objects that our views can then observe.</p><p>Here‚Äôs how we might implement a <a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift">view model</a> as such an observed object, which uses a <a href="https://www.swiftbysundell.com/basics/combine">Combine publisher</a> to subscribe to changes in its underlying data model ‚Äî in this case a <code>Podcast</code> type:</p><pre class="splash"><code><span class="s-keyword">class</span> PodcastViewModel: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">@Published private(set) var</span> podcast: <span class="s-type">Podcast</span>
    <span class="s-keyword">private var</span> cancellable: <span class="s-type">AnyCancellable</span>?

    <span class="s-keyword">init</span>&lt;T: <span class="s-type">Publisher</span>&gt;(
        podcast: <span class="s-type">Podcast</span>,
        publisher: <span class="s-type">T</span>
    ) <span class="s-keyword">where</span> <span class="s-type">T</span>.<span class="s-type">Output</span> == <span class="s-type">Podcast</span>, <span class="s-type">T</span>.<span class="s-type">Failure</span> == <span class="s-type">Never</span> {
        <span class="s-keyword">self</span>.<span class="s-property">podcast</span> = podcast
        <span class="s-keyword">self</span>.<span class="s-property">cancellable</span> = publisher.<span class="s-call">assign</span>(to: \.<span class="s-property">podcast</span>, on: <span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">To learn more about the <code>@Published</code> property wrapper used above, check out <a href="https://www.swiftbysundell.com/articles/published-properties-in-swift">‚ÄúPublished properties in Swift‚Äù</a>.</p><p>We could then build a corresponding <code>PodcastView</code> that uses the above <code>PodcastViewModel</code> as its data source, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> PodcastView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">PodcastViewModel</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(uiImage: viewModel.<span class="s-property">podcast</span>.<span class="s-property">image</span>)
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(viewModel.<span class="s-property">podcast</span>.<span class="s-property">name</span>)
                    .<span class="s-call">bold</span>()
                <span class="s-type">Text</span>(viewModel.<span class="s-property">podcast</span>.<span class="s-property">creator</span>)
                    .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
            }
        }
    }
}</code></pre><p>While view models can be incredibly useful in order to encapsulate the logic required to bridge the gap between a view and its data model (while also enforcing some separation of concerns between those two layers), in the above case, our view model simply acts as an <em>observable wrapper</em> for our <code>Podcast</code> model ‚Äî which in turn requires us to always access that model using <code>viewModel.podcast</code>.</p><p>Since there‚Äôs really nothing <code>Podcast</code> model-specific about our view model implementation ‚Äî let‚Äôs see if we can generalize it instead, and in doing so, make it easier to use as well. To do that, let‚Äôs rename it to <code>Observable</code>, and make it a generic over any <code>Value</code> ‚Äî with one important addition: we‚Äôll also make it support <em><a href="https://www.swiftbysundell.com/tips/combining-dynamic-member-lookup-with-key-paths">dynamic member lookup</a></em>, like this:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
final class</span> Observable&lt;Value&gt;: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">@Published private(set) var</span> value: <span class="s-type">Value</span>
    <span class="s-keyword">private var</span> cancellable: <span class="s-type">AnyCancellable</span>?

    <span class="s-keyword">init</span>&lt;T: <span class="s-type">Publisher</span>&gt;(
        value: <span class="s-type">Value</span>,
        publisher: <span class="s-type">T</span>
    ) <span class="s-keyword">where</span> <span class="s-type">T</span>.<span class="s-type">Output</span> == <span class="s-type">Value</span>, <span class="s-type">T</span>.<span class="s-type">Failure</span> == <span class="s-type">Never</span> {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
        <span class="s-keyword">self</span>.<span class="s-property">cancellable</span> = publisher.<span class="s-call">assign</span>(to: \.<span class="s-property">value</span>, on: <span class="s-keyword">self</span>)
    }

    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        value[keyPath: keyPath]
    }
}</code></pre><p>The big benefit of the above approach (apart from the fact that we now have a completely reusable type that can be used to observe <em>any model</em>) is that we can now access each of our <code>Podcast</code> model properties <em>directly</em>, thanks to <code>@dynamicMemberLookup</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> PodcastView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> podcast: <span class="s-type">Observable</span>&lt;<span class="s-type">Podcast</span>&gt;

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(uiImage: podcast.<span class="s-property">image</span>)
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(podcast.<span class="s-property">name</span>)
                    .<span class="s-call">bold</span>()
                <span class="s-type">Text</span>(podcast.<span class="s-property">creator</span>)
                    .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
            }
        }
    }
}</code></pre><p>Much nicer! Now, time for the bonus round. Since our new <code>Observable</code> type is very similar to Combine‚Äôs built-in <code>CurrentValueSubject</code> (in that it keeps track of the latest emitted value), let‚Äôs also create a convenience API that‚Äôll let us easily convert any such subject into an <code>Observable</code> object:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">CurrentValueSubject</span> <span class="s-keyword">where</span> <span class="s-type">Failure</span> == <span class="s-type">Never</span> {
    <span class="s-keyword">func</span> asObservable() -&gt; <span class="s-type">Observable</span>&lt;<span class="s-type">Output</span>&gt; {
        <span class="s-type">Observable</span>(value: value, publisher: <span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">Note that a key difference between our <code>Observable</code> and Combine‚Äôs <code>CurrentValueSubject</code> is that the latter is mutable, which might not be something that we want to expose to certain parts of our view layer.</p><p>With the above in place, we can now easily create instances of our <code>PodcastView</code> from a <code>CurrentValueSubject</code> that emits new values whenever the podcast in question was updated:</p><pre class="splash"><code><span class="s-keyword">func</span> makePodcastView(
    with subject: <span class="s-type">CurrentValueSubject</span>&lt;<span class="s-type">Podcast</span>, <span class="s-type">Never</span>&gt;
) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
    <span class="s-type">PodcastView</span>(podcast: subject.<span class="s-call">asObservable</span>())
}</code></pre><p>While there are several other approaches can be used to update SwiftUI views whenever their models change (including using the built-in <code>.onReceive</code> view modifier to let a view subscribe to a Combine publisher directly), I feel like the above kind of <code>Observable</code> type provides a really neat way to let a view subscribe to a single model in a read-only fashion, without requiring that view to contain any form of subscription logic.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-test-assertion-messages-as-comments</guid><title>Tip: Using test assertion messages as comments</title><description></description><link>https://www.swiftbysundell.com/tips/using-test-assertion-messages-as-comments</link><pubDate>Tue, 12 May 2020 18:55:00 +0200</pubDate><content:encoded><![CDATA[<p>Often when writing tests, we might want to add some additional information to our code ‚Äî for example in order to explain why a certain operation is being performed, to give debugging hints in case of a future failure, or to make the code easier to follow.</p><p>One way to do that is of course to use good old fashioned comments ‚Äî like in the following test, which verifies that we‚Äôre able to add and then remove an item from a <code>TodoList</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> TodoListTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testAddingAndRemovingItem() {
        <span class="s-comment">// First, add an item and make sure that it's added</span>
        <span class="s-keyword">var</span> list = <span class="s-type">TodoList</span>()
        <span class="s-keyword">let</span> item = list.<span class="s-call">addItem</span>(named: <span class="s-string">"My item"</span>)
        <span class="s-call">XCTAssertTrue</span>(list.<span class="s-call">containsItem</span>(named: item.<span class="s-property">name</span>))

        <span class="s-comment">// Then, remove the item and make sure that it was removed</span>
        list.<span class="s-call">removeItem</span>(item)
        <span class="s-call">XCTAssertFalse</span>(list.<span class="s-call">containsItem</span>(named: item.<span class="s-property">name</span>))
    }
}</code></pre><p>There‚Äôs certainly nothing wrong with the above approach, but like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code">‚ÄúWriting self-documenting Swift code‚Äù</a></em>, if we can find ways to let our code <em>explain itself</em>, then that can often remove much of the need for the above kind of contextual comments.</p><p>One way to do that within our testing code is to make use of the fact that we can pass custom messages to each of XCTest‚Äôs various assertion functions. That way, we can convert our comments into messages that are directly attached to our verification code ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> TodoListTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testAddingAndRemovingItem() {
        <span class="s-keyword">var</span> list = <span class="s-type">TodoList</span>()
        <span class="s-keyword">let</span> item = list.<span class="s-call">addItem</span>(named: <span class="s-string">"My item"</span>)
        
        <span class="s-call">XCTAssertTrue</span>(
            list.<span class="s-call">containsItem</span>(named: item.<span class="s-property">name</span>),
            <span class="s-string">"A TodoList should contain an item that was added"</span>
        )

        list.<span class="s-call">removeItem</span>(item)
        
        <span class="s-call">XCTAssertFalse</span>(
            list.<span class="s-call">containsItem</span>(named: item.<span class="s-property">name</span>),
            <span class="s-string">"Item should have been removed after calling 'removeItem()'"</span>
        )
    }
}</code></pre><p>The major benefit of the above approach is that not only will our messages still be fully readable within our source code ‚Äî they‚Äôll also be displayed within our logs when an assertion failed, which often makes it much easier to identify and debug test failures when using <a href="https://www.swiftbysundell.com/articles/adding-continuous-integration-to-a-swift-project">continuous integration</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/propagating-user-facing-errors-in-swift</guid><title>Propagating user-facing errors in Swift</title><description>Let‚Äôs take a look at a few techniques that can make it much simpler to propagate runtime errors to our users, and how employing some of those techniques could help us present richer error messages without having to add a ton of complexity within each UI implementation.</description><link>https://www.swiftbysundell.com/articles/propagating-user-facing-errors-in-swift</link><pubDate>Sun, 10 May 2020 20:25:00 +0200</pubDate><content:encoded><![CDATA[<p>If it‚Äôs one thing that almost all programs have in common is that they will, at some point, encounter some form of error. While some errors might be the result of bugs and failures caused by faulty code, incorrect assumptions, or system incompatibilities ‚Äî there are also multiple kinds of errors that are completely normal, valid parts of a program‚Äôs execution.</p><p>One challenge with such errors is how to propagate and present them to the user, which can be really tricky, even if we disregard tasks like crafting informative and actionable error messages. It‚Äôs so incredibly common to see apps either display a generic <em>‚ÄùAn error occurred‚Äù</em> message regardless of what kind of error that was encountered, or throw walls of highly technical debugging text at the user ‚Äî neither of which is a great user experience.</p><p>So this week, let‚Äôs take a look at a few techniques that can make it much simpler to propagate runtime errors to our users, and how employing some of those techniques could help us present richer error messages without having to add a ton of complexity within each UI implementation.</p><h2>An evolution from simple to complex</h2><p>When starting to build a new app feature, it‚Äôs arguably a good idea to start out as simple as possible ‚Äî which typically helps us avoid <em>premature optimization</em>, by enabling us to discover the most appropriate structure and abstractions as we iterate on our code.</p><p>When it comes to error propagation, such a simple implementation might look like the following example ‚Äî in which we attempt to load a list of conversations within some form of messaging app, and then pass any error that was encountered into a private <code>handle</code> method:</p><pre class="splash"><code><span class="s-keyword">class</span> ConversationListViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> loader: <span class="s-type">ConversationLoader</span>
    
    ...

    <span class="s-keyword">private func</span> loadConversations() {
        <span class="s-comment">// Load our list of converstions, and then either render
        // our results, or handle any error that was encountered:</span>
        loader.<span class="s-call">loadConversations</span> { [<span class="s-keyword">weak self</span>] result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> conversations):
                <span class="s-keyword">self</span>?.<span class="s-call">render</span>(conversations)
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-keyword">self</span>?.<span class="s-call">handle</span>(error)
            }
        }
    }
}</code></pre><p>Our <code>handle</code> method might then, for example, create a <code>UIAlertController</code> in order to render the passed error‚Äôs <code>localizedDescription</code> to the user, along with a <em>‚ÄùRetry‚Äù</em> button ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">ConversationListViewController</span> {
    <span class="s-keyword">func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>) {
        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"An error occured"</span>,
            message: error.<span class="s-property">localizedDescription</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )
        
        alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
            title: <span class="s-string">"Dismiss"</span>,
            style: .<span class="s-dotAccess">default</span>
        ))

        alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
            title: <span class="s-string">"Retry"</span>,
            style: .<span class="s-dotAccess">default</span>,
            handler: { [<span class="s-keyword">weak self</span>] <span class="s-keyword">_ in
                self</span>?.<span class="s-call">loadConversations</span>()
            }
        ))

        <span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>While the above approach (or something like it, such as using a custom error <a href="https://www.swiftbysundell.com/articles/using-child-view-controllers-as-plugins-in-swift">child view controller</a>, rather than an alert view) is incredibly common, it does come with a few significant drawbacks.</p><p>First of all, since we‚Äôre directly rendering any error that was encountered while loading our list of models, chances are high that we‚Äôll end up displaying code-level implementation details to the user ‚Äî which isn‚Äôt great ‚Äî and secondly, we‚Äôre always showing a <em>‚ÄúRetry‚Äù</em> button, regardless of whether retrying the operation will realistically yield a different result.</p><p>To address those two issues, we might try to make our errors a bit more granular and well-defined, for example by introducing a dedicated <code>NetworkingError</code> enum that we make sure has proper localized messages for each case:</p><pre class="splash"><code><span class="s-keyword">enum</span> NetworkingError: <span class="s-type">LocalizedError</span> {
    <span class="s-keyword">case</span> deviceIsOffline
    <span class="s-keyword">case</span> unauthorized
    <span class="s-keyword">case</span> resourceNotFound
    <span class="s-keyword">case</span> serverError(<span class="s-type">Error</span>)
    <span class="s-keyword">case</span> missingData
    <span class="s-keyword">case</span> decodingFailed(<span class="s-type">Error</span>)
}</code></pre><p>If we then go back and retrofit our <code>ConversationLoader</code> with support for our new error enum, we‚Äôll end up with a much more <a href="https://www.swiftbysundell.com/articles/providing-a-unified-swift-error-api">unified error API</a> that our various UI components will be able to use to handle errors in a more precise manner:</p><pre class="splash"><code><span class="s-keyword">class</span> ConversationLoader {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;[<span class="s-type">Conversation</span>], <span class="s-type">NetworkingError</span>&gt;) -&gt; <span class="s-type">Void</span>
    
    ...

    <span class="s-keyword">func</span> loadConverstions(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        ...
    }
}</code></pre><p>However, performing error handling in a <em>‚Äùprecise manner‚Äù</em> is easier said than done, and often leads to a ton of complicated code that needs to be specifically written for each feature or use case ‚Äî since each part of our code base is likely to use a slightly different set of errors.</p><p>As an example, here‚Äôs how complex our previous <code>handle</code> method now has become, once we‚Äôve started customizing the way we present our errors depending on what type of error that was encountered:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">ConversationListViewController</span> {
    <span class="s-keyword">func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">NetworkingError</span>) {
        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"An error occured"</span>,
            message: error.<span class="s-property">localizedDescription</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )
        
        alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
            title: <span class="s-string">"Dismiss"</span>,
            style: .<span class="s-dotAccess">default</span>
        ))

        <span class="s-comment">// Here we take different actions depending on the error
        // that was encontered. We've decided that only some
        // errors warrant a "Retry" button, while an "unauthorized"
        // error should redirect the user to the login screen,
        // since their login session has most likely expired:</span>
        <span class="s-keyword">switch</span> error {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">deviceIsOffline</span>, .<span class="s-dotAccess">serverError</span>:
            alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
                title: <span class="s-string">"Retry"</span>,
                style: .<span class="s-dotAccess">default</span>,
                handler: { [<span class="s-keyword">weak self</span>] <span class="s-keyword">_ in
                    self</span>?.<span class="s-call">loadConversations</span>()
                }
            ))
        <span class="s-keyword">case</span> .<span class="s-dotAccess">resourceNotFound</span>, .<span class="s-dotAccess">missingData</span>, .<span class="s-dotAccess">decodingFailed</span>
            <span class="s-keyword">break
        case</span> .<span class="s-dotAccess">unauthorized</span>:
            <span class="s-keyword">return</span> navigator.<span class="s-call">logOut</span>()
        }

        <span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>While the above will most likely lead to an improved user experience ‚Äî since we‚Äôre now tailoring the presentation of each error according to what the user can reasonably do about it ‚Äî maintaining that sort of complexity within each feature isn‚Äôt going to be fun, so let‚Äôs see if we can find a better solution.</p><h2>Using the power of the responder chain</h2><p>If we remain within the realm of UIKit for now, one way to improve the way that UI-related errors are propagated within an app is to make use of the <em>responder chain</em>.</p><p>The responder chain is a system that both UIKit and AppKit have in common (although its implementation does differ between the two frameworks), and is how all sorts of system events ‚Äî from touches, to keyboard events, to input focus ‚Äî are handled. Any <code>UIResponder</code> subclass (such as <code>UIView</code> and <code>UIViewController</code>) can participate in the responder chain, and the system will automatically add all of our views and view controllers to it as soon as they‚Äôre added to our view hierarchy.</p><p>On iOS, the responder chain starts at the app‚Äôs <code>AppDelegate</code>, and goes all the way through our view hierarchy until it reaches our topmost views ‚Äî which means that it is, in many ways, an ideal tool to use for tasks like propagation.</p><p>So let‚Äôs take a look at how we could move our error handling and propagation code to the responder chain ‚Äî by first extending <code>UIResponder</code> with a method that, by default, moves any error that we send to it upwards through the chain using the built-in <code>next</code> property:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIResponder</span> {
    <span class="s-comment">// We're dispatching our new method through the Objective-C
    // runtime, to enable us to override it within subclasses:</span>
    <span class="s-keyword">@objc func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>,
                      from viewController: <span class="s-type">UIViewController</span>,
                      retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-comment">// This assertion will help us identify errors that were
        // either emitted by a view controller *before* it was
        // added to the responder chain, or never handled at all:</span>
        <span class="s-keyword">guard let</span> nextResponder = next <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> <span class="s-call">assertionFailure</span>(<span class="s-string">"""
            Unhandled error</span> \(error) <span class="s-string">from</span> \(viewController)
            <span class="s-string">"""</span>)
        }

        nextResponder.<span class="s-call">handle</span>(error,
            from: viewController,
            retryHandler: retryHandler
        )
    }
}</code></pre><p class="info">The above design is quite similar to AppKit‚Äôs <code>presentError</code> API, which also uses the responder chain in a similar fashion.</p><p>Since much of our UI-based error propagation is likely to originate from view controllers, let‚Äôs also extend <code>UIViewController</code> with the following convenience API to avoid having to manually pass <code>self</code> every time that we want to handle an error:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIViewController</span> {
    <span class="s-keyword">func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>,
                retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-call">handle</span>(error, from: <span class="s-keyword">self</span>, retryHandler: retryHandler)
    }
}</code></pre><p>Using our new API is now <em>almost</em> as simple as calling the private <code>handle</code> method that we previously used within our <code>ConversationListViewController</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> ConversationListViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">func</span> loadConversations() {
        loader.<span class="s-call">loadConversations</span> { [<span class="s-keyword">weak self</span>] result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> conversations):
                <span class="s-keyword">self</span>?.<span class="s-call">render</span>(conversations)
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-keyword">self</span>?.<span class="s-call">handle</span>(error, retryHandler: {
                    <span class="s-keyword">self</span>?.<span class="s-call">loadConversations</span>()
                })
            }
        }
    }
}</code></pre><p>With our new error propagation system in place, we can now implement our error handling code anywhere within the responder chain ‚Äî which both gives us a ton of flexibility, and also lets us move away from requiring each view controller to manually implement its own error handling code.</p><h2>Generic error categories</h2><p>However, before we‚Äôll be able to fully utilize our new error handling system, we‚Äôre going to need a slightly more generic way to identify the various errors that our code can produce ‚Äî otherwise we‚Äôll likely end up with quite massive implementations that need to perform lots of type casting between our different error types.</p><p>One way to make that happen would be to introduce a set of <em>error categories</em> that we can divide our app‚Äôs errors into ‚Äî for example by using an enum and a <a href="https://www.swiftbysundell.com/articles/specializing-protocols-in-swift">specialized</a> <code>CategorizedError</code> protocol:</p><pre class="splash"><code><span class="s-keyword">enum</span> ErrorCategory {
    <span class="s-keyword">case</span> nonRetryable
    <span class="s-keyword">case</span> retryable
    <span class="s-keyword">case</span> requiresLogout
}

<span class="s-keyword">protocol</span> CategorizedError: <span class="s-type">Error</span> {
    <span class="s-keyword">var</span> category: <span class="s-type">ErrorCategory</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Now all that we have to do to categorize an error is make it conform to the above protocol, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">NetworkingError</span>: <span class="s-type">CategorizedError</span> {
    <span class="s-keyword">var</span> category: <span class="s-type">ErrorCategory</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">deviceIsOffline</span>, .<span class="s-dotAccess">serverError</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">retryable</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">resourceNotFound</span>, .<span class="s-dotAccess">missingData</span>, .<span class="s-dotAccess">decodingFailed</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">nonRetryable</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">unauthorized</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">requiresLogout</span>
        }
    }
}</code></pre><p>Finally, let‚Äôs also extend <code>Error</code> with a convenience API that‚Äôll let us retrieve an <code>ErrorCategory</code> from any error ‚Äî by falling back to a default category for errors that don‚Äôt yet support categorization:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Error</span> {
    <span class="s-keyword">func</span> resolveCategory() -&gt; <span class="s-type">ErrorCategory</span> {
        <span class="s-keyword">guard let</span> categorized = <span class="s-keyword">self as</span>? <span class="s-type">CategorizedError</span> <span class="s-keyword">else</span> {
            <span class="s-comment">// We could optionally choose to trigger an assertion
            // here, if we consider it important that all of our
            // errors have categories assigned to them.</span>
            <span class="s-keyword">return</span> .<span class="s-dotAccess">nonRetryable</span>
        }

        <span class="s-keyword">return</span> categorized.<span class="s-property">category</span>
    }
}</code></pre><p>With the above in place, we‚Äôll now be able to write our error handling code in a complete reusable way, without losing any precision. In this case, we‚Äôll do that by extending our <code>AppDelegate</code> (which sits at the top of the responder chain) with the following implementation:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">AppDelegate</span> {
    <span class="s-keyword">override func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>,
                         from viewController: <span class="s-type">UIViewController</span>,
                         retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"An error occured"</span>,
            message: error.<span class="s-property">localizedDescription</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )

        alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
            title: <span class="s-string">"Dismiss"</span>,
            style: .<span class="s-dotAccess">default</span>
        ))

        <span class="s-keyword">switch</span> error.<span class="s-call">resolveCategory</span>() {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">retryable</span>:
            alert.<span class="s-call">addAction</span>(<span class="s-type">UIAlertAction</span>(
                title: <span class="s-string">"Retry"</span>,
                style: .<span class="s-dotAccess">default</span>,
                handler: { <span class="s-keyword">_ in</span> <span class="s-call">retryHandler</span>() }
            ))
        <span class="s-keyword">case</span> .<span class="s-dotAccess">nonRetryable</span>:
            <span class="s-keyword">break
        case</span> .<span class="s-dotAccess">requiresLogout</span>:
            <span class="s-keyword">return</span> <span class="s-call">performLogout</span>()
        }

        viewController.<span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>Apart from the fact that we now have a single error handling implementation that can be used to present any error that was encountered by any of our view controllers, the power of the responder chain is that we can also easily insert more specific handling code anywhere within that chain.</p><p>For example, if an error that requires logout (such as an authorization error) was encountered on our login screen, we probably want to display an error message, rather than attempting to log the user out. To make that happen, we just have to implement <code>handle</code> within that view controller, add our custom error handling, and then pass any errors that we don‚Äôt wish to handle at that level to our superclass ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">LoginViewController</span> {
    <span class="s-keyword">override func</span> handle(<span class="s-keyword">_</span> error: <span class="s-type">Error</span>,
                         from viewController: <span class="s-type">UIViewController</span>,
                         retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">guard</span> error.<span class="s-call">resolveCategory</span>() == .<span class="s-dotAccess">requiresLogout</span> <span class="s-keyword">else</span> {
            <span class="s-keyword">return super</span>.<span class="s-call">handle</span>(error,
                from: viewController,
                retryHandler: retryHandler
            )
        }

        errorLabel.<span class="s-property">text</span> = <span class="s-string">"""
        Login failed. Check your username and password.
        """</span>
    }
}</code></pre><p class="info">The above override will also catch all errors produced by our login view controller‚Äôs children.</p><p>While there are a number of other factors that we might want to take into account when handling errors (such as avoiding stacking multiple alerts on top of each other, or to automatically retry certain operations rather than showing an error), using the responder chain to propagate user-facing errors can be incredibly powerful ‚Äî as it lets us write finely grained error handling code without having to spread that code across all of our various UI implementations.</p><h2>From UIKit to SwiftUI</h2><p>Next, let‚Äôs take a look at how we could achieve a setup similar to the UIKit-based one that we just explored, but within SwiftUI instead. While SwiftUI does not have an <em>actual responder chain</em>, it does feature other mechanisms that let us propagate information upwards and downwards through a view hierarchy.</p><p>To get started, let‚Äôs create an <code>ErrorHandler</code> protocol that we‚Äôll use to define our various error handlers. When asked to handle an error, we‚Äôll also give each handler access to the <code>View</code> that the error was encountered in, as well as a <code>LoginStateController</code> that‚Äôs used to manage our app‚Äôs login state, and just like within our UIKit-based implementation, we‚Äôll use a <code>retryHandler</code> closure to enable failed operations to be retried:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ErrorHandler {
    <span class="s-keyword">func</span> handle&lt;T: <span class="s-type">View</span>&gt;(
        <span class="s-keyword">_</span> error: <span class="s-type">Error</span>?,
        <span class="s-keyword">in</span> view: <span class="s-type">T</span>,
        loginStateController: <span class="s-type">LoginStateController</span>,
        retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-type">AnyView</span>
}</code></pre><p class="info">Note that the above <code>error</code> parameter is an optional, which will later enable us to pass in our view errors in a declarative, SwiftUI-friendly way.</p><p>Next, let‚Äôs write a default implementation of the above protocol, which (just like when using UIKit) will present an alert view for each error that was encountered. It‚Äôll do so by converting its passed parameters into an internal <code>Presentation</code> model, which will then be wrapped in a <code>Binding</code> value and used to present an <code>Alert</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> AlertErrorHandler: <span class="s-type">ErrorHandler</span> {
    <span class="s-comment">// We give our handler an ID, so that SwiftUI will be able
    // to keep track of the alerts that it creates as it updates
    // our various views:</span>
    <span class="s-keyword">private let</span> id = <span class="s-type">UUID</span>()

    <span class="s-keyword">func</span> handle&lt;T: <span class="s-type">View</span>&gt;(
        <span class="s-keyword">_</span> error: <span class="s-type">Error</span>?,
        <span class="s-keyword">in</span> view: <span class="s-type">T</span>,
        loginStateController: <span class="s-type">LoginStateController</span>,
        retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-type">AnyView</span> {
        <span class="s-keyword">guard</span> error?.<span class="s-call">resolveCategory</span>() != .<span class="s-dotAccess">requiresLogout</span> <span class="s-keyword">else</span> {
            loginStateController.<span class="s-property">state</span> = .<span class="s-dotAccess">loggedOut</span>
            <span class="s-keyword">return</span> <span class="s-type">AnyView</span>(view)
        }

        <span class="s-keyword">var</span> presentation = error.<span class="s-call">map</span> { <span class="s-type">Presentation</span>(
            id: id,
            error: $0,
            retryHandler: retryHandler
        )}

        <span class="s-comment">// We need to convert our model to a Binding value in
        // order to be able to present an alert using it:</span>
        <span class="s-keyword">let</span> binding = <span class="s-type">Binding</span>(
            get: { presentation },
            set: { presentation = $0 }
        )

        <span class="s-keyword">return</span> <span class="s-type">AnyView</span>(view.<span class="s-call">alert</span>(item: binding, content: makeAlert))
    }
}</code></pre><p>The reason we need a <code>Presentation</code> model is because SwiftUI requires a value to be <code>Identifiable</code> in order to be able to display an alert for it. By using our handler‚Äôs own <code>UUID</code> as our identifier (like we do above), we‚Äôll be able to provide SwiftUI with a stable identity for each alert that we create, even as it updates and re-renders our views.</p><p>Let‚Äôs now implement that <code>Presentation</code> model, along with the private <code>makeAlert</code> method that we call above, and our default <code>ErrorHandler</code> implementation will be complete:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">AlertErrorHandler</span> {
    <span class="s-keyword">struct</span> Presentation: <span class="s-type">Identifiable</span> {
        <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
        <span class="s-keyword">let</span> error: <span class="s-type">Error</span>
        <span class="s-keyword">let</span> retryHandler: () -&gt; <span class="s-type">Void</span>
    }
    
    <span class="s-keyword">func</span> makeAlert(for presentation: <span class="s-type">Presentation</span>) -&gt; <span class="s-type">Alert</span> {
        <span class="s-keyword">let</span> error = presentation.<span class="s-property">error</span>

        <span class="s-keyword">switch</span> error.<span class="s-call">resolveCategory</span>() {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">retryable</span>:
            <span class="s-keyword">return</span> <span class="s-type">Alert</span>(
                title: <span class="s-type">Text</span>(<span class="s-string">"An error occured"</span>),
                message: <span class="s-type">Text</span>(error.<span class="s-property">localizedDescription</span>),
                primaryButton: .<span class="s-call">default</span>(<span class="s-type">Text</span>(<span class="s-string">"Dismiss"</span>)),
                secondaryButton: .<span class="s-call">default</span>(<span class="s-type">Text</span>(<span class="s-string">"Retry"</span>),
                    action: presentation.<span class="s-property">retryHandler</span>
                )
            )
        <span class="s-keyword">case</span> .<span class="s-dotAccess">nonRetryable</span>:
            <span class="s-keyword">return</span> <span class="s-type">Alert</span>(
                title: <span class="s-type">Text</span>(<span class="s-string">"An error occured"</span>),
                message: <span class="s-type">Text</span>(error.<span class="s-property">localizedDescription</span>),
                dismissButton: .<span class="s-call">default</span>(<span class="s-type">Text</span>(<span class="s-string">"Dismiss"</span>))
            )
        <span class="s-keyword">case</span> .<span class="s-dotAccess">requiresLogout</span>:
            <span class="s-comment">// We don't expect this code path to be hit, since
            // we're guarding for this case above, so we'll
            // trigger an assertion failure here.</span>
            <span class="s-call">assertionFailure</span>(<span class="s-string">"Should have logged out"</span>)
            <span class="s-keyword">return</span> <span class="s-type">Alert</span>(title: <span class="s-type">Text</span>(<span class="s-string">"Logging out..."</span>))
        }
    }
}</code></pre><p>The next thing that we‚Äôll need is a way to pass the current error handler downwards through our view hierarchy, which interestingly is the opposite direction compared to how we implemented things using the UIKit responder chain. While SwiftUI does feature APIs for upwards propagation (such as the <em>preferences system</em> that we used to implement syncing between views in <em><a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2/%23geometry-preferences-and-layout-dependencies">part two of ‚ÄúA guide to the SwiftUI layout system‚Äù</a></em>), passing objects and information downwards is often a much better fit for SwiftUI‚Äôs highly declarative nature.</p><p>To make that happen, let‚Äôs use SwiftUI‚Äôs <em>environment system</em>, which enables us to add key objects and values to our view hierarchy‚Äôs overall environment ‚Äî which any view or modifier will then be able to obtain.</p><p>Doing so involves two steps in this case. First, we‚Äôll define an <code>EnvironmentKey</code> for storing our current error handler, and we‚Äôll then extend the <code>EnvironmentValues</code> type with a <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift">computed property</a> for accessing it ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ErrorHandlerEnvironmentKey: <span class="s-type">EnvironmentKey</span> {
    <span class="s-keyword">static var</span> defaultValue: <span class="s-type">ErrorHandler</span> = <span class="s-type">AlertErrorHandler</span>()
}

<span class="s-keyword">extension</span> <span class="s-type">EnvironmentValues</span> {
    <span class="s-keyword">var</span> errorHandler: <span class="s-type">ErrorHandler</span> {
        <span class="s-keyword">get</span> { <span class="s-keyword">self</span>[<span class="s-type">ErrorHandlerEnvironmentKey</span>.<span class="s-keyword">self</span>] }
        <span class="s-keyword">set</span> { <span class="s-keyword">self</span>[<span class="s-type">ErrorHandlerEnvironmentKey</span>.<span class="s-keyword">self</span>] = newValue }
    }
}</code></pre><p>Since we‚Äôve made an instance of <code>AlertErrorHandler</code> our default environment value, we don‚Äôt need to explicitly inject an error handler when constructing our views ‚Äî except when we‚Äôll want to override the default handler for a subset of our hierarchy (like we did for our login screen when using UIKit). To make such overrides simpler to add, let‚Äôs create a convenience API for it:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> handlingErrors(
        using handler: <span class="s-type">ErrorHandler</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">environment</span>(\.<span class="s-property">errorHandler</span>, handler)
    }
}</code></pre><p>With the above in place, we now have everything that‚Äôs needed for <em>handling errors</em>, so now let‚Äôs implement the other side of the coin ‚Äî <em>emitting them</em>.</p><p>To enable any view to easily emit the user-facing errors that it encounters, let‚Äôs use SwiftUI‚Äôs <em><a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views/%23modifier-types">view modifier system</a></em> to encapsulate all of the logic required to connect an error and a retry handler to the error handling system that we built above:</p><pre class="splash"><code><span class="s-keyword">struct</span> ErrorEmittingViewModifier: <span class="s-type">ViewModifier</span> {
    <span class="s-keyword">@EnvironmentObject var</span> loginStateController: <span class="s-type">LoginStateController</span>
    <span class="s-keyword">@Environment</span>(\.<span class="s-property">errorHandler</span>) <span class="s-keyword">var</span> handler

    <span class="s-keyword">var</span> error: <span class="s-type">Error</span>?
    <span class="s-keyword">var</span> retryHandler: () -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">func</span> body(content: <span class="s-type">Content</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        handler.<span class="s-call">handle</span>(error,
            in: content,
            loginStateController: loginStateController,
            retryHandler: retryHandler
        )
    }
}</code></pre><p class="info">Note how we use two different property wrappers for accessing our above environment objects. The <code>@Environment</code> wrapper enables us to read values directly from the environment itself, while the <code>@EnvironmentObject</code> one enables us to obtain an object that was passed down from a parent view.</p><p>While we <em>could</em> simply use our new view modifier directly within our views, let‚Äôs also create a convenience API for it, for example like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> emittingError(
        <span class="s-keyword">_</span> error: <span class="s-type">Error</span>?,
        retryHandler: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">modifier</span>(<span class="s-type">ErrorEmittingViewModifier</span>(
            error: error,
            retryHandler: retryHandler
        ))
    }
}</code></pre><p>With the above in place, our SwiftUI-based error propagation system is now finished ‚Äî so let‚Äôs take it for a spin! Even though the system itself was quite complex to build, the resulting call sites can remain very simple ‚Äî since all that a view needs to do to propagate an error is to call the <code>emittingError</code> API that we just defined, and our new error propagation system will take care of the rest.</p><p>Here‚Äôs what that might look like in a rewritten SwiftUI-version of our <code>ConversationListViewController</code> from before (which now also has an accompanying <a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift">view model</a>):</p><pre class="splash"><code><span class="s-keyword">class</span> ConversationListViewModel: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">@Published private(set) var</span> error: <span class="s-type">Error</span>?
    <span class="s-keyword">@Published private(set) var</span> conversations: [<span class="s-type">Conversation</span>]
    ...
}

<span class="s-keyword">struct</span> ConversationListView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">ConversationListViewModel</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(viewModel.<span class="s-property">conversations</span>, rowContent: makeRow)
            .<span class="s-call">emittingError</span>(viewModel.<span class="s-property">error</span>, retryHandler: {
                <span class="s-keyword">self</span>.<span class="s-property">viewModel</span>.<span class="s-call">load</span>()
            })
            .<span class="s-call">onAppear</span>(perform: viewModel.<span class="s-property">load</span>)
            ...
    }

    <span class="s-keyword">private func</span> makeRow(for conversation: <span class="s-type">Conversation</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        ...
    }
}</code></pre><p>The final piece of the puzzle is that when we‚Äôre setting up our view hierarchy, we need to make sure to inject our <code>LoginStateController</code> into our environment (to enable it to later be retrieved by our <code>ErrorEmittingViewModifier</code>), which can be done like this:</p><pre class="splash"><code><span class="s-type">RootView</span>(...).<span class="s-call">environmentObject</span>(loginStateController)</code></pre><p class="info">We‚Äôll take a much closer look at SwiftUI‚Äôs various environment APIs, and how they can be used for dependency injection, in future articles.</p><p>In many ways, the two implementations of our error propagation system really show just how different UIKit and SwiftUI are ‚Äî as SwiftUI required us to add several new types, but also enabled us construct a fully declarative API that‚Äôs inline with the built-in APIs that SwiftUI itself ships with.</p><h2>Conclusion</h2><p>When dealing with user-facing errors, such as those encountered within our UI code, it‚Äôs typically a good idea to come up with some form of system or architecture that lets us propagate those kinds of errors to a central handling mechanism.</p><p>When using UIKit or AppKit, that could be done using the responder chain, while SwiftUI-based apps might opt to use either the environment or preferences system, or by going for some kind of unidirectional approach for both emitting errors and other events.</p><p>Either way, let‚Äôs make those simple <em>‚ÄúAn error occurred‚Äù</em> dialogs a thing of the past, shall we? üôÇ</p><p>Got questions, comments, or feedback? Feel free to reach out either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/clips/6</guid><title>Video: Key paths and functions</title><description>Let‚Äôs take a look at how Swift‚Äôs key paths work, and how they relate to functions ‚Äî both in terms of what comes built into the language itself, and what kind of utilities that we can write ourselves to form some really nice convenience APIs.</description><link>https://www.swiftbysundell.com/clips/6</link><pubDate>Fri, 8 May 2020 18:50:00 +0200</pubDate><content:encoded><![CDATA[<div class="video-player"><iframe frameborder="0" allow="accelerometer; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="true" src="https://www.youtube-nocookie.com/embed/OJPFwSA1AbA"></iframe></div><p>Let‚Äôs take a look at how Swift‚Äôs key paths work, and how they relate to functions ‚Äî both in terms of what comes built into the language itself, and what kind of utilities that we can write ourselves to form some really nice convenience APIs.</p><p>For more on Swift‚Äôs key paths feature, check out <a href="https://www.swiftbysundell.com/tags/key-paths">this category page</a>.</p><h2>Sample code</h2><p>Using key paths to extract property values from a <code>Product</code> value:</p><pre class="splash"><code><span class="s-keyword">struct</span> Product {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> kind: <span class="s-type">Kind</span>
    ...
}

<span class="s-keyword">let</span> keyPath = \<span class="s-type">Product</span>.<span class="s-property">name</span>

<span class="s-keyword">var</span> product = <span class="s-type">Product</span>(name: <span class="s-string">"iPhone 11"</span>, kind: .<span class="s-dotAccess">phone</span>)

product[keyPath: keyPath] <span class="s-comment">// iPhone 11</span>
product[keyPath: \.<span class="s-property">kind</span>] <span class="s-comment">// Product.Kind.phone</span>
product[keyPath: keyPath] = <span class="s-string">"iPhone SE"</span></code></pre><p>Passing a key path as a function when using <code>map</code> to transform an array:</p><pre class="splash"><code><span class="s-keyword">let</span> products: [<span class="s-type">Product</span>] = [...]
<span class="s-keyword">let</span> names = products.<span class="s-call">map</span> { $0.<span class="s-property">name</span> }
<span class="s-keyword">let</span> names = products.<span class="s-call">map</span>(\.<span class="s-property">name</span>)</code></pre><p>Extending the <code>Sequence</code> protocol with a key path-based convenience API for sorting:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Sequence</span> {
    <span class="s-keyword">func</span> sorted&lt;T: <span class="s-type">Comparable</span>&gt;(
        by keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Element</span>, <span class="s-type">T</span>&gt;
    ) -&gt; [<span class="s-type">Element</span>] {
        <span class="s-call">sorted</span> { a, b <span class="s-keyword">in</span>
            a[keyPath: keyPath] &lt; b[keyPath: keyPath]
        }
    }
}</code></pre><p>How using our new <code>sorted</code> method compares to using an inline sorting closure:</p><pre class="splash"><code><span class="s-comment">// Using an inline closure:</span>
products.<span class="s-call">sorted</span>(by: { $0.<span class="s-property">name</span> &lt; $1.<span class="s-property">name</span> })

<span class="s-comment">// Using a key path:</span>
products.<span class="s-call">sorted</span>(by: \.<span class="s-property">name</span>)</code></pre><p>A <code>CanvasViewController</code> that currently uses an asynchronous completion handler closure to assign a <code>UIImage</code> to a <code>UIImageView</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> CanvasViewController {
    <span class="s-keyword">private var</span> canvas = <span class="s-type">Canvas</span>()
    <span class="s-keyword">private lazy var</span> previewImageView = <span class="s-type">UIImageView</span>()

    ...

    <span class="s-keyword">func</span> renderPreviewImage() {
        canvas.<span class="s-call">renderAsImage</span> { [<span class="s-keyword">weak self</span>] image <span class="s-keyword">in
            self</span>?.<span class="s-property">previewImageView</span>.<span class="s-property">image</span> = image
        }
    }
}</code></pre><p>Writing a utility function that enables us to convert a reference writable key path into a setter closure:</p><pre class="splash"><code><span class="s-keyword">func</span> setter&lt;O: <span class="s-type">AnyObject</span>, V&gt;(
    for object: <span class="s-type">O</span>,
    <span class="s-keyword">_</span> keyPath: <span class="s-type">ReferenceWritableKeyPath</span>&lt;<span class="s-type">O</span>, <span class="s-type">V</span>&gt;
) -&gt; (<span class="s-type">V</span>) -&gt; <span class="s-type">Void</span> {
    { [<span class="s-keyword">weak</span> object] value <span class="s-keyword">in</span>
        object?[keyPath: keyPath] = value
    }
}</code></pre><p>Using our new utility function:</p><pre class="splash"><code><span class="s-keyword">class</span> CanvasViewController {
    <span class="s-keyword">private var</span> canvas = <span class="s-type">Canvas</span>()
    <span class="s-keyword">private lazy var</span> previewImageView = <span class="s-type">UIImageView</span>()

    ...

    <span class="s-keyword">func</span> renderPreviewImage() {
        canvas.<span class="s-call">renderAsImage</span>(
            then: <span class="s-call">setter</span>(for: previewImageView, \.<span class="s-property">image</span>)
        )
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/72</guid><title>Podcast: ‚ÄúMany layers of SwiftUI‚Äù, with special guest Tobias Due Munk</title><description>Tobias Due Munk joins John to talk about using SwiftUI to build prototypes, how third party developers can extend SwiftUI‚Äôs built-in APIs in various ways, and to discuss the challenges of writing highly dynamic systems in Swift.</description><link>https://www.swiftbysundell.com/podcast/72</link><pubDate>Thu, 7 May 2020 20:45:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell72.mp3" type="audio/mpeg"/></audio><p>Tobias Due Munk joins John to talk about using SwiftUI to build prototypes, how third party developers can extend SwiftUI‚Äôs built-in APIs in various ways, and to discuss the challenges of writing highly dynamic systems in Swift.</p><h2>Sponsors</h2><ul><li><strong><a href="https://clubhouse.io/sundell">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that‚Äôs fantastic for remote collaboration. Built specifically for software teams. Sign up for free at <a href="https://clubhouse.io/sundell">clubhouse.io/sundell</a>.</li><li><strong><a href="https://bitrise.io/swift">Bitrise</a>:</strong> Fast, stable and highly customizable continuous integration. Automatically build, test and distribute your app on every single commit that you make. Get started for free at <a href="https://bitrise.io/swift">bitrise.io/swift</a>, and also check out their new podcast <a href="https://blog.bitrise.io/mobile-devops-is-a-thing-a-podcast-by-bitrise">‚ÄúMobile DevOps is a Thing!‚Äù</a>.</li></ul><h2>Links</h2><ul><li><a href="https://twitter.com/tobiasdm">Tobias on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://www.youtube.com/watch?v=SCOLRVVRDJk">Into the Deep</a></li><li><a href="https://www.dotconferences.com/2020/02/tobias-due-munk-prototyping-custom-ui-in-swiftui">Prototyping Custom UI in SwiftUI</a></li><li><a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">A guide to the SwiftUI layout system</a></li><li><a href="https://rambo.codes/posts/2020-01-03-you-can-use-swiftui-today">Gui Rambo‚Äôs ‚ÄúYou can use SwiftUI today‚Äù article</a></li><li><a href="https://www.swiftbysundell.com/tips/optional-swiftui-views">Unwrapping optional SwiftUI views</a></li><li><a href="https://www.swiftbysundell.com/podcast/59">Episode with Josh Shaffer from Apple</a></li><li><a href="https://developer.apple.com/documentation/swiftui/navigationview/view_modifiers">SwiftUI View Modifiers</a></li><li><a href="https://developer.apple.com/documentation/swiftui/anyview">AnyView</a></li><li><a href="https://storybook.js.org">Storybook for React</a></li><li><a href="https://duemunk.dk">Tobias‚Äôs website</a></li><li><a href="https://git.kabellmunk.dk/talks/into-the-deep">The source code for ‚ÄúInto the Deep‚Äù</a></li><li><a href="https://dias.app">Dias</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/special/three-years-of-swift-by-sundell</guid><title>Three years of Swift by Sundell</title><description></description><link>https://www.swiftbysundell.com/special/three-years-of-swift-by-sundell</link><pubDate>Tue, 5 May 2020 20:55:00 +0200</pubDate><content:encoded><![CDATA[<p>I very often get asked questions along the lines of <em>‚ÄúHow do you grow an audience?‚Äù</em> or <em>‚ÄúHow to make a website get a lot of traffic?‚Äù</em>. While I‚Äôm sure that there are a number of (more or less morally questionable) techniques that you can employ to accelerate the spread of a project ‚Äî that‚Äôs never something that I‚Äôve been particulary interested in or focused on.</p><p>Today marks exactly three years since I started Swift by Sundell, and while I‚Äôm incredibly happy with how this project has evolved and grown during those past three years, the incredible journey that this project has taken me on wasn‚Äôt something that I ever could have planned (or honestly even imagined).</p><p>When I first launched this website on the 5th of May 2017, I did it for a simple reason: <em>I wanted to write about Swift</em>. At that point, I had already been writing on Medium for a few months, and had realized just how much I enjoyed writing a short little post every week ‚Äî about a technique I had grown fond of, or about a way that I had solved a commonly encountered problem. I really didn‚Äôt have any specific goals or plans for the site, other than to see for how long that I would be able to keep writing a new article every week.</p><p>Fast-forward three years, to today, the 5th of May 2020 ‚Äî and I still don‚Äôt know for how many weeks that I‚Äôll be able to keep writing, <em>because I never stopped</em>.</p><p>So if there‚Äôs one thing that I <em>can give</em> as an answer to those questions about growth and success, it‚Äôs really just that: <em>don‚Äôt stop</em>. If you want to work on something, work on it. If you want to ship an app, write the code for it. Keep doing the very best work that you possibly can, regardless of how many people that are reading, listening, or watching. Because if the work is good, people will eventually show up.</p><p>While this website is now read by over a million people each year, and serves around 50,000 page views <em>per day</em>, three years ago, it had an audience of zero ‚Äî and that‚Äôs something that I will never forget.</p><p>I didn‚Äôt intend for this website to become my full-time job, but I‚Äôm really glad that it did. It‚Äôs such a pleasure to be able to share my work like this, in a way that anybody can access, anywhere around the world.</p><p>So whether this is the first time you ended up on this website, or you‚Äôre a regular reader ‚Äî thank you. Thanks to all of you for reading my articles, for listening to my podcast, and for all of the amazing feedback that this wonderful community has given me over the past three years.</p><p>Happy birthday, Swift by Sundell! Let‚Äôs do another three years, shall we?</p>]]></content:encoded></item><item><guid isPermaLink="false">swiftbysundell/links/making-xcode-ui-tests-faster-and-more-stable</guid><title>Link: Making Xcode UI tests faster and more stable</title><description></description><link>https://blog.bitrise.io/making-xcode-ui-tests-faster-and-more-stable</link><pubDate>Tue, 5 May 2020 11:15:00 +0200</pubDate><content:encoded><![CDATA[<p>Over the years, Xcode‚Äôs built-in UI testing system has developed somewhat of a reputation for being slow, unstable and generally hard to work with.</p><p>While it‚Äôs true that UI tests are inherently slower to run than something like unit tests (given that they actually have to run the app and interact with the UI as a user would), there are often ways to make the tests that we write much more stable ‚Äî and in my latest guest post on the Bitrise blog, I share my favorite tips and techniques for doing just that.</p><p><strong><a href="https://blog.bitrise.io/making-xcode-ui-tests-faster-and-more-stable">Read the full article on the Bitrise blog</a></strong></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/different-categories-of-swift-protocols</guid><title>The different categories of Swift protocols</title><description>Swift‚Äôs many protocols can, in general, be split up into four main categories. Let‚Äôs go through them, and how keeping them in mind can help us write well-formed protocols that are consistent with those found in the standard library.</description><link>https://www.swiftbysundell.com/articles/different-categories-of-swift-protocols</link><pubDate>Sun, 3 May 2020 20:25:00 +0200</pubDate><content:encoded><![CDATA[<p>In general, the primarily role of protocols (or <em>interfaces</em>) is to enable generic abstractions to be defined on top of concrete implementations ‚Äî a technique which is commonly referred to as <em>polymorphism</em>, as it enables us to swap (or <em>morph</em>) our implementations without affecting their public API.</p><p>While Swift offers full support for that kind of interface-based polymorphism, protocols also play a much larger role in the overall design of the language and its standard library ‚Äî as a major part of the functionality that Swift ships with is actually implemented directly on top of various protocols.</p><p>That <em>protocol-oriented design</em> also enables us to use protocols in many different ways within our own code as well ‚Äî all of which can essentially be divided into four main categories. This week, let‚Äôs go through those categories, and both take a look at how Apple uses protocols within their frameworks, and how we can define our own protocols in a very similar fashion.</p><h2>Enabling unified actions</h2><p>Let‚Äôs start by taking a look at protocols that require the types that conform to them to be able to perform certain actions. For example, the standard library‚Äôs <code>Equatable</code> protocol is used to mark that a type can perform an equality check between two instances, while the <code>Hashable</code> protocol is adopted by types that can be hashed:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Equatable {
    <span class="s-keyword">static func</span> ==(lhs: <span class="s-type">Self</span>, rhs: <span class="s-type">Self</span>) -&gt; <span class="s-type">Bool</span>
}

<span class="s-keyword">protocol</span> Hashable: <span class="s-type">Equatable</span> {
    <span class="s-keyword">func</span> hash(into hasher: <span class="s-keyword">inout</span> <span class="s-type">Hasher</span>)
}</code></pre><p>A big benefit of the fact that those two capabilities are defined using the type system (rather than being hard-coded into the compiler) is that it lets us write generic code that‚Äôs <em><a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4">constrained</a></em> to those protocols, which in turn enables us to make full use of those capabilities within such code.</p><p>For example, here‚Äôs how we could extend <code>Array</code> with a method that lets us count all occurrences of a value, given that the array‚Äôs <code>Element</code> type conforms to <code>Equatable</code>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Array</span> <span class="s-keyword">where</span> <span class="s-type">Element</span>: <span class="s-type">Equatable</span> {
    <span class="s-keyword">func</span> numberOfOccurences(of value: <span class="s-type">Element</span>) -&gt; <span class="s-type">Int</span> {
        <span class="s-call">reduce</span>(into: <span class="s-number">0</span>) { count, element <span class="s-keyword">in</span>
            <span class="s-comment">// We can check whether two values are equal here
            // since we have a guarantee that they both conform
            // to the Equatable protocol:</span>
            <span class="s-keyword">if</span> element == value {
                count += <span class="s-number">1</span>
            }
        }
    }
}</code></pre><p>In general, whenever we define action-based protocols, it‚Äôs usually a good idea to make those protocols as generic as possible (just like <code>Equatable</code> and <code>Hashable</code>), since that lets them remain focused on the actions themselves, rather than being too tied to any specific domain.</p><p>So for example, if we wanted to unify several types that load various objects or values, we could define a <code>Loadable</code> protocol with an <em>associated type</em> ‚Äî which would let each conforming type declare what sort of <code>Result</code> that it loads:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Loadable {
    <span class="s-keyword">associatedtype</span> Result
    <span class="s-keyword">func</span> load() <span class="s-keyword">throws</span> -&gt; <span class="s-type">Result</span>
}</code></pre><p>However, not every protocol defines actions (after all, this is just the first category out of four). For example, while the name of the following <code>Cachable</code> protocol might suggest that it contains actions for caching, it‚Äôs actually just used to enable various types to define their own caching keys:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Cachable: <span class="s-type">Codable</span> {
    <span class="s-keyword">var</span> cacheKey: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Compare the above to the built-in <a href="https://www.swiftbysundell.com/basics/codable"><code>Codable</code></a> protocol that <code>Cachable</code> <a href="https://www.swiftbysundell.com/articles/specializing-protocols-in-swift/%23inheritance">inherits from</a>, which <em>does</em> define actions for both encoding and decoding ‚Äî and it starts to become clear that we‚Äôve ended up with a bit of a naming mismatch.</p><p>After all, not all protocols need to use the <em>able</em> suffix. In fact, forcing that suffix onto any given noun just to define a protocol for it can lead to quite a lot of confusion ‚Äî like in this case:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Titleable {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p class="info">What does <em>‚ÄúTitleable‚Äù</em> even mean?</p><p>What‚Äôs perhaps even more confusing is when using the <em>‚Äùable‚Äù</em> suffix results in a name with a completely different meaning than what we intended. For example, here we‚Äôve defined a protocol <em>with the intention</em> of having it act as an API for color containers, but its name suggests that it‚Äôs for types that themselves can be colored:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Colorable {
    <span class="s-keyword">var</span> foregroundColor: <span class="s-type">UIColor</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> backgroundColor: <span class="s-type">UIColor</span> { <span class="s-keyword">get</span> }
}</code></pre><p>So how could we improve some of the these protocols ‚Äî both in terms of their naming, as well as how they‚Äôre structured? Let‚Äôs start by stepping out of category number one, and explore a few different ways of defining protocols in Swift.</p><h2>Defining requirements</h2><p>Category number two is for protocols that are used to define formal requirements for a given kind of object or API. Within the standard library, such protocols are used to define what <em>it means to be</em> things like a <code>Collection</code>, a <code>Numeric</code>, or a <code>Sequence</code>:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Sequence {
    <span class="s-keyword">associatedtype</span> Iterator: <span class="s-type">IteratorProtocol</span>
    <span class="s-keyword">func</span> makeIterator() -&gt; <span class="s-type">Iterator</span>
}</code></pre><p class="info">Note that the above protocol is not called <code>Sequencable</code>, since that would indicate that it‚Äôs about <em>turning objects into</em> sequences, rather than defining the requirements for <em>being one</em>.</p><p>What the above definition of <code>Sequence</code> tells us is that the primary role of any Swift sequence (such as an <code>Array</code>, a <code>Dictionary</code>, or something like a <code>Range</code>) is to act as a <em><a href="https://www.swiftbysundell.com/articles/using-the-factory-pattern-to-avoid-shared-state-in-swift">factory</a></em> for creating iterators ‚Äî which in turn are formalized through the following protocol:</p><pre class="splash"><code><span class="s-keyword">protocol</span> IteratorProtocol {
    <span class="s-keyword">associatedtype</span> Element
    <span class="s-keyword">mutating func</span> next() -&gt; <span class="s-type">Element</span>?
}</code></pre><p class="info">The above protocol could arguably have been called <code>Iterable</code> instead, since iterators do actually perform each iteration action themselves. However, the name <code>IteratorProtocol</code> was likely picked to make it feel more consistent with <code>Sequence</code>, since simply naming it <code>Iterator</code> would‚Äôve caused conflicts with the associated type of the same name.</p><p>With the above two protocols in mind, let‚Äôs now go back to the <code>Cachable</code> and <code>Colorable</code> protocols that we defined earlier, to see if they can be improved by transforming them into requirement definitions instead.</p><p>Let‚Äôs start by renaming <code>Colorable</code> into <code>ColorProvider</code>, which gives that protocol a whole new meaning ‚Äî even if its requirements remain exactly the same. It no longer sounds like it‚Äôs used to define objects that can be colored, but rather that it‚Äôs about <em>providing</em> color information to some other part of our system ‚Äî which is exactly what we intended:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ColorProvider {
    <span class="s-keyword">var</span> foregroundColor: <span class="s-type">UIColor</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> backgroundColor: <span class="s-type">UIColor</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Similarly, taking inspiration from the built-in <code>IteratorProtocol</code>, we could rename <code>Cachable</code> into something like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> CachingProtocol: <span class="s-type">Codable</span> {
    <span class="s-keyword">var</span> cacheKey: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p>However, an arguably even better approach in this case would be to decouple the concept of generating caching keys from the types that are actually being cached ‚Äî which would let us keep our model code free from caching-specific properties.</p><p>One way to do that would be to move our key generation code into separate types ‚Äî which we could then formalize the requirements for using a <code>CacheKeyGenerator</code> protocol:</p><pre class="splash"><code><span class="s-keyword">protocol</span> CacheKeyGenerator {
    <span class="s-keyword">associatedtype</span> Value: <span class="s-type">Codable</span>
    <span class="s-keyword">func</span> cacheKey(for value: <span class="s-type">Value</span>) -&gt; <span class="s-type">String</span>
}</code></pre><p>Another option would be to model the above as <a href="https://www.swiftbysundell.com/articles/alternatives-to-protocols-in-swift/%23single-requirements-using-closures">a closure instead</a>, which is often a great alternative to protocols that just contain a single requirement.</p><h2>Type conversions</h2><p>Next, let‚Äôs take a look at protocols that are used to declare that a type is <em>convertible</em> to and from other values. We‚Äôll again start with an example from the standard library ‚Äî <code>CustomStringConvertible</code>, which can be used to enable any type to be converted into a custom description string:</p><pre class="splash"><code><span class="s-keyword">protocol</span> CustomStringConvertible {
    <span class="s-keyword">var</span> description: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p class="info">Compare the above to what it could‚Äôve looked like if it was called <code>Describable</code> instead. If so, the expectation would probably have been that it contains a <code>describe()</code> method, or something similar.</p><p>That kind of design is particularly useful when we want to be able to extract a single piece of data from multiple types ‚Äî which perfectly matches the purpose of our (somewhat strangely named) <code>Titleable</code> protocol from earlier.</p><p>By renaming that protocol to <code>TitleConvertible</code> instead, we not only make it easier to understand what that protocol is for, we also make our code more consistent with the standard library ‚Äî which is most often a good thing:</p><pre class="splash"><code><span class="s-keyword">protocol</span> TitleConvertible {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}</code></pre><p>Type conversion protocols can also use methods, rather than properties, which is typically <a href="https://www.swiftbysundell.com/tips/computed-properties-vs-methods">a better fit</a> when we expect certain implementations to require a fair amount of computation ‚Äî for example when working with image conversions:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ImageConvertible {
    <span class="s-comment">// Since rendering an image can be a somewhat expensive
    // operation (depending on the type being rendered), we're
    // defining our protocol requirement as a method, rather
    // than as a property:</span>
    <span class="s-keyword">func</span> makeImage() -&gt; <span class="s-type">UIImage</span>
}</code></pre><p>We can also use this category of protocols to enable certain types to be <em>expressed</em> in different ways ‚Äî a technique which is, among other things, used to implement all of Swift‚Äôs built-in support for literals ‚Äî such as string and array literals. Even <code>nil</code> assignments are implemented through a protocol, which is quite cool:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ExpressibleByArrayLiteral {
    <span class="s-keyword">associatedtype</span> ArrayLiteralElement
    <span class="s-keyword">init</span>(arrayLiteral elements: <span class="s-type">ArrayLiteralElement</span>...)
}

<span class="s-keyword">protocol</span> ExpressibleByNilLiteral {
    <span class="s-keyword">init</span>(nilLiteral: ())
}</code></pre><p class="info">Note that while we‚Äôre free to conform to most built-in literal protocols within our own code as well, conforming to <code>ExpressibleByNilLiteral</code> is discouraged ‚Äî as <code>Optional</code> is expected to be the only type adopting that protocol.</p><p>While it‚Äôs perhaps not that common to define our own protocols for bridging literals into an instances of a type (since that does, in fact, require changes to the compiler), we can use that same design whenever we want to declare a protocol for <em>expressing</em> a type using a lower-level representation.</p><p>For example, here‚Äôs how we could define an <code>ExpressibleByUUID</code> protocol for identifier types that can be created using a raw <code>UUID</code>:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ExpressibleByUUID {
    <span class="s-keyword">init</span>(uuid: <span class="s-type">UUID</span>)
}</code></pre><p>Another option would be to use the <code>RawRepresentable</code> protocol, which is what powers <a href="https://www.swiftbysundell.com/basics/enums">enums</a> that have raw values. However, while that protocol is definitely also a type converting one, its initializer is <em>failable</em> ‚Äî which means that it‚Äôs really only useful for conditional conversions that could potentially result in <code>nil</code>.</p><h2>Abstract interfaces</h2><p>Finally, let‚Äôs take a look at perhaps the most common way of using protocols within third party code ‚Äî to define abstractions for interfacing with multiple underlying types.</p><p>An interesting example of this pattern can be found within Apple‚Äôs Metal framework, which is a low-level graphics programming API. Since GPUs tend to vary a lot between devices, and Metal aims to provide a unified API for programming against any type of hardware that it supports, it uses a protocol to define its API as an abstract interface ‚Äî which looks like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> MTLDevice: <span class="s-type">NSObjectProtocol</span> {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> registryID: <span class="s-type">UInt64</span> { <span class="s-keyword">get</span> }
    ...
}</code></pre><p>When using Metal, we can then call the <code>MTLCreateSystemDefaultDevice</code> function, and the system will return an implementation of the above protocol that‚Äôs appropriate for the device that our program is currently running on:</p><pre class="splash"><code><span class="s-keyword">func</span> MTLCreateSystemDefaultDevice() -&gt; <span class="s-type">MTLDevice</span>?</code></pre><p>Within our own code, we can also use that exact same pattern whenever we want to support multiple implementations of the same interface. For example, we might define a <code>NetworkEngine</code> protocol in order to decouple the way we perform our network calls from any specific means of networking:</p><pre class="splash"><code><span class="s-keyword">protocol</span> NetworkEngine {
    <span class="s-keyword">func</span> perform(
        <span class="s-keyword">_</span> request: <span class="s-type">NetworkRequest</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    )
}</code></pre><p>With the above in place, we‚Äôre now free to define as many underlying networking implementations as we need ‚Äî for example a <code>URLSession</code>-based one for production, and a mocked version for testing:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">URLSession</span>: <span class="s-type">NetworkEngine</span> {
    <span class="s-keyword">func</span> perform(
        <span class="s-keyword">_</span> request: <span class="s-type">NetworkRequest</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        ...
    }
}

<span class="s-keyword">struct</span> MockNetworkEngine: <span class="s-type">NetworkEngine</span> {
    <span class="s-keyword">var</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;

    <span class="s-keyword">func</span> perform(
        <span class="s-keyword">_</span> request: <span class="s-type">NetworkRequest</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        <span class="s-call">handler</span>(result)
    }
}</code></pre><p class="info">To learn more about mocking within unit tests, check out <a href="https://www.swiftbysundell.com/articles/mocking-in-swift">‚ÄúMocking in Swift‚Äù</a>.</p><p>The above technique can also be a great way to <a href="https://www.swiftbysundell.com/articles/code-encapsulation-in-swift">encapsulate third party dependencies</a> in order to prevent them from spreading across our entire code base ‚Äî which in turn makes it much easier to replace or remove those dependencies in the future.</p><h2>Conclusion</h2><p>Swift‚Äôs implementation of protocols is definitely one of the most interesting aspects of the language, and the sheer number of ways that they can be defined and used really shows just how powerful they are ‚Äî especially once we start making full use of features like associated types and protocol extensions.</p><p>Because of that, it‚Äôs important to not treat every protocol the same way, but to rather design them according to which category that they belong to. To recap, these are the four categories that I like to split protocols up into:</p><ul><li><strong>Action enablers</strong>, which enable us to perform a given set of actions on each conforming type. They typically have names that end with <em>‚Äúable‚Äù</em>, such as <code>Equatable</code>.</li><li><strong>Requirement definitions</strong> enable us to formalize the requirements for being a certain kind of object, for example a <code>Sequence</code>, a <code>Numeric</code>, or a <code>ColorProvider</code>.</li><li><strong>Type conversion</strong> protocols are used to let various types declare that they can be convertible into another type, or expressible through a raw value or literal ‚Äî like <code>CustomStringConvertible</code> or <code>ExpressibleByStringLiteral</code>.</li><li><strong>Abstract interfaces</strong> act as unified APIs that multiple types can implement, which in turn lets us swap out implementations as we wish, encapsulate third party code, or mock certain objects within our tests.</li></ul><p>What do you think? Do you agree with my way of splitting Swift‚Äôs various protocols up into those four categories, or do you organize your protocols some other way? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/inferred-generic-type-constraints</guid><title>Tip: Inferred generic type constraints</title><description></description><link>https://www.swiftbysundell.com/tips/inferred-generic-type-constraints</link><pubDate>Fri, 1 May 2020 18:20:00 +0200</pubDate><content:encoded><![CDATA[<p>Generic type constraints can be used to impose a set of requirements on the concrete types that a given API will be used with, which in turn enables us make certain assumptions about those types within our generic code.</p><p>For example, let‚Äôs say that an app that we‚Äôre working on is using a <code>NetworkRequest</code> protocol to enable us to define our various requests as different types that each declare what kind of <code>Response</code> that they expect:</p><pre class="splash"><code><span class="s-keyword">protocol</span> NetworkRequest {
    <span class="s-keyword">associatedtype</span> Response: <span class="s-type">Codable</span>

    <span class="s-keyword">func</span> makeURLRequest() -&gt; <span class="s-type">URLRequest</span>
}</code></pre><p>If we now define an API for performing such a request, we might end up with something like the following ‚Äî a function that uses a generic type constraint to ensure that its <code>T</code> type does in fact conform to our above protocol:</p><pre class="splash"><code><span class="s-keyword">func</span> perform<span class="highlight">&lt;T: <span class="s-type">NetworkRequest</span>&gt;</span>(
    <span class="s-keyword">_</span> request: <span class="s-type">T</span>,
    then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">T</span>.<span class="s-type">Response</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
) {
    ...
}</code></pre><p>Now let‚Äôs say that we also want to add support for enqueuing requests using a <code>NetworkRequestQueue</code> class ‚Äî that also uses a generic type constrained to our <code>NetworkRequest</code> protocol:</p><pre class="splash"><code><span class="s-keyword">class</span> NetworkRequestQueue&lt;Request: <span class="s-type">NetworkRequest</span>&gt; {
    ...
}</code></pre><p>When it comes to adding a parameter for injecting an instance of the above class into our <code>perform</code> function, we might initially simply add it to our list of parameters ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">func</span> perform&lt;T: <span class="s-type">NetworkRequest</span>&gt;(
    <span class="s-keyword">_</span> request: <span class="s-type">T</span>,
    on queue: <span class="s-type">NetworkRequestQueue</span>&lt;<span class="s-type">T</span>&gt;,
    then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">T</span>.<span class="s-type">Response</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
) {
    ...
}</code></pre><p>However, since our <code>NetworkRequestQueue</code> class already requires its generic <code>Request</code> type to conform to our <code>NetworkRequest</code> protocol ‚Äî and since the compiler knows that the type used to specialize that class will be the same as the one used for our <code>request</code> parameter ‚Äî we can actually omit that type constraint from our <code>perform</code> function entirely, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> perform<span class="highlight">&lt;T&gt;</span>(
    <span class="s-keyword">_</span> request: <span class="s-type">T</span>,
    on queue: <span class="s-type">NetworkRequestQueue</span>&lt;<span class="s-type">T</span>&gt;,
    then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">T</span>.<span class="s-type">Response</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
) {
    ...
}</code></pre><p>The above might seem like a small detail, and perhaps it is in the grand scheme of things ‚Äî but since generic code tends to become quite verbose, especially when using type constraints, anything we can do to reduce that sort of verbosity is arguably a good thing.</p><p>As an added bonus, let‚Äôs also make the above <code>handler</code> parameter‚Äôs closure type a bit simpler as well ‚Äî by first turning it into a type alias within an extension on our <code>NetworkRequest</code> protocol:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">NetworkRequest</span> {
    <span class="s-keyword">typealias</span> ResponseHandler = (<span class="s-type">Result</span>&lt;<span class="s-type">Response</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
}</code></pre><p>With the above in place, we can now make our <code>perform</code> function‚Äôs signature even nicer to read ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">func</span> perform&lt;T&gt;(
    <span class="s-keyword">_</span> request: <span class="s-type">T</span>,
    on queue: <span class="s-type">NetworkRequestQueue</span>&lt;<span class="s-type">T</span>&gt;,
    then handler: <span class="s-keyword">@escaping</span> <span class="s-type">T</span>.<span class="s-type">ResponseHandler</span>
) {
    ...
}</code></pre><p>Swift‚Äôs syntax might initially seem quite verbose when it comes to defining generic types and functions, but there are often certain tricks and techniques that we can use to make such definitions much more compact ‚Äî without sacrificing any readability.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/bitrise-april-2020</guid><title>Sponsor: Bitrise</title><description>Thanks a lot to Bitrise for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/bitrise-april-2020</link><pubDate>Thu, 30 Apr 2020 16:20:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to <a href="https://go.bitrise.io/swift">Bitrise</a> for supporting Swift by Sundell with another two-week sponsorship. I‚Äôve been using Bitrise since long before they became a sponsor, and their continued support also plays a big part in helping me keep Swift by Sundell free and open to everyone.</p><p>Bitrise is Continuous Integration and Delivery that <em>just works</em>. It lets you automate all sorts of tasks ‚Äî from building and distributing an app, to running tests, code style checks and other types of static analysis. It‚Äôs fast, stable, always updated with the latest versions of Swift and Xcode, and is super easy to use.</p><p>Before I was using Bitrise, adding continuous integration (or CI) to a project was always a bit of a chore ‚Äî since it required fiddling around with poorly documented configuration files, manually updating things for every new Xcode release, and constantly debugging sources of flakiness and instability.</p><p>Now, whenever I start a new project, I simply log into my Bitrise account, click a few buttons in their web UI ‚Äî and my new project has a fully capable CI pipeline up and running. It really is <em>that easy</em>, no matter whether I‚Äôm building an app, a framework, or just a simple Swift package ‚Äî Bitrise builds my project and runs all of my tests on every single commit that I make, which helps me ensure that my projects remain fully working on all of the platforms that they support.</p><p>I really recommend that you try out Bitrise ‚Äî it‚Äôs <em>completely free</em> to get started, and their free tier is now more capable than ever. Using <a href="https://go.bitrise.io/swift">this link</a> to check out Bitrise also helps support Swift by Sundell, which in turn helps me keep the site and the podcast up and running.</p><p><a href="https://go.bitrise.io/swift">Try Bitrise for free and support Swift by Sundell</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/clips/5</guid><title>Video: Controllers in MVC</title><description>Let‚Äôs take a look at the role that controllers play within the MVC design pattern, and how we can avoid some of the most common issues when working with them ‚Äî particularly around how we can break up Massive View Controllers into smaller building blocks.</description><link>https://www.swiftbysundell.com/clips/5</link><pubDate>Tue, 28 Apr 2020 18:05:00 +0200</pubDate><content:encoded><![CDATA[<div class="video-player"><iframe frameborder="0" allow="accelerometer; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="true" src="https://www.youtube-nocookie.com/embed/Ni70aTksJWg"></iframe></div><p>Let‚Äôs take a look at the role that controllers play within the MVC design pattern, and how we can avoid some of the most common issues when working with them ‚Äî particularly around how we can break up <em>Massive View Controllers</em> into smaller building blocks.</p><h2>Links</h2><ul><li><a href="https://www.swiftbysundell.com/basics/child-view-controllers">Child view controllers</a></li><li><a href="https://www.swiftbysundell.com/articles/logic-controllers-in-swift">Logic controllers</a></li><li><a href="https://www.swiftbysundell.com/articles/model-controllers-in-swift">Model controllers</a></li><li><a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift">View models</a></li></ul><h2>Sample code</h2><p>An example of a view controller that constructs its header view inline within its <code>loadView</code> method:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> headerView = <span class="s-type">UIView</span>()
        ...
        view.<span class="s-call">addSubview</span>(headerView)
    }
}</code></pre><p>Moving that header view implementation to a new view controller instead:</p><pre class="splash"><code><span class="s-keyword">class</span> HeaderViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        ...
    }
}</code></pre><p>Embedding our new <code>HeaderViewController</code> as a <a href="https://www.swiftbysundell.com/basics/child-view-controllers">child view controller</a>:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> headerVC = <span class="s-type">HeaderViewController</span>()
        view.<span class="s-call">addSubview</span>(headerVC.<span class="s-property">view</span>)
        <span class="s-call">addChild</span>(headerVC)
        headerVC.<span class="s-call">didMove</span>(toParent: <span class="s-keyword">self</span>)
        ...
    }
}</code></pre><p>Extending <code>UIViewController</code> with an API to make it easier to add child view controllers:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIViewController</span> {
    <span class="s-keyword">func</span> add(<span class="s-keyword">_</span> child: <span class="s-type">UIViewController</span>) {
        <span class="s-call">addChild</span>(child)
        view.<span class="s-call">addSubview</span>(child.<span class="s-property">view</span>)
        child.<span class="s-call">didMove</span>(toParent: <span class="s-keyword">self</span>)
    }
}</code></pre><p class="info">You can also find a <code>remove</code> equivalent to the above API within the <a href="https://www.swiftbysundell.com/basics/child-view-controllers/">Basics article about child view controllers</a>.</p><p>An example of a view controller method that doesn‚Äôt really have much to do with controlling a view:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> userID: <span class="s-type">User</span>.<span class="s-type">ID</span>
    <span class="s-keyword">private let</span> networking: <span class="s-type">NetworkManager</span>
    ...

    <span class="s-keyword">private func</span> loadUser() {
        <span class="s-keyword">let</span> endpoint = <span class="s-type">Endpoint</span>.<span class="s-call">user</span>(id: userID)

        networking.<span class="s-call">request</span>(endpoint) { [<span class="s-keyword">weak self</span>] result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
                <span class="s-keyword">let</span> user = <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">User</span>.<span class="s-keyword">self</span>, from: data)
                <span class="s-keyword">self</span>?.<span class="s-call">render</span>(user)
            } <span class="s-keyword">catch</span> {
                <span class="s-keyword">self</span>?.<span class="s-call">showErrorView</span>(for: error)
            }
        }
    }

    ...
}</code></pre><p>Implementing a generic <code>ViewState</code> enum that we can use to model any view controller‚Äôs high-level rendering state:</p><pre class="splash"><code><span class="s-keyword">enum</span> ViewState&lt;Model&gt; {
    <span class="s-keyword">case</span> loading
    <span class="s-keyword">case</span> presenting(<span class="s-type">Model</span>)
    <span class="s-keyword">case</span> failed(<span class="s-type">Error</span>)
}</code></pre><p>Implementing a <a href="https://www.swiftbysundell.com/articles/logic-controllers-in-swift">logic controller</a> companion for our <code>ProfileViewController</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileLogicController {
    <span class="s-keyword">private let</span> userID: <span class="s-type">User</span>.<span class="s-type">ID</span>
    <span class="s-keyword">private let</span> networking: <span class="s-type">NetworkManager</span>

    ...

    <span class="s-keyword">func</span> loadCurrentState(then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">ViewState</span>&lt;<span class="s-type">User</span>&gt;) -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">let</span> endpoint = <span class="s-type">Endpoint</span>.<span class="s-call">user</span>(id: userID)

        networking.<span class="s-call">request</span>(endpoint) { result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
                <span class="s-keyword">let</span> user = <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">User</span>.<span class="s-keyword">self</span>, from: data)
                <span class="s-call">handler</span>(.<span class="s-call">presenting</span>(user))
            } <span class="s-keyword">catch</span> {
                <span class="s-call">handler</span>(.<span class="s-call">failed</span>(error))
            }
        }
    }
}</code></pre><p>Using our new logic controller within our view controller:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> logic: <span class="s-type">ProfileLogicController</span>

    ...

    <span class="s-keyword">override func</span> viewWillAppear(<span class="s-keyword">_</span> animated: <span class="s-type">Bool</span>) {
        <span class="s-keyword">super</span>.<span class="s-call">viewWillAppear</span>(animated)

        logic.<span class="s-call">loadCurrentState</span> { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in
            self</span>?.<span class="s-call">render</span>(state)
        }
    }
    
    <span class="s-keyword">private func</span> userDidPickNewProfileImage(<span class="s-keyword">_</span> image: <span class="s-type">UIImage</span>) {
        logic.<span class="s-call">handleNewProfileImage</span>(image) { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in
            self</span>?.<span class="s-call">render</span>(state)
        }
    }
}</code></pre><p>An example of a model that‚Äôs currently managed as a singleton:</p><pre class="splash"><code><span class="s-keyword">struct</span> Player {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> score: <span class="s-type">Int</span>
    <span class="s-keyword">var</span> challenges: [<span class="s-type">Challenge</span>]
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">Player</span> {
    <span class="s-keyword">static var</span> current: <span class="s-type">Player</span>?
}</code></pre><p>Using a model controller to manage our model instead:</p><pre class="splash"><code><span class="s-keyword">class</span> PlayerModelController {
    <span class="s-keyword">private(set) var</span> model: <span class="s-type">Player</span>

    <span class="s-keyword">init</span>(model: <span class="s-type">Player</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">model</span> = model
    }
    
    <span class="s-keyword">func</span> levelCompleted(<span class="s-keyword">_</span> level: <span class="s-type">Level</span>) {
        <span class="s-keyword">var</span> levelScore = level.<span class="s-property">enemiesDefeated</span> * <span class="s-number">100</span>
        levelScore += level.<span class="s-property">obstaclesAvoided</span> * <span class="s-number">50</span>
        levelScore *= level.<span class="s-property">difficulty</span>.<span class="s-property">scoreMultiplier</span>

        model.<span class="s-property">score</span> += levelScore
    }
    
    <span class="s-keyword">func</span> observe(using closure: <span class="s-keyword">@escaping</span> (<span class="s-type">Player</span>) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">Cancellable</span> {
        ...
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/querying-collections-in-swift</guid><title>Querying collections in Swift</title><description>This week, let‚Äôs explore how we can make use of the standard library‚Äôs built-in algorithms when performing various types of queries against collections of values.</description><link>https://www.swiftbysundell.com/articles/querying-collections-in-swift</link><pubDate>Sun, 26 Apr 2020 19:40:00 +0200</pubDate><content:encoded><![CDATA[<p>When working with collections, such as arrays or dictionaries, it‚Äôs very common to want to query them for information about the values that they contain. We might need to find the first element that matches a given set of criteria, validate all values according to a set of requirements, and so on.</p><p>In situations like these, it might initially seem like we always need to write purpose-built algorithms that perform each query using a classic <code>for</code> or <code>while</code> loop, and while that‚Äôs certainly a fine approach in some cases, it often turns out that writing such manual iterations can be quite unnecessary.</p><p>This week, let‚Äôs explore why that is ‚Äî by taking a look at some of the Swift standard library‚Äôs built-in algorithms for querying collections, and how we can compose and combine them to form a nearly infinite number of different queries.</p><h2>Searching for a match</h2><p>Let‚Äôs start by taking a look at a very common type of situation, in which we want to query a collection in order to find the first element that matches a given predicate.</p><p>As an example, let‚Äôs say that we‚Äôre working on a movie recommendation app, and that when the user taps a button for showing the next movie within a given genre, we search a <code>movieQueue</code> array and display the first match ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">func</span> showNextMovie(inGenre genre: <span class="s-type">Genre</span>) {
    <span class="s-keyword">var</span> match: <span class="s-type">Movie</span>?

    <span class="s-keyword">for</span> movie <span class="s-keyword">in</span> movieQueue {
        <span class="s-keyword">if</span> movie.<span class="s-property">genre</span> == genre {
            <span class="s-comment">// We've found our match, so we'll break the iteration</span>
            match = movie
            <span class="s-keyword">break</span>
        }
    }

    <span class="s-keyword">guard let</span> movie = match <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> <span class="s-call">showNoMovieFoundView</span>()
    }

    <span class="s-call">showMovieView</span>(for: movie)
}</code></pre><p>While the above code works, it could definitely be implemented in a more compact way, which in this case should also improve its readability.</p><p>For starters, let‚Äôs get rid of that local <code>match</code> variable, by moving our <code>for</code> loop into its own, dedicated function. Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/pure-functions-in-swift">‚ÄúPure functions in Swift‚Äù</a></em>, structuring logic as functions that simply operate on an input/output basis can often improve our code ‚Äî both in terms of how easy it is to read, as well as how testable our overall system becomes.</p><p>While our new function won‚Äôt be entirely <em>‚Äúpure‚Äù</em> (since it‚Äôll still rely on the state of our <code>movieQueue</code> array), it‚Äôll now simply return the first matching <code>Movie</code> that was found, rather than assigning it to a local variable:</p><pre class="splash"><code><span class="s-keyword">func</span> nextMovie(inGenre genre: <span class="s-type">Genre</span>) -&gt; <span class="s-type">Movie</span>? {
    <span class="s-keyword">for</span> movie <span class="s-keyword">in</span> movieQueue {
        <span class="s-keyword">if</span> movie.<span class="s-property">genre</span> == genre {
            <span class="s-keyword">return</span> movie
        }
    }

    <span class="s-keyword">return nil</span>
}</code></pre><p>With the above in place, we can now heavily simplify our <code>showNextMovie</code> function from before ‚Äî as it now only needs to contain the logic that determines which view that should be shown for the current state of the app:</p><pre class="splash"><code><span class="s-keyword">func</span> showNextMovie(inGenre genre: <span class="s-type">Genre</span>) {
    <span class="s-keyword">guard let</span> movie = <span class="s-call">nextMovie</span>(inGenre: genre) <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> <span class="s-call">showNoMovieFoundView</span>()
    }

    <span class="s-call">showMovieView</span>(for: movie)
}</code></pre><p>However, using the power of the Swift standard library, we can simplify our code even further. If we take a closer look at our <code>nextMovie</code> function and the <code>for</code> loop that it contains, there‚Äôs really nothing about it that‚Äôs specific to movies ‚Äî it simply iterates over an array and returns the first element that matches a given predicate.</p><p>To slightly twist the classic App Store slogan: <em>‚ÄúThere‚Äôs a collection API for that‚Äù</em>. In this case, we can simply replace our custom <code>nextMovie</code> function with a call to the built-in <code>first(where:)</code> method, which lets us pass a predicate to match against. Combine that with the <a href="https://www.swiftbysundell.com/basics/optionals"><code>Optional</code></a> type‚Äôs <code>map</code> method ‚Äî and we can implement our entire <code>showNextMovie</code> function like this instead:</p><pre class="splash"><code><span class="s-keyword">func</span> showNextMovie(inGenre genre: <span class="s-type">Genre</span>) {
    <span class="s-keyword">let</span> movie = movieQueue.<span class="s-call">first</span>(where: { $0.<span class="s-property">genre</span> == genre })
    movie.<span class="s-call">map</span>(showMovieView) ?? <span class="s-call">showNoMovieFoundView</span>()
}</code></pre><p>Just like that, we‚Äôve essentially boiled down a 10+ line algorithm to just two lines of code, by leveraging the standard library‚Äôs built-in APIs and algorithms. Pretty nice!</p><p class="info">There‚Äôs also a <code>last(where:)</code> equivalent to the API used above, as well as <code>firstIndex(where:)</code> and <code>lastIndex(where:)</code> variants that return indexes rather than elements. However, the ‚Äúlast‚Äù variants are only available on collections that conform to the <code>BidirectionalCollection</code> protocol, such as <code>Array</code>.</p><h2>Verifying requirements</h2><p>Not all collection queries are about retrieving an element, though ‚Äî sometimes we might just want to verify that a series of values meet a certain requirement.</p><p>For example, let‚Äôs now say that we‚Äôre working on an app for scheduling and managing events, and that the app includes a feature that lets each participant mark whether they‚Äôre ready for the event to begin. We‚Äôve then extended our app‚Äôs <code>Event</code> model with a method that lets us easily check whether all participants have marked themselves as ready ‚Äî which currently looks like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> isReadyToBegin() -&gt; <span class="s-type">Bool</span> {
        <span class="s-keyword">for</span> participant <span class="s-keyword">in</span> participants {
            <span class="s-keyword">guard</span> participant.<span class="s-property">isReady</span> <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }
        }

        <span class="s-keyword">return true</span>
    }
}</code></pre><p class="info">The reason the above API was implemented as a method, and not a computed property, is because its <a href="https://www.swiftbysundell.com/basics/time-complexity">time complexity</a> isn‚Äôt <code>O(1)</code>. To learn more about that philosophy, check out <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift">‚ÄúComputed properties in Swift‚Äù</a>.</p><p>However, just like before, there‚Äôs a much easier way to implement the above ‚Äî this time by leveraging the standard library‚Äôs <code>allSatisfy</code> API, which (like the name implies) enables us to check whether all of a collection‚Äôs element satisfy a given predicate. Combine that with the fact that <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a> can now be <a href="https://www.swiftbysundell.com/tips/passing-key-paths-as-functions">passed as functions</a>, and we can replace our entire implementation with just a single line of code ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> isReadyToBegin() -&gt; <span class="s-type">Bool</span> {
        participants.<span class="s-call">allSatisfy</span>(\.<span class="s-property">isReady</span>)
    }
}</code></pre><p>With that change in place, the question is whether we still need to keep the above method at all, given that it now simply contains a call to another API. If we‚Äôre only looking to use it in a single place, we might as well just inline the call to <code>allSatisfy</code> directly at the call site ‚Äî however, our above method does add some additional context, as its name makes it crystal clear that we‚Äôre checking whether an event is ready to begin, so it still might make sense to keep it.</p><h2>Minimum and maximum values</h2><p>Next, let‚Äôs take a look at another common type of query ‚Äî computing minimum and maximum values from a series of elements. This time, let‚Äôs say that we‚Äôre building a game, and that we‚Äôd like to add a convenience API for computing the maximum score among an array of players for a given level. If we again start with a manually implemented algorithm, we might write something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Level</span> {
    <span class="s-keyword">func</span> maximumPlayerScore() -&gt; <span class="s-type">Int</span> {
        <span class="s-keyword">var</span> maximumScore = <span class="s-number">0</span>

        <span class="s-keyword">for</span> player <span class="s-keyword">in</span> players {
            maximumScore = <span class="s-call">max</span>(maximumScore, player.<span class="s-property">score</span>)
        }

        <span class="s-keyword">return</span> maximumScore
    }
}</code></pre><p>While the <code>max</code> function that we use above is (along with its <code>min</code> equivalent) incredibly common and can be found in a wide range of programming languages, Swift also includes a variant of it that can be called directly on a collection. All that we have to do to use it is to pass a closure that sorts the collection‚Äôs elements in <em>ascending order</em> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Level</span> {
    <span class="s-keyword">func</span> maximumPlayerScore() -&gt; <span class="s-type">Int</span> {
        <span class="s-comment">// Note that we need to sort the collection in ascending
        // order, which is why we use &lt; to perform our comparsion:</span>
        <span class="s-keyword">let</span> winningPlayer = players.<span class="s-call">max</span> { $0.<span class="s-property">score</span> &lt; $1.<span class="s-property">score</span> }
        <span class="s-keyword">return</span> winningPlayer?.<span class="s-property">score</span> ?? <span class="s-number">0</span>
    }
}</code></pre><p>An alternative approach to the above would be to first sort the <code>players</code> array by each player‚Äôs <code>score</code> property, and then simply pick the first element. However, doing so would be worse in terms of time complexity, since <code>min</code> and <code>max</code> can both be executed in pure linear (<code>O(n)</code>) time, while <code>sort</code> has a time complexity of <code>O(n log n)</code>.</p><h2>Composing custom algorithms</h2><p>So far in this article, we‚Äôve mainly focused on <em>replacing</em> custom collection algorithms with standard library API calls, and while it‚Äôs certainly beneficial to do so whenever possible, that‚Äôs not always the case.</p><p>Let‚Äôs go back to our <code>Event</code> model from before, and take a look at another API that‚Äôs also implemented as a collection query. This one checks whether a set of users are all present within an current event‚Äôs list of participants, and currently looks like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> participantsContain(<span class="s-keyword">_</span> users: <span class="s-type">Set</span>&lt;<span class="s-type">User</span>&gt;) -&gt; <span class="s-type">Bool</span> {
        <span class="s-keyword">for</span> user <span class="s-keyword">in</span> users {
            <span class="s-keyword">guard</span> participants.<span class="s-call">contains</span>(where: { $0.<span class="s-property">userID</span> == user.<span class="s-property">id</span> }) <span class="s-keyword">else</span> {
                <span class="s-keyword">return false</span>
            }
        }

        <span class="s-keyword">return true</span>
    }
}</code></pre><p>While in this case there‚Äôs no equivalent standard library API that we can simply replace the above code with, there‚Äôs still a way in which we could improve it.</p><p>The beauty of the algorithms that come built-in as part of the standard library is that they‚Äôre all very focused and narrow ‚Äî which in turn means that they can often be composed in order to form higher-level logic. So we don‚Äôt need to necessarily find a single API that matches an algorithm as a whole, we simply need to find one match for each of its components.</p><p>Looking at our above algorithm, we‚Äôre already using the <code>contains(where:)</code> API to form our inner loop, while our outer iteration still uses a classic <code>for</code> loop. However, if we take a closer look, it turns out that the outer loop has the exact same shape as the one that we initially used within our <code>isReadyToBegin</code> method from before ‚Äî in that it checks that all elements within the passed set of users satisfy a given requirement.</p><p>While we could now go back to our <code>participantsContain</code> method and refactor our code right there, let‚Äôs in this case implement our logic as a generic algorithm instead ‚Äî by composing <code>allSatsify</code> and <code>contains(where:)</code> into a new method for the <code>Sequence</code> protocol (which all collections and other sequences conform to):</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Sequence</span> {
    <span class="s-keyword">func</span> contains&lt;T: <span class="s-type">Sequence</span>&gt;(
        <span class="s-keyword">_</span> values: <span class="s-type">T</span>,
        matchedBy matcher: (<span class="s-type">Element</span>, <span class="s-type">T</span>.<span class="s-type">Element</span>) -&gt; <span class="s-type">Bool</span>
    ) -&gt; <span class="s-type">Bool</span> {
        values.<span class="s-call">allSatisfy</span> { value <span class="s-keyword">in</span>
            <span class="s-call">contains</span>(where: { <span class="s-call">matcher</span>($0, value) })
        }
    }
}</code></pre><p>With the above in place, we can now go back to our <code>Event</code> type and simply make its <code>participantsContain</code> method call our new API by passing its predicate as a closure ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> participantsContain(<span class="s-keyword">_</span> users: <span class="s-type">Set</span>&lt;<span class="s-type">User</span>&gt;) -&gt; <span class="s-type">Bool</span> {
        participants.<span class="s-call">contains</span>(users, matchedBy: {
            $0.<span class="s-property">userID</span> == $1.<span class="s-property">id</span>
        })
    }
}</code></pre><p>Choosing whether to implement a piece of logic as either a generic algorithm or something that‚Äôs specifically written for a given use case can occasionally be quite difficult. However, a rule of thumb to keep in mind is that whenever our logic is simply a composition of other generic algorithms ‚Äî it probably makes sense for that new algorithm to be generic too.</p><h2>Conclusion</h2><p>The Swift standard library contains a number of incredibly useful algorithms, functions and other APIs ‚Äî and making full use of them not only reduces the amount of code that we need to maintain ourselves, it also lets us build our logic on top of shared code that‚Äôs well-tested and deployed within every single Swift program on the planet.</p><p>There are of course many more Collection APIs than those that were highlighted in this article, so I both recommend checking out the articles covering <a href="https://www.swiftbysundell.com/articles/slicing-swift-collections">slicing</a> and <a href="https://www.swiftbysundell.com/articles/transforming-collections-in-swift">transformations</a> if you haven‚Äôt done so already, and to explore the <a href="https://developer.apple.com/documentation/swift/sequence"><code>Sequence</code></a> and <a href="https://developer.apple.com/documentation/swift/collection"><code>Collection</code></a> protocols yourself ‚Äî chances are high that you‚Äôll find at least one way that one of your algorithms could be simplified.</p><p>Got questions, comments or feedback? You‚Äôre always more than welcome to contact me, either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/podcast/71</guid><title>Podcast: ‚ÄúPolymorphic interfaces‚Äù, with special guest Dave Abrahams</title><description>Dave Abrahams joins John to talk about Protocol-Oriented Programming and how to make the most out of the Swift Standard Library. Also, discussions on Swift‚Äôs overall design, why it puts such a strong emphasis on value types and protocols, and how it‚Äôs been influenced by other languages.</description><link>https://www.swiftbysundell.com/podcast/71</link><pubDate>Thu, 23 Apr 2020 20:57:00 +0200</pubDate><content:encoded><![CDATA[<audio controls><source src="https://traffic.libsyn.com/swiftbysundell/SwiftBySundell71.mp3" type="audio/mpeg"/></audio><p>Dave Abrahams joins John to talk about Protocol-Oriented Programming and how to make the most out of the Swift Standard Library. Also, discussions on Swift‚Äôs overall design, why it puts such a strong emphasis on value types and protocols, and how it‚Äôs been influenced by other languages.</p><h2>Sponsor</h2><p><strong><a href="https://nordvpn.com/sundell">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you‚Äôre on. Get 50% off their one-year plan at <a href="https://nordvpn.com/sundell">nordvpn.com/sundell</a>, or when using offer code <em>SUNDELL</em>.</p><p><em>Interested in advertising on Swift by Sundell? Check out <a href="https://www.swiftbysundell.com/sponsor">this page</a>, or <a href="mailto:sponsor@swiftbysundell.com">get in touch</a> for more information.</em></p><h2>Links</h2><ul><li><a href="https://twitter.com/DaveAbrahams">Dave on Twitter</a></li><li><a href="https://twitter.com/johnsundell">John on Twitter</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/408">Protocol-Oriented Programming in Swift</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/223">Embracing Algorithms</a></li><li><a href="https://en.wikipedia.org/wiki/Alexander_Stepanov">Alexander Stepanov</a></li><li><a href="https://en.wikipedia.org/wiki/Standard_Template_Library">The C++ Standard Template Library</a></li><li><a href="https://www.boost.org">Boost</a></li><li><a href="https://www.swiftbysundell.com/tips/enums-with-custom-raw-types">Enums with custom raw types</a></li><li><a href="https://www.swiftbysundell.com/podcast/58">Previous Swift for TensorFlow episode with Paige Bailey and Brennan Saeta</a></li><li><a href="https://twitter.com/SeanParent">Sean Parent</a></li><li><a href="https://www.haskell.org/tutorial/classes.html">Haskell Type Classes</a></li><li><a href="https://developer.apple.com/documentation/swift/anycollection">AnyCollection</a></li><li><a href="https://www.swiftbysundell.com/articles/specializing-protocols-in-swift">Specializing protocols</a></li><li><a href="https://www.swiftbysundell.com/articles/type-erasure-using-closures-in-swift">Type erasure using closures</a></li><li><a href="https://www.swiftbysundell.com/basics/codable">Codable</a></li><li><a href="https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">‚ÄúThe Genuine Sieve of Eratosthenes‚Äù by Melissa E. O‚ÄôNeill</a></li><li><a href="https://docs.google.com/document/d/1Fm56p5rV1t2Euh6WLtBFKGqI43ozC3EIjReyLk-LCLU">Swift for TensorFlow open design meetings</a></li><li><a href="https://soundcloud.com/banana-drama">Intro and outro music by Dariusz Dziuk</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/enums-with-custom-raw-types</guid><title>Tip: Enums with custom raw types</title><description></description><link>https://www.swiftbysundell.com/tips/enums-with-custom-raw-types</link><pubDate>Wed, 22 Apr 2020 17:15:00 +0200</pubDate><content:encoded><![CDATA[<p>Swift enums are very commonly used to create exhaustive lists of raw values (such as strings or integers) that can then be worked with in a type-safe manner. For example, here‚Äôs how we could define a <code>VideoFormat</code> enum that contains a list of formats based on their file extensions:</p><pre class="splash"><code><span class="s-keyword">enum</span> VideoFormat: <span class="s-type">String</span> {
    <span class="s-keyword">case</span> mp4
    <span class="s-keyword">case</span> webM = <span class="s-string">"webm"</span>
    <span class="s-keyword">case</span> ogg
}</code></pre><p>When declaring a raw value-based enum like the one above, the compiler will automatically make it conform to the <code>RawRepresentable</code> protocol ‚Äî which in turn gives us access to APIs like the <code>init?(rawValue:)</code> initializer, as well as the <code>rawValue</code> property ‚Äî enabling us to easily convert raw values to and from instances of our enum.</p><p>While it might initially seem like that sort of functionality requires an enum‚Äôs raw type to be a built-in one (such as <code>String</code>), it actually works with completely custom ones too ‚Äî as long as they both conform to <code>Equatable</code>, and can be expressed using either a string or numeric literal.</p><p>As an example, let‚Äôs say that we‚Äôre working on an app that uses the following <code>Path</code> type to model file system paths in a more strongly typed manner (compared to always passing raw strings around):</p><pre class="splash"><code><span class="s-keyword">struct</span> Path: <span class="s-type">Equatable</span> {
    <span class="s-keyword">var</span> string: <span class="s-type">String</span>
}</code></pre><p>Now wouldn‚Äôt it be cool if we would be able to define an enum with <code>Path</code>-based raw values? For example in order to specify an exhaustive list of targets for certain file system operations, like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> Target: <span class="s-type">Path</span> {
    <span class="s-keyword">case</span> content
    <span class="s-keyword">case</span> resources
    <span class="s-keyword">case</span> images = <span class="s-string">"resources/images"</span>
}</code></pre><p>The cool thing is that all we need to do to make the above possible is to make our <code>Path</code> type conform to <code>ExpressibleByStringLiteral</code> ‚Äî and the compiler will take care of the rest:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Path</span>: <span class="s-type">ExpressibleByStringLiteral</span> {
    <span class="s-keyword">init</span>(stringLiteral: <span class="s-type">String</span>) {
        string = stringLiteral
    }
}</code></pre><p>The fact that enums can have completely custom raw types is yet another example of how so much of Swift‚Äôs core functionality is implemented using its own type system ‚Äî which in turn makes it possible for our custom types to behave exactly like the built-in ones do.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/mixing-enums-with-other-swift-types</guid><title>Mixing enums with other Swift types</title><description>Swift enums are really powerful, but they can often be made even more capable when mixed with other kinds of Swift types ‚Äî such as protocols and structs. This week, let‚Äôs take a look at a few examples of doing just that.</description><link>https://www.swiftbysundell.com/articles/mixing-enums-with-other-swift-types</link><pubDate>Sun, 19 Apr 2020 21:07:00 +0200</pubDate><content:encoded><![CDATA[<p>One really interesting aspect of Swift is just how many different language features that it supports. While it could definitely be argued that having lots of features at our disposal perhaps makes the language more complex than it needs to be, it‚Äôs also a big part of what makes Swift so flexible when it comes to how we write and structure our code.</p><p>While using <em>all</em> of Swift‚Äôs language features as much as possible is hardly a good goal to have, building a truly great Swift program often comes down to making the best use of each feature that‚Äôs relevant to what we‚Äôre looking to build ‚Äî which often means mixing them in order to best take advantage of what each feature has to offer.</p><p>This week, let‚Äôs take a look at a few examples of doing just that ‚Äî specifically when it comes to how enums can be mixed with some of Swift‚Äôs other features in order to improve the predictability of our logic, while also reducing boilerplate.</p><h2>Eliminating multiple sources of truth</h2><p>One of the most common problems within software engineering in general is logic that relies on <em>multiple sources of truth</em> for a given piece of data ‚Äî especially when those sources might end up contradicting each other, which tends to result in <em>undefined states</em>.</p><p>For example, let‚Äôs say that we‚Äôre working on an app for writing articles, and that we‚Äôd like to use the same data model to represent articles that have been published, as well as unpublished drafts.</p><p>To handle those two cases, we might give our data model an <code>isDraft</code> property that indicates whether it‚Äôs representing a draft, and we‚Äôd also need to turn any data that‚Äôs unique to published articles into optionals ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">Content</span>
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>? <span class="s-comment">// Only assigned to published articles</span>
    <span class="s-keyword">var</span> isDraft: <span class="s-type">Bool</span> <span class="s-comment">// Indicates whether this is a draft</span>
    ...
}</code></pre><p>At first, it might not seem like the above model has multiple sources of truth ‚Äî but it actually does, since whether an article should be considered <em>published</em> could both be determined by looking at whether it has a <code>url</code> assigned to it, or whether its <code>isDraft</code> property is <code>true</code>.</p><p>That may not seem like a big deal, but it could quite quickly lead to inconsistencies across our code base, and it also requires unnecessary boilerplate ‚Äî as each call site has to both check the <code>isDraft</code> flag, and unwrap the optional <code>url</code> property, in order to make sure that its logic is correct.</p><p>This is exactly the type of situation in which Swift‚Äôs enums really shine ‚Äî since they let us model the above kind of variants as explicit states, each of which can carry its own set of data in a non-optional manner ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Article</span> {
    <span class="s-keyword">enum</span> State {
        <span class="s-keyword">case</span> published(<span class="s-type">URL</span>)
        <span class="s-keyword">case</span> draft
    }
}</code></pre><p>What the above enum enables us to do is to replace our previous <code>url</code> and <code>isDraft</code> properties with a new <code>state</code> property ‚Äî which will act as a single source of truth for determining the state of each article:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">Content</span>
    <span class="s-keyword">var</span> state: <span class="s-type">State</span>
}</code></pre><p>With the above in place we can now simply <code>switch</code> on our new <code>state</code> property whenever we need to check whether an article has been published ‚Äî and the code paths for published articles no longer need to deal with any optional URLs. For example, here‚Äôs how we could now conditionally create a <code>UIActivityViewController</code> for sharing published articles:</p><pre class="splash"><code><span class="s-keyword">func</span> makeActivityViewController(
    for article: <span class="s-type">Article</span>
) -&gt; <span class="s-type">UIActivityViewController</span>? {
    <span class="s-keyword">switch</span> article.<span class="s-property">state</span> {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">published</span>(<span class="s-keyword">let</span> url):
        <span class="s-keyword">return</span> <span class="s-type">UIActivityViewController</span>(
            activityItems: [url],
            applicationActivities: <span class="s-keyword">nil</span>
        )
    <span class="s-keyword">case</span> .<span class="s-dotAccess">draft</span>:
        <span class="s-keyword">return nil</span>
    }
}</code></pre><p>However, when making the above kind of structural change to one of our core data models, chances are that we‚Äôll also need to update quite a lot of code that uses that model ‚Äî and we might not be able to perform all of those updates at once.</p><p>Thankfully, it‚Äôs often relatively easy to solve that type of problem through some form of temporary backward compatibility layer ‚Äî which uses our new single source of truth under the hood, while still exposing the same API as we had before to the rest of our code base.</p><p>For example, here‚Äôs how we could let <code>Article</code> temporarily keep its <code>url</code> property until we‚Äôre done migrating all of our code to its new <code>state</code> API:</p><pre class="splash"><code><span class="s-preprocessing">#warning</span>(<span class="s-string">"Temporary backward compatibility. Remove ASAP."</span>)
<span class="s-keyword">extension</span> <span class="s-type">Article</span> {
    <span class="s-keyword">@available</span>(*, deprecated, message: <span class="s-string">"Use state instead"</span>)
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>? {
        <span class="s-keyword">get</span> {
            <span class="s-keyword">switch</span> state {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">draft</span>:
                <span class="s-keyword">return nil
            case</span> .<span class="s-dotAccess">published</span>(<span class="s-keyword">let</span> url):
                <span class="s-keyword">return</span> url
            }
        }
        <span class="s-keyword">set</span> {
            state = newValue.<span class="s-call">map</span>(<span class="s-type">State</span>.<span class="s-property">published</span>) ?? .<span class="s-dotAccess">draft</span>
        }
    }
}</code></pre><p class="info">Above we‚Äôre using both the <code>#warning</code> compiler directive, and the <code>@available</code> attribute, to have the compiler emit warnings both wherever our <code>url</code> property is still used, and to remind us that this extension should be removed as soon as possible.</p><p>So that‚Äôs an example of how we can mix structs and other types with enums in order to establish a single source of truth for our various states. Next, let‚Äôs take a look at how we can go the other way around, and <em>augment</em> some of our enums to make them much more powerful ‚Äî while also reducing our overall number of <code>switch</code> statements in the process.</p><h2>Enums versus protocols</h2><p>Following the above idea of using enums to model distinct states ‚Äî let‚Äôs now say that we‚Äôre working on a drawing app, and that we‚Äôve currently implemented our tool selection code using an enum that contains all of the drawing tools that our app supports:</p><pre class="splash"><code><span class="s-keyword">enum</span> Tool: <span class="s-type">CaseIterable</span> {
    <span class="s-keyword">case</span> pen
    <span class="s-keyword">case</span> brush
    <span class="s-keyword">case</span> fill
    <span class="s-keyword">case</span> text
    ...
}</code></pre><p>Besides the state management aspects, one additional benefit of using an enum in this case is the <code>CaseIterable</code> protocol, which our <code>Tool</code> type conforms to. Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/enum-iterations-in-swift-42">‚ÄúEnum iterations in Swift‚Äù</a></em>, conforming to that protocol makes the compiler automatically generate a static <code>allCases</code> property, which we can then use to easily iterate through all of our cases ‚Äî for example in order to build a toolbox view that contains buttons for each of our drawing tools:</p><pre class="splash"><code><span class="s-keyword">func</span> makeToolboxView() -&gt; <span class="s-type">UIView</span> {
    <span class="s-keyword">let</span> toolbox = <span class="s-type">UIView</span>()

    <span class="s-keyword">for</span> tool <span class="s-keyword">in</span> <span class="s-type">Tool</span>.<span class="s-property">allCases</span> {
        <span class="s-comment">// Add a button for selecting the tool</span>
        ...
    }

    <span class="s-keyword">return</span> toolbox
}</code></pre><p>However, as neat as it is to have all of our tools gathered within a single type, that setup does come with a quite major disadvantage in this case.</p><p>Since all of our tools are likely going to need a fair amount of logic, and using an enum requires us to implement all of that logic within a single place, we‚Äôll probably end up with series of increasingly complex <code>switch</code> statements ‚Äî looking something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Tool</span> {
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">pen</span>:
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">brush</span>:
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">fill</span>:
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">text</span>:
            ...
        ...
        }
    }
    
    <span class="s-keyword">var</span> name: <span class="s-type">String</span> {
        <span class="s-keyword">switch self</span> {
        ...
        }
    }

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>) {
        <span class="s-keyword">switch self</span> {
        ...
        }
    }
}</code></pre><p>Another issue with our current approach is that it makes it quite difficult to store tool-specific states ‚Äî since enums that conform to <code>CaseIterable</code> can‚Äôt carry any associated values.</p><p>To address both of the above two problems, let‚Äôs instead try to implement each of our tools using a protocol ‚Äî which would give us a shared interface, while still enabling each tool to be declared and implemented in isolation:</p><pre class="splash"><code><span class="s-comment">// A protocol that acts as a shared interface for each of our tools:</span>
<span class="s-keyword">protocol</span> Tool {
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> name: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>)
}

<span class="s-comment">// Simpler tools can just implement the required properties, as well
// as the 'apply' method for performing their drawing:</span>
<span class="s-keyword">struct</span> PenTool: <span class="s-type">Tool</span> {
    <span class="s-keyword">let</span> icon = <span class="s-type">Icon</span>.<span class="s-property">pen</span>
    <span class="s-keyword">let</span> name = <span class="s-string">"Draw using a pen"</span>

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>) {
        ...
    }
}

<span class="s-comment">// More complex tools are now free to declare their own state properties,
// which could then be used within their drawing code:</span>
<span class="s-keyword">struct</span> TextTool: <span class="s-type">Tool</span> {
    <span class="s-keyword">let</span> icon = <span class="s-type">Icon</span>.<span class="s-property">letter</span>
    <span class="s-keyword">let</span> name = <span class="s-string">"Add text"</span>

    <span class="s-keyword">var</span> font = <span class="s-type">UIFont</span>.<span class="s-call">systemFont</span>(ofSize: <span class="s-type">UIFont</span>.<span class="s-property">systemFontSize</span>)
    <span class="s-keyword">var</span> characterSpacing: <span class="s-type">CGFloat</span> = <span class="s-number">0</span>

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>) {
        ...
    }
}</code></pre><p>However, while the above change enables us to fully decouple our various <code>Tool</code> implementations, we‚Äôve also lost one of the major benefits of our enum-based approach ‚Äî that we could easily iterate over each tool by using <code>Tool.allCases</code>.</p><p>While we <em>could</em> sort of achieve the same thing using a manually implemented function (or use some form of code generation), that‚Äôs extra code that we‚Äôd have to maintain and keep in sync with our various <code>Tool</code> types ‚Äî which isn‚Äôt ideal:</p><pre class="splash"><code><span class="s-keyword">func</span> allTools() -&gt; [<span class="s-type">Tool</span>] {
    <span class="s-keyword">return</span> [
        <span class="s-type">PenTool</span>(),
        <span class="s-type">BrushTool</span>(),
        <span class="s-type">FillTool</span>(),
        <span class="s-type">TextTool</span>()
        ...
    ]
}</code></pre><p>But what if we didn‚Äôt have to make a choice <em>between</em> protocols and enums, and instead could mix them to sort of achieve the best of both worlds?</p><h2>Enum on the outside, protocol on the inside</h2><p>Let‚Äôs revert our <code>Tool</code> type back to being an enum, but rather than again implementing all of our logic as methods and properties full of <code>switch</code> statements ‚Äî let‚Äôs instead keep those implementations protocol-oriented, only this time we‚Äôll make them <em>controllers for our tools</em>, rather than being model representations of the tools themselves.</p><p>Using our previous <code>Tool</code> protocol as a starting point, let‚Äôs define a new protocol called <code>ToolController</code>, which ‚Äî along with our previous requirements ‚Äî includes a method that lets each tool provide and manage its own options view. That way, we can end up with a truly decoupled architecture, in which each controller completely manages the logic and UI required for each given tool:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ToolController {
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> name: <span class="s-type">String</span> { <span class="s-keyword">get</span> }

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>)
    <span class="s-keyword">func</span> makeOptionsView() -&gt; <span class="s-type">UIView</span>?
}</code></pre><p>Going back to our <code>TextTool</code> implementation from before, here‚Äôs how we could modify it to instead become a <code>TextToolController</code> that conforms to our new protocol:</p><pre class="splash"><code><span class="s-keyword">class</span> TextToolController: <span class="s-type">ToolController</span> {
    <span class="s-keyword">let</span> icon = <span class="s-type">Icon</span>.<span class="s-property">letter</span>
    <span class="s-keyword">let</span> name = <span class="s-string">"Add text"</span>

    <span class="s-keyword">private var</span> font = <span class="s-type">UIFont</span>.<span class="s-call">systemFont</span>(ofSize: <span class="s-type">UIFont</span>.<span class="s-property">systemFontSize</span>)
    <span class="s-keyword">private var</span> characterSpacing: <span class="s-type">CGFloat</span> = <span class="s-number">0</span>

    <span class="s-keyword">func</span> apply(at point: <span class="s-type">CGPoint</span>, on canvas: <span class="s-type">Canvas</span>) {
        ...
    }

    <span class="s-keyword">func</span> makeOptionsView() -&gt; <span class="s-type">UIView</span>? {
        <span class="s-keyword">let</span> view = <span class="s-type">UIView</span>()

        <span class="s-keyword">let</span> characterSpacingStepper = <span class="s-type">UIStepper</span>()
        view.<span class="s-call">addSubview</span>(characterSpacingStepper)

        <span class="s-comment">// When creating our tool-specific options view, our
        // controller can now reference its own instance methods
        // and properties, just like a view controller would:</span>
        characterSpacingStepper.<span class="s-call">addTarget</span>(<span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(handleCharacterSpacingStepper),
            for: .<span class="s-dotAccess">valueChanged</span>
        )
        
        ...

        <span class="s-keyword">return</span> view
    }
    
    ...
}</code></pre><p>Then, rather than having our <code>Tool</code> enum contain any actual logic, we‚Äôll just give it a single method for creating a <code>ToolController</code> corresponding to its current state ‚Äî saving us the trouble of having to write all those <code>switch</code> statements that we had before, while still enabling us to make full use of <code>CaseIterable</code>:</p><pre class="splash"><code><span class="s-keyword">enum</span> Tool: <span class="s-type">CaseIterable</span> {
    <span class="s-keyword">case</span> pen
    <span class="s-keyword">case</span> brush
    <span class="s-keyword">case</span> fill
    <span class="s-keyword">case</span> text
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">Tool</span> {
    <span class="s-keyword">func</span> makeController() -&gt; <span class="s-type">ToolController</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">pen</span>:
            <span class="s-keyword">return</span> <span class="s-type">PenToolController</span>()
        <span class="s-keyword">case</span> .<span class="s-dotAccess">brush</span>:
            <span class="s-keyword">return</span> <span class="s-type">BrushToolController</span>()
        <span class="s-keyword">case</span> .<span class="s-dotAccess">fill</span>:
            <span class="s-keyword">return</span> <span class="s-type">FillToolController</span>()
        <span class="s-keyword">case</span> .<span class="s-dotAccess">text</span>:
            <span class="s-keyword">return</span> <span class="s-type">TextToolController</span>()
        ...
        }
    }
}</code></pre><p class="info">An alternative to the above approach would be to create a dedicated <code>ToolControllerFactory</code>, rather than having <code>Tool</code> itself create our controllers. To learn more about that pattern, check out <a href="https://www.swiftbysundell.com/tags/the-factory-pattern">this page</a>.</p><p>Finally, putting all of the pieces together, we‚Äôll now be able to both easily iterate over each tool in order to build our toolbox view, and trigger the current tool‚Äôs logic by communicating with its <code>ToolController</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> CanvasViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private var</span> tool = <span class="s-type">Tool</span>.<span class="s-call">pen</span> {
        <span class="s-keyword">didSet</span> { controller = tool.<span class="s-call">makeController</span>() }
    }
    <span class="s-keyword">private lazy var</span> controller = tool.<span class="s-call">makeController</span>()
    <span class="s-keyword">private let</span> canvas = <span class="s-type">Canvas</span>()
    
    ...
    
    <span class="s-keyword">private func</span> makeToolboxView() -&gt; <span class="s-type">UIView</span> {
        <span class="s-keyword">let</span> toolbox = <span class="s-type">UIView</span>()
    
        <span class="s-keyword">for</span> tool <span class="s-keyword">in</span> <span class="s-type">Tool</span>.<span class="s-property">allCases</span> {
            <span class="s-comment">// Add a button for selecting the tool</span>
            ...
        }
    
        <span class="s-keyword">return</span> toolbox
    }

    <span class="s-keyword">private func</span> handleTapRecognizer(<span class="s-keyword">_</span> recognizer: <span class="s-type">UITapGestureRecognizer</span>) {
        <span class="s-comment">// Handling taps on the canvas using the current tool's controller:</span>
        <span class="s-keyword">let</span> location = recognizer.<span class="s-call">location</span>(in: view)
        controller.<span class="s-call">apply</span>(at: location, on: canvas)
    }
    
    ...
}</code></pre><p>The beauty of the above approach is that it enables us to fully decouple our logic, while still establishing a single source of truth for all of our states and variants. We could‚Äôve also chosen to split our code up a bit differently, for example to keep each tool‚Äôs <code>icon</code> and <code>name</code> within our enum, and only move our actual logic out to our <code>ToolController</code> implementations ‚Äî but that‚Äôs always something we could tweak going forward.</p><h2>Conclusion</h2><p>While it sometimes might seem like we always need to pick just a single type of abstraction within each given situation, we can often achieve some really interesting results when combining and mixing several of Swift‚Äôs language features into a single solution ‚Äî for example by combining the predictability of enums with the flexibility of protocols.</p><p>What do you think? Have you ever mixed enums with Swift‚Äôs other features and types in order to solve a specific problem? Let me know ‚Äî along with your questions, feedback and comments ‚Äî either <a href="https://www.swiftbysundell.com/contact">via email</a> or on <a href="https://twitter.com/johnsundell">Twitter</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/combine</guid><title>Basics: Combine</title><description>Combine is a really powerful reactive programming framework from Apple, but getting started with it can be quite difficult, so let‚Äôs go through the basics of its API and its core concepts.</description><link>https://www.swiftbysundell.com/basics/combine</link><pubDate>Thu, 16 Apr 2020 14:20:00 +0200</pubDate><content:encoded><![CDATA[<p>Introduced during WWDC 2019, Apple‚Äôs Combine framework lets us model all sorts of asynchronous events and operations as <em>‚Äúvalues over time‚Äù</em>. While that‚Äôs a phrase that‚Äôs commonly used within the <em>reactive programming</em> world, as a concept and way of constructing logic, it can initially be quite difficult to fully grasp.</p><p>So in this article, let‚Äôs take a look at the basics of Combine, what some of the core principles of reactive programming are, and how they can become really useful in practice.</p><p>Let‚Äôs start with <em>Publishers</em>, which are observable objects that emit values whenever a given event occurred. Publishers can either be active indefinitely or eventually be completed, and can also optionally fail when an error was encountered.</p><p>When introducing Combine, Apple also went through some of their core libraries in order to retrofit them with Combine support. For example, here‚Äôs how we could use Foundation‚Äôs <code>URLSession</code> type to create a publisher for making a <a href="https://www.swiftbysundell.com/basics/networking">network request</a> to a given URL:</p><pre class="splash"><code><span class="s-keyword">let</span> url = <span class="s-type">URL</span>(string: <span class="s-string">"https://api.github.com/repos/johnsundell/publish"</span>)!
<span class="s-keyword">let</span> publisher = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTaskPublisher</span>(for: url)</code></pre><p>Once we‚Äôve created a publisher, we can then attach <em>subscriptions</em> to it, for example by using the <code>sink</code> API ‚Äî which lets us pass a closure to be called whenever a new value was received, as well as one that‚Äôll be called once the publisher was completed:</p><pre class="splash"><code><span class="s-keyword">let</span> cancellable = publisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in</span>
        <span class="s-comment">// Called once, when the publisher was completed.</span>
        <span class="s-call">print</span>(completion)
    },
    receiveValue: { value <span class="s-keyword">in</span>
        <span class="s-comment">// Can be called multiple times, each time that a
        // new value was emitted by the publisher.</span>
        <span class="s-call">print</span>(value)
    }
)</code></pre><p>Note how our above call to <code>sink</code> returns a value that we store as <code>cancellable</code>. When attaching a new subscriber, a Combine publisher always returns an object that conforms to the <code>Cancellable</code> <a href="https://www.swiftbysundell.com/basics/protocols">protocol</a>, which acts as a <em>token</em> for the new subscription. We then need to retain that token for as long as we want the subscription to remain active, since once it gets <a href="https://www.swiftbysundell.com/basics/memory-management">deallocated</a>, our subscription will automatically get cancelled (we can also cancel it manually by calling <code>cancel()</code> on the token).</p><p>Next, let‚Äôs fill in our above closures with a bit more logic, starting with the one for <code>receiveCompletion</code>, which will get passed an <a href="https://www.swiftbysundell.com/basics/enums">enum</a> containing two cases ‚Äî one for any error that was encountered, and one for when the publisher successfully completed:</p><pre class="splash"><code><span class="s-keyword">let</span> cancellable = publisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in
        switch</span> completion {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
            <span class="s-call">print</span>(error)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
            <span class="s-call">print</span>(<span class="s-string">"Success"</span>)
        }
    },
    receiveValue: { value <span class="s-keyword">in</span>
        <span class="s-call">print</span>(value)
    }
)</code></pre><p>Before we start filling in our <code>receiveValue</code> closure, let‚Äôs define a simple data model that we‚Äôll decode our downloaded data into. Since we‚Äôre using a URL that points to a GitHub API endpoint for a repository (<a href="https://github.com/johnsundell/publish">Publish</a>, to be exact), let‚Äôs declare our model as a <a href="https://www.swiftbysundell.com/basics/codable"><code>Codable</code></a> struct that has two properties can be found in the JSON that we‚Äôll download:</p><pre class="splash"><code><span class="s-keyword">struct</span> Repository: <span class="s-type">Codable</span> {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
}</code></pre><p>With the above model in place, let‚Äôs now implement our <code>receiveValue</code> logic ‚Äî in which we‚Äôll create a <code>JSONDecoder</code> in order to decode the data that was downloaded into a <code>Repository</code> value, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> cancellable = publisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in
        switch</span> completion {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
            <span class="s-call">print</span>(error)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
            <span class="s-call">print</span>(<span class="s-string">"Success"</span>)
        }
    },
    receiveValue: { value <span class="s-keyword">in
        let</span> decoder = <span class="s-type">JSONDecoder</span>()

        <span class="s-keyword">do</span> {
            <span class="s-comment">// Since each value passed into our closure will be a tuple
            // containing the downloaded data, as well as the network
            // response itself, we're accessing the 'data' property here:</span>
            <span class="s-keyword">let</span> repo = <span class="s-keyword">try</span> decoder.<span class="s-call">decode</span>(<span class="s-type">Repository</span>.<span class="s-keyword">self</span>, from: value.<span class="s-property">data</span>)
            <span class="s-call">print</span>(repo)
        } <span class="s-keyword">catch</span> {
            <span class="s-call">print</span>(error)
        }
    }
)</code></pre><p>While the above works, we‚Äôve sort of written our code the same way as we would when using a standard closure-based API ‚Äî in that we‚Äôre nesting our logic within completion handlers. There‚Äôs nothing wrong with that, but the true power of Combine (and reactive programming in general) lies in constructing <em>chains of operations</em> that our data gets streamed through.</p><p>To get started, let‚Äôs take a look at the <code>map</code> operator, which works the same way as it <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap">does on collections</a> ‚Äî as it lets us transform each value that a publisher emits into a new form. Such a transform can be as simple as accessing a property on each value ‚Äî for example, here we‚Äôre transforming each of our network result values by extracting their <code>data</code> property, which now gives us a publisher that emits <code>Data</code> values instead:</p><pre class="splash"><code><span class="s-keyword">let</span> dataPublisher = publisher.<span class="s-call">map</span>(\.<span class="s-property">data</span>)</code></pre><p class="info">Above we‚Äôre accessing the <code>data</code> property using a key path, which you can read more about in <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">‚ÄúThe power of key paths in Swift‚Äù</a>.</p><p>Besides <code>map</code>, Combine also ships with a number of other operators that we can use to transform our data in various ways. It even includes an operator that lets us decode our data directly within our chain ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">let</span> repoPublisher = publisher
    .<span class="s-call">map</span>(\.<span class="s-property">data</span>)
    .<span class="s-call">decode</span>(
        type: <span class="s-type">Repository</span>.<span class="s-keyword">self</span>,
        decoder: <span class="s-type">JSONDecoder</span>()
    )</code></pre><p>While we started out with a publisher that was emitting <code>(Data, URLResponse)</code> values, through our above chain, we‚Äôve now transformed that publisher into one that emits <code>Repository</code> values directly ‚Äî which lets us heavily simplify our subscription code, as we no longer need to perform any form of data decoding within our closures:</p><pre class="splash"><code><span class="s-keyword">let</span> cancellable = repoPublisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in
        switch</span> completion {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
            <span class="s-call">print</span>(error)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
            <span class="s-call">print</span>(<span class="s-string">"Success"</span>)
        }
    },
    receiveValue: { repo <span class="s-keyword">in</span>
        <span class="s-call">print</span>(repo)
    }
)</code></pre><p class="info">A general rule of thumb is to try to keep all subscription closures as simple as possible ‚Äî and to instead construct the above sort of reactive chains that our data can flow through in order to get transformed into its final form.</p><p>Since Combine is primarily used to handle asynchronous events and values, it‚Äôs quite common to run into threading issues when using it ‚Äî especially when we want to use a received value within our UI code. Since Apple‚Äôs UI frameworks (UIKit, AppKit, SwiftUI, etc.) can ‚Äî for the most part ‚Äî only be updated from the <em><a href="https://www.swiftbysundell.com/basics/grand-central-dispatch">main thread</a></em>, we‚Äôre going to run into issues when writing code like this:</p><pre class="splash"><code><span class="s-comment">// Two labels that we want to render our data using:</span>
<span class="s-keyword">let</span> nameLabel = <span class="s-type">UILabel</span>()
<span class="s-keyword">let</span> errorLabel = <span class="s-type">UILabel</span>()

<span class="s-keyword">let</span> cancellable = repoPublisher.<span class="s-call">sink</span>(
    receiveCompletion: { completion <span class="s-keyword">in
        switch</span> completion {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
            <span class="s-comment">// Rendering a description of the error that was encountered:</span>
            errorLabel.<span class="s-property">text</span> = error.<span class="s-property">localizedDescription</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>:
            <span class="s-keyword">break</span>
        }
    },
    receiveValue: { repo <span class="s-keyword">in</span>
        <span class="s-comment">// Rendering the downloaded repository's name:</span>
        nameLabel.<span class="s-property">text</span> = repo.<span class="s-property">name</span>
    }
)</code></pre><p>The problem is that, since <code>URLSession</code> performs its work on a background thread, our subscriptions will also be triggered on that same background thread by default ‚Äî which in turn makes us violate the rule of only performing UI updates on the main thread.</p><p>The good news is that it‚Äôs really easy to fix the above sort of issues when using Combine, as it also includes an operator that lets us switch which thread (or <a href="https://www.swiftbysundell.com/clips/2"><code>DispatchQueue</code></a>) that a publisher will emit its events on ‚Äî which we in this case can use to jump over to the <code>main</code> queue, and thus, the main thread:</p><pre class="splash"><code><span class="s-keyword">let</span> repoPublisher = publisher
    .<span class="s-call">map</span>(\.<span class="s-property">data</span>)
    .<span class="s-call">decode</span>(
        type: <span class="s-type">Repository</span>.<span class="s-keyword">self</span>,
        decoder: <span class="s-type">JSONDecoder</span>()
    )
    .<span class="s-call">receive</span>(on: <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>)</code></pre><p>So that‚Äôs the basics of using Combine to subscribe to a publisher, and using operators to transform its values. Next, let‚Äôs take a look at how we can create our very own publishers as well, and a few things that can be good to keep in mind when doing that.</p><p>Let‚Äôs say that we‚Äôre working on a simple <code>Counter</code> class that keeps track of a value that can be incremented by calling an <code>increment()</code> method ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> Counter {
    <span class="s-comment">// Using 'private(set)', we ensure that our value can only
    // be modified within the Counter class itself, while still
    // enabling external code to read it:</span>
    <span class="s-keyword">private(set) var</span> value = <span class="s-number">0</span>

    <span class="s-keyword">func</span> increment() {
        value += <span class="s-number">1</span>
    }
}</code></pre><p>Now let‚Äôs make it possible to use Combine to subscribe to changes in our counter‚Äôs value. To get started, we could use Combine‚Äôs built-in <code>PassthroughSubject</code> type, which both acts as a publisher, and as a <em>subject</em> ‚Äî an object that new values can be <em>sent</em> using:</p><pre class="splash"><code><span class="s-keyword">class</span> Counter {
    <span class="s-keyword">let</span> publisher = <span class="s-type">PassthroughSubject</span>&lt;<span class="s-type">Int</span>, <span class="s-type">Never</span>&gt;()

    <span class="s-keyword">private(set) var</span> value = <span class="s-number">0</span> {
        <span class="s-comment">// Whenever our property was set, we send its new value
        // to our subject/publisher:</span>
        <span class="s-keyword">didSet</span> { publisher.<span class="s-call">send</span>(value) }
    }

    <span class="s-keyword">func</span> increment() {
        value += <span class="s-number">1</span>
    }
}</code></pre><p class="info">We‚Äôre using <code>Never</code> as our publisher‚Äôs error type, which means that it‚Äôll never be able to throw any errors ‚Äî which is perfect in this case, since we‚Äôre only sending new <code>Int</code> values to it.</p><p>With the above in place, we can now subscribe to our new publisher just like we did earlier when performing network requests using <code>URLSession</code> ‚Äî for example like this:</p><pre class="splash"><code><span class="s-keyword">let</span> counter = <span class="s-type">Counter</span>()

<span class="s-keyword">let</span> cancellable = counter.<span class="s-property">publisher</span>
    .<span class="s-call">filter</span> { $0 &gt; <span class="s-number">2</span> }
    .<span class="s-call">sink</span> { value <span class="s-keyword">in</span>
        <span class="s-call">print</span>(value)
    }

<span class="s-comment">// Since we're filtering out all values below 3, only our final
// increment call will result in a value being printed:</span>
counter.<span class="s-call">increment</span>()
counter.<span class="s-call">increment</span>()
counter.<span class="s-call">increment</span>()</code></pre><p class="info">Note how we‚Äôre able to just pass a single closure into our above call to <code>sink</code>, since our publisher can‚Äôt throw any errors, which means that we don‚Äôt need to handle its completion event (if we don‚Äôt want to).</p><p>However, while the above approach works, it does come with a quite major downside. Since our <code>PassthroughSubject</code> is both a publisher and a subject, any code can send new values to it, even if that code lives outside of our <code>Counter</code> class ‚Äî simply by calling <code>send()</code>:</p><pre class="splash"><code>counter.<span class="s-property">publisher</span>.<span class="s-call">send</span>(<span class="s-number">17</span>)</code></pre><p>That isn‚Äôt great, as ideally we‚Äôd like to enforce that only <code>Counter</code> can send new values ‚Äî to avoid <em>multiple sources of truth</em>. Thankfully, that can quite easily be done, by creating two separate properties ‚Äî one that only exposes the <em>publisher part</em> of our <code>PassthroughSubject</code>, and a private one that lets us access it as a <em>subject</em> as well:</p><pre class="splash"><code><span class="s-keyword">class</span> Counter {
    <span class="s-keyword">var</span> publisher: <span class="s-type">AnyPublisher</span>&lt;<span class="s-type">Int</span>, <span class="s-type">Never</span>&gt; {
        <span class="s-comment">// Here we're "erasing" the information of which type
        // that our subject actually is, only letting our outside
        // code know that it's a read-only publisher:</span>
        subject.<span class="s-call">eraseToAnyPublisher</span>()
    }

    <span class="s-keyword">private(set) var</span> value = <span class="s-number">0</span> {
        <span class="s-keyword">didSet</span> { subject.<span class="s-call">send</span>(value) }
    }

    <span class="s-comment">// By storing our subject in a private property, we'll only
    // be able to send new values to it from within this class:</span>
    <span class="s-keyword">private let</span> subject = <span class="s-type">PassthroughSubject</span>&lt;<span class="s-type">Int</span>, <span class="s-type">Never</span>&gt;()

    <span class="s-keyword">func</span> increment() {
        value += <span class="s-number">1</span>
    }
}</code></pre><p>Much better. We now have a strong guarantee that the values that our publisher will emit will always be completely in-sync with the actual state of our <code>Counter</code> class.</p><p>Another option that would let us achieve the same thing would be to use the <code>@Published</code> property wrapper ‚Äî check out <em><a href="https://www.swiftbysundell.com/articles/published-properties-in-swift">‚ÄúPublished properties in Swift‚Äù</a></em> for more info on that approach.</p><p>To recap, these are five of the key pieces of Combine‚Äôs overall terminology:</p><ul><li>A <em>publisher</em> is an observable object that emits values over time, and that can also optionally complete either when no more values are available, or when it encountered an error.</li><li>Objects or closures that are used to observe a publisher are referred to as <em>subscribers</em>.</li><li>A <em>subject</em> is a <em>mutable</em> object that can be used to send new values through a publisher. Types like <code>PassthroughSubject</code> act as both publishers and subjects.</li><li><em>Operators</em> are used to build reactive chains or pipelines that our data can flow through, where each operator applies some form of transform to the data that was sent to it.</li><li>A <em>cancellable</em> is used to keep track of a subscription to a given publisher, and needs to be retained for as long as we want that subscription to remain active.</li></ul><p>Combine is an exciting framework that lets us use the power of reactive programming without having to bring in any third-party dependencies ‚Äî which in turn enables us to construct logic that automatically <em>reacts</em> to changes in values over time.</p><p>While this article only covered the very basics of Combine, I hope that you found it useful, and we‚Äôll dive into much more advanced ways of using Combine within the <a href="https://www.swiftbysundell.com/articles">main weekly article series</a> over the coming months and years.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/sponsor/instabug-april-2020</guid><title>Sponsor: Instabug</title><description>Thanks a lot to Instabug for sponsoring Swift by Sundell.</description><link>https://www.swiftbysundell.com/sponsor/instabug-april-2020</link><pubDate>Wed, 15 Apr 2020 14:20:00 +0200</pubDate><content:encoded><![CDATA[<p>My thanks to <a href="https://instabug.com/sdk?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-april-13">Instabug</a> for sponsoring Swift by Sundell for another two weeks, helping me keep the site free and open to everyone.</p><p>People often ask me for recommendations as to which crash reporter to use for an iOS app ‚Äî and for me that‚Äôs an easy decision ‚Äî Instabug is not only an incredibly powerful crash reporter, it also has a ton of other useful features, and a strong focus on both privacy and security.</p><p>With Instabug, you can let your testers and users easily report bugs and issues, and ask you questions, right from within the app itself. And, when those reports instantly appear within your Instabug dashboard, they‚Äôll also contain all sorts of useful debugging information and reproduction steps ‚Äî so that you can fix those issues in record time.</p><p>You‚Äôll also get performance monitoring, in-app surveys, intelligent grouping for all crash and bug reports, detailed stack traces, network request logs, and so much more ‚Äî all in a single, easy to use SDK. It‚Äôs <a href="https://instabug.com/sdk?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-april-13">free to try</a>, and only takes a minute to integrate.</p><p><a href="https://instabug.com/sdk?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q220-april-13">Try Instabug for free and support Swift by Sundell</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/published-properties-in-swift</guid><title>Published properties in Swift</title><description>This week, let‚Äôs explore the topic of published properties, by reimplementing Combine‚Äôs @Published property wrapper with support for earlier versions of Apple‚Äôs operating systems.</description><link>https://www.swiftbysundell.com/articles/published-properties-in-swift</link><pubDate>Sun, 12 Apr 2020 21:50:00 +0200</pubDate><content:encoded><![CDATA[<p>Reactive programming has become increasingly popular within the Apple developer community over the last few years, and the introduction of Apple‚Äôs own Combine framework during WWDC 2019 is likely going to further accelerate that growth in popularity for years to come.</p><p>Part of the magic of Combine is that it isn‚Äôt <em>just</em> another reactive programming framework. While it does use patterns and APIs that are very similar to other reactive frameworks, such as RxSwift and ReactiveSwift, it also makes heavy use of several new Swift features (as well as a dash of compiler magic) to make reactive programming more approachable in a few key ways.</p><p>However, using Combine requires us to drop support for Apple‚Äôs previous OS versions, which is many cases might be somewhat of a ‚Äúdeal breaker‚Äù. So this week, let‚Äôs take a look at one of Combine‚Äôs more interesting aspects ‚Äî published properties ‚Äî and how it‚Äôs definitely possible to adopt that pattern even without access to Combine itself.</p><h2>The magic of observable objects</h2><p>Apart from being a stand-alone framework, Combine also plays a very important role in the declarative machinery that powers SwiftUI ‚Äî especially when it comes to how the system can automatically re-render parts of our UI when its underlying data changes.</p><p>A key part of that system is the <code>ObservableObject</code> protocol, which enables us to mark any class as being <em>observable</em>. That, along with the <code>@Published</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a>, lets us easily construct types that emit signals whenever some of their properties were changed.</p><p>For example, here‚Äôs how we could use those two tools to define a <code>ProfileViewModel</code> which notifies its observers whenever its <code>state</code> was modified:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewModel: <span class="s-type">ObservableObject</span> {
    <span class="s-keyword">enum</span> State {
        <span class="s-keyword">case</span> isLoading
        <span class="s-keyword">case</span> failed(<span class="s-type">Error</span>)
        <span class="s-keyword">case</span> loaded(<span class="s-type">User</span>)
    }

    <span class="s-comment">// Simply marking a property with the @Published property wrapper
    // is enough to make the system emit observable events whenever
    // a new value was assigned to it.</span>
    <span class="s-keyword">@Published private(set) var</span> state = <span class="s-type">State</span>.<span class="s-property">isLoading</span>
    
    ...
}</code></pre><p>The above is really all that it takes to make an object observable through Combine ‚Äî which is quite remarkable ‚Äî as the compiler will automatically synthesize an <code>objectWillChange</code> publisher (a Combine object which can be observed), and all of the code needed to bind our <code>@Published</code>-marked properties to that publisher.</p><p>When using SwiftUI, we can then use another property wrapper, <code>@ObservedObject</code>, to in turn bind any <code>ObservableObject</code> to our UI ‚Äî which will make SwiftUI update our view on every change to that object‚Äôs published properties:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProfileView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">ProfileViewModel</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-comment">// Construct our UI based on the current state</span>
        ...
    }
}</code></pre><p>However, since Combine isn‚Äôt <em>just</em> a part of SwiftUI, but also a completely stand-alone framework, we can also use it within other contexts as well ‚Äî for example when using UIKit or AppKit to build our UI.</p><p>While we won‚Äôt get those nice declarative data bindings for free outside of SwiftUI, we can still use the power of Combine itself by subscribing to any observable object‚Äôs <code>objectWillChange</code> publisher directly ‚Äî and then update our UI accordingly, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> viewModel: <span class="s-type">ProfileViewModel</span>
    <span class="s-keyword">private var</span> cancellable: <span class="s-type">AnyCancellable</span>?

    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        cancellable = viewModel.<span class="s-property">objectWillChange</span>.<span class="s-call">sink</span> { [<span class="s-keyword">weak self</span>] <span class="s-keyword">in
            self</span>?.<span class="s-call">render</span>()
        }
    }

    <span class="s-keyword">private func</span> render() {
        <span class="s-keyword">switch</span> viewModel.<span class="s-property">state</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">isLoading</span>:
            <span class="s-comment">// Show loading spinner</span>
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">failed</span>(<span class="s-keyword">let</span> error):
            <span class="s-comment">// Show error view</span>
            ...
        <span class="s-keyword">case</span> .<span class="s-dotAccess">loaded</span>(<span class="s-keyword">let</span> user):
            <span class="s-comment">// Show user's profile</span>
            ...
        }
    }
}</code></pre><p class="info">Note that we need to keep track of the cancellable object that Combine returns when we start our subscription using <code>sink</code>, since that subscription will only remain valid for as long as the returned <code>AnyCancellable</code> instance is retained.</p><p>However, there is one major issue with our above implementation ‚Äî and that‚Äôs that our observation will be triggered <em>before</em> our view model is updated, given that we‚Äôre subscribing to its <code>objectWillChange</code> publisher. That means that we‚Äôll always render our view model‚Äôs <em>previous</em> state, rather than the new one, which isn‚Äôt great.</p><p>Thankfully, there is one more built-in way that we can observe our view model, without having to write any custom observation code ‚Äî and that‚Äôs by attaching our subscription to the <code>state</code> property itself.</p><p>To do that, we‚Äôre going to access the <code>@Published</code> property wrapper‚Äôs <em><a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift/%23projected-values">projected value</a></em> (by prefixing its name with <code>$</code>), which gives us access to a Combine publisher just for that property. We can then subscribe to that publisher using the same <code>sink</code> API as before ‚Äî only this time our closure will get passed the property‚Äôs <em>new value</em>, which makes our rendering code work as we‚Äôd expect:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        cancellable = viewModel.<span class="s-property">$state</span>.<span class="s-call">sink</span> { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in
            self</span>?.<span class="s-call">render</span>(state)
        }
    }

    <span class="s-keyword">private func</span> render(<span class="s-keyword">_</span> state: <span class="s-type">ProfileViewModel</span>.<span class="s-type">State</span>) {
        ...
    }
}</code></pre><p>So Combine can be an incredibly useful tool even outside the realm of SwiftUI ‚Äî as it enables us to set up custom data flows and bindings, while still taking advantage of <code>ObservableObject</code> and the very lightweight way in which it enables us to make our models (and other types) observable.</p><h2>Just a backport away</h2><p>However, the issue remains that Combine is only available on the (at the time of writing) latest major versions of Apple‚Äôs various operating systems. On one hand, that‚Äôs definitely to be expected, as that‚Äôs always the case for frameworks that ship as part of the operating systems themselves. But on the other hand, it‚Äôs a bit of a shame that we‚Äôll potentially have to wait years until we can start adopting Combine‚Äôs various patterns. <em>Or do we?</em></p><p>After all, Combine is just Swift code (at least on the surface level), the property wrappers feature that <code>@Published</code> is implemented with is a standard Swift language feature that any code can use ‚Äî and since we‚Äôve established that <code>ObservableObject</code> (and the slight bit of magic that it employs to automatically bind our properties to its <code>objectWillChange</code> publisher) is mostly useful within the context of SwiftUI ‚Äî is there really anything stopping us from reimplementing part of that system ourselves?</p><p>Let‚Äôs give it a try! We‚Äôll start with a quite bare-bones <code>@propertyWrapper</code> implementation, which projects itself as its <code>projectedValue</code>, and keeps track of a list of observation closures using a <code>MutableReference</code> (which will later enable us to insert and remove observations using <a href="https://www.swiftbysundell.com/basics/value-and-reference-types">reference semantics</a>), like this:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper
struct</span> Published&lt;Value&gt; {
    <span class="s-keyword">var</span> projectedValue: <span class="s-type">Published</span> { <span class="s-keyword">self</span> }
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span> { <span class="s-keyword">didSet</span> { <span class="s-call">valueDidChange</span>() } }
    
    <span class="s-keyword">private var</span> observations = <span class="s-type">MutableReference</span>(
        value: <span class="s-type">List</span>&lt;(<span class="s-type">Value</span>) -&gt; <span class="s-type">Void</span>&gt;()
    )

    <span class="s-keyword">init</span>(wrappedValue: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">wrappedValue</span> = wrappedValue
    }
}</code></pre><p class="info">The above <code>List</code> type was borrowed from <a href="https://www.swiftbysundell.com/articles/picking-the-right-data-structure-in-swift">‚ÄúPicking the right data structure in Swift‚Äù</a>, and the <code>MutableReference</code> type comes from <a href="https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift">‚ÄúCombining value and reference types in Swift‚Äù</a>.</p><p>While we could‚Äôve used a built-in data structure (such as <code>Array</code>) to store our observations, using a linked list gives us simple <code>O(1)</code> insertions and removals (while preserving the order of our elements), which in turn should prevent our new property wrapper from becoming a bottleneck when dealing with a large number of observations.</p><p>Next, let‚Äôs implement the <code>valueDidChange</code> method that‚Äôs being called whenever our property wrapper‚Äôs <code>wrappedValue</code> was modified ‚Äî by simply iterating over all of our observation closures and calling them with our new value:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">Published</span> {
    <span class="s-keyword">func</span> valueDidChange() {
        <span class="s-keyword">for</span> closure <span class="s-keyword">in</span> observations.<span class="s-property">value</span> {
            <span class="s-call">closure</span>(wrappedValue)
        }
    }
}</code></pre><p>Now, before we implement our actual observation code, we‚Äôll need to decide how we want to invalidate each observation (so that they get deallocated along with the objects that triggered them). While there are a <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-2">number of different approaches</a> that we can take here, let‚Äôs mimmic Combine‚Äôs approach and use <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-2/%23tokens">cancellation tokens</a> which automatically cancel their observation when deallocated.</p><p>Here‚Äôs how such a token type could be implemented:</p><pre class="splash"><code><span class="s-keyword">class</span> Cancellable {
    <span class="s-keyword">private var</span> closure: (() -&gt; <span class="s-type">Void</span>)?

    <span class="s-keyword">init</span>(closure: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">closure</span> = closure
    }

    <span class="s-keyword">deinit</span> {
        <span class="s-call">cancel</span>()
    }

    <span class="s-keyword">func</span> cancel() {
        closure?()
        closure = <span class="s-keyword">nil</span>
    }
}</code></pre><p>Finally, let‚Äôs give our new implementation of <code>@Published</code> a closure-based observation API, which will use the above <code>Cancellable</code> type to invalidate observations once cancelled:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Published</span> {
    <span class="s-keyword">func</span> observe(with closure: <span class="s-keyword">@escaping</span> (<span class="s-type">Value</span>) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">Cancellable</span> {
        <span class="s-comment">// To further mimmic Combine's behaviors, we'll call
        // each observation closure as soon as it's attached to
        // our property:</span>
        <span class="s-call">closure</span>(wrappedValue)

        <span class="s-keyword">let</span> node = observations.<span class="s-property">value</span>.<span class="s-call">append</span>(closure)

        <span class="s-keyword">return</span> <span class="s-type">Cancellable</span> { [<span class="s-keyword">weak</span> observations] <span class="s-keyword">in</span>
            observations?.<span class="s-property">value</span>.<span class="s-call">remove</span>(node)
        }
    }
}</code></pre><p>With the above in place, we can now go back to our <code>ProfileViewController</code> and (with a few minor tweaks) achieve the exact same reactive UI implementation as we had before ‚Äî only this time it‚Äôs fully compatible with iOS 12 and below:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> viewModel: <span class="s-type">ProfileViewModel</span>
    <span class="s-keyword">private var</span> cancellable: <span class="s-type"><span class="highlight">Cancellable</span></span>? 

    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        cancellable = viewModel.<span class="s-property">$state</span>.<span class="s-call"><span class="highlight">observe</span></span> { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in</span> 
            <span class="s-keyword">self</span>?.<span class="s-call">render</span>(state)
        }
    }

    <span class="s-keyword">private func</span> render(<span class="s-keyword">_</span> state: <span class="s-type">ProfileViewModel</span>.<span class="s-type">State</span>) {
        ...
    }
}</code></pre><p>Now all that we need to do is to make <code>ProfileViewModel</code> backward compatible as well, which can simply be done by removing its conformance to <code>ObseravableObject</code> (or at least making it conditional using the <code>@available</code> attribute), and everything else will keep working the exact same way as before.</p><h2>Remaining reactive with RxSwift</h2><p>While our above <code>@Published</code> implementation can act as a great starting point if we wish to adopt <em>some</em> of Combine‚Äôs patterns in a backward compatible way, it doesn‚Äôt really enable us to fully embrace reactive programming (unless we keep extending it with new capabilities). On the other hand, reactive programming is not universally adopted, and perhaps our current closure-based API is more than enough to cover our needs.</p><p>But let‚Äôs also explore what a fully reactive version of our new property wrapper might look like. To do that we‚Äôre going to enlist the help of the popular <a href="https://github.com/ReactiveX/RxSwift">RxSwift framework</a>, and implement our observations using its <code>PublishSubject</code> type. We‚Äôll also return that subject (as a read-only <code>Observable&lt;Value&gt;</code>) as our property wrapper‚Äôs <code>projectedValue</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">import</span> RxSwift

<span class="s-keyword">@propertyWrapper
struct</span> Published&lt;Value&gt; {
    <span class="s-keyword">var</span> projectedValue: <span class="s-type">Observable</span>&lt;<span class="s-type">Value</span>&gt; { subject }
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span> { <span class="s-keyword">didSet</span> { <span class="s-call">valueDidChange</span>() } }

    <span class="s-keyword">private let</span> subject = <span class="s-type">PublishSubject</span>&lt;<span class="s-type">Value</span>&gt;()

    <span class="s-keyword">init</span>(wrappedValue: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">wrappedValue</span> = wrappedValue
    }

    <span class="s-keyword">private func</span> valueDidChange() {
        subject.<span class="s-call">on</span>(.<span class="s-call">next</span>(wrappedValue))
    }
}</code></pre><p>With the above implementation in place, we can now use RxSwift‚Äôs many different APIs and reactive operators to transform and subscribe to our <code>@Published</code> values, for example like this:</p><pre class="splash"><code><span class="s-keyword">import</span> RxSwift

<span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> viewModel: <span class="s-type">ProfileViewModel</span>
    <span class="s-keyword">private var</span> disposeBag = <span class="s-type">DisposeBag</span>()

    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        viewModel.<span class="s-property">$state</span>
            .<span class="s-call">subscribe</span>(onNext: { [<span class="s-keyword">weak self</span>] state <span class="s-keyword">in
                self</span>?.<span class="s-call">render</span>(state)
            })
            .<span class="s-call">disposed</span>(by: disposeBag)
    }
    
    ...
}</code></pre><p class="info">Note that RxSwift ships with its own cancellation token system, called ‚Äúdisposables‚Äù, which means that we no longer need our own <code>Cancellable</code> type when going this route.</p><p>There‚Äôs of course no right or wrong option when it comes to whether we should opt for the closure-based version or the one using RxSwift ‚Äî both approaches have their own set of tradeoffs. Like with all technology decisions, it all comes down to what our requirements are, and whether either of the above two approaches will give us more benefits than what we‚Äôre paying to build and maintain them.</p><h2>Conclusion</h2><p>While Combine is a complex and powerful framework with a ton of different APIs and capabilities, the <code>@Published</code> property wrapper is one of its core aspects when it comes to UI development specifically ‚Äî as it lets us easily set up reactive data bindings between our models and our UI.</p><p>Combine might be limited to the latest versions of Apple‚Äôs operating systems, but we could still implement our own version of the <code>@Published</code> property wrapper with support for either closure-based observations, frameworks like RxSwift, or something else. At the end of the day, even Apple‚Äôs own frameworks are implemented using the same kind of code that both you and I write on a daily basis ‚Äî it‚Äôs just a matter of whether that‚Äôs code that we‚Äôre willing to maintain ourselves until we‚Äôre able to adopt the first party solution.</p><p>What do you think? Does the pattern of published properties appeal to you, and what do you think about the <code>@Published</code> implementations presented in this article? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/combining-dynamic-member-lookup-with-key-paths</guid><title>Tip: Combining dynamic member lookup with key paths</title><description></description><link>https://www.swiftbysundell.com/tips/combining-dynamic-member-lookup-with-key-paths</link><pubDate>Fri, 10 Apr 2020 16:20:00 +0200</pubDate><content:encoded><![CDATA[<p>At first, Swift‚Äôs <code>@dynamicMemberLookup</code> attribute might seem like an odd feature, given that it can be used to circumvent much of the type safety that Swift otherwise puts such a strong emphasis on.</p><p>Essentially, adding that attribute to a class or struct enables us to add support for accessing <em>any property</em> on that type ‚Äî regardless of whether that property actually exists or not. For example, here‚Äôs a <code>Settings</code> type that currently implements <code>@dynamicMemberLookup</code> like this:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
struct</span> Settings {
    <span class="s-keyword">var</span> colorTheme = <span class="s-type">ColorTheme</span>.<span class="s-property">modern</span>
    <span class="s-keyword">var</span> itemPageSize = <span class="s-number">25</span>
    <span class="s-keyword">var</span> keepUserLoggedIn = <span class="s-keyword">true

    subscript</span>(dynamicMember member: <span class="s-type">String</span>) -&gt; <span class="s-type">Any</span>? {
        <span class="s-keyword">switch</span> member {
        <span class="s-keyword">case</span> <span class="s-string">"colorTheme"</span>:
            <span class="s-keyword">return</span> colorTheme
        <span class="s-keyword">case</span> <span class="s-string">"itemPageSize"</span>:
            <span class="s-keyword">return</span> itemPageSize
        <span class="s-keyword">case</span> <span class="s-string">"keepUserLoggedIn"</span>:
            <span class="s-keyword">return</span> keepUserLoggedIn
        <span class="s-keyword">default</span>:
            <span class="s-keyword">return nil</span>
        }
    }
}</code></pre><p class="info">To learn more about subscripts in general, check out <a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift">‚ÄúThe power of subscripts in Swift‚Äù</a>.</p><p>Since the above type supports dynamic member lookup, we can use any arbitrary name when accessing one of its properties, and the compiler won‚Äôt give us any kind of warning or error when there‚Äôs no declared property matching that name:</p><pre class="splash"><code><span class="s-keyword">let</span> settings = <span class="s-type">Settings</span>()
<span class="s-keyword">let</span> theme = settings.<span class="s-property">colorTheme</span>
<span class="s-keyword">let</span> somethingUnknown = settings.<span class="s-property">somePropertyName</span></code></pre><p>Again, that might seem like an odd feature for Swift to support, but it‚Äôs incredibly useful when writing <em>bridging code</em> between Swift and more dynamic languages ‚Äî such as Ruby, Python, or JavaScript ‚Äî or when writing other kinds of proxy-based code.</p><p>However, there is <em>one more way</em> to use <code>@dynamicMemberLookup</code> that can also be incredibly useful even within completely static Swift code ‚Äî and that‚Äôs to combine it with <em><a href="https://www.swiftbysundell.com/tags/key-paths">key paths</a></em>.</p><p>As an example, let‚Äôs revisit the <code>Reference</code> type from <em><a href="https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift">‚ÄúCombining value and reference types in Swift‚Äù</a></em> (which enables a value type to be passed as a reference), and add support for dynamically looking up one of its wrapped <code>Value</code> type‚Äôs members ‚Äî but this time using a <code>KeyPath</code>, rather than a <code>String</code>:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
class</span> Reference&lt;Value&gt; {
    <span class="s-keyword">private(set) var</span> value: <span class="s-type">Value</span>

    <span class="s-keyword">init</span>(value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }

    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        value[keyPath: keyPath]
    }
}</code></pre><p>Now this is <em>really cool</em>, because what the above enables us to do is to access any of our <code>Value</code> type‚Äôs properties directly as if they were properties of our <code>Reference</code> type itself ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">let</span> reference = <span class="s-type">Reference</span>(value: <span class="s-type">Settings</span>())
<span class="s-keyword">let</span> theme = reference.<span class="s-property">colorTheme</span></code></pre><p class="info">Since we implemented our <code>Reference</code> type‚Äôs <code>dynamicMember</code> subscript using a key path, we won‚Äôt be able to look up any arbitrary property name when using it, like we could when using strings.</p><p>We can even add a mutable version too, by creating a subscript overload that accepts a <code>WritableKeyPath</code>, and by then implementing both a getter and a setter for it:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Reference</span> {
    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">WritableKeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        <span class="s-keyword">get</span> { value[keyPath: keyPath] }
        <span class="s-keyword">set</span> { value[keyPath: keyPath] = newValue }
    }
}</code></pre><p>With the above in place, we can now directly mutate any <code>Value</code> that‚Äôs wrapped using our <code>Reference</code> type ‚Äî just as if we were mutating the reference instance itself:</p><pre class="splash"><code><span class="s-keyword">let</span> reference = <span class="s-type">Reference</span>(value: <span class="s-type">Settings</span>())
reference.<span class="s-property">theme</span> = .<span class="s-dotAccess">oldSchool</span></code></pre><p>Finally, just like how we in the <a href="https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift">original article</a> extracted all of the mutating APIs from <code>Reference</code> into a new <code>MutableReference</code> type ‚Äî let‚Äôs do that here as well, to be able to limit in which parts of our code base that mutations can occur:</p><pre class="splash"><code><span class="s-keyword">@dynamicMemberLookup
class</span> Reference&lt;Value&gt; {
    <span class="s-keyword">fileprivate(set) var</span> value: <span class="s-type">Value</span>

    <span class="s-keyword">init</span>(value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }

    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        value[keyPath: keyPath]
    }
}

<span class="s-keyword">class</span> MutableReference&lt;Value&gt;: <span class="s-type">Reference</span>&lt;<span class="s-type">Value</span>&gt; {
    <span class="s-keyword">subscript</span>&lt;T&gt;(dynamicMember keyPath: <span class="s-type">WritableKeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">T</span>&gt;) -&gt; <span class="s-type">T</span> {
        <span class="s-keyword">get</span> { value[keyPath: keyPath] }
        <span class="s-keyword">set</span> { value[keyPath: keyPath] = newValue }
    }
}</code></pre><p>Using the above, we can now easily pass a value type as a reference, and both read and mutate its properties as if we were accessing the wrapped value directly ‚Äî for example like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewModel {
    <span class="s-keyword">private let</span> user: <span class="s-type">User</span>
    <span class="s-keyword">private let</span> settings: <span class="s-type">MutableReference</span>&lt;<span class="s-type">Settings</span>&gt;

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, settings: <span class="s-type">MutableReference</span>&lt;<span class="s-type">Settings</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">user</span> = user
        <span class="s-keyword">self</span>.<span class="s-property">settings</span> = settings
    }

    <span class="s-keyword">func</span> makeEmailAddressIcon() -&gt; <span class="s-type">Icon</span> {
        <span class="s-comment">// Reading Setting's 'colorTheme' property:</span>
        <span class="s-keyword">var</span> icon = <span class="s-type">Icon</span>.<span class="s-property">email</span>
        icon.<span class="s-property">useLightVersion</span> = settings.<span class="s-property">colorTheme</span>.<span class="s-property">isDark</span>
        <span class="s-keyword">return</span> icon
    }

    <span class="s-keyword">func</span> rememberMeSwitchToggled(to newValue: <span class="s-type">Bool</span>) {
        <span class="s-comment">// Mutating Setting's 'keepUserLoggedIn' property:</span>
        settings.<span class="s-property">keepUserLoggedIn</span> = newValue
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/handling-keyup-and-keydown-events</guid><title>Tip: Handling keyUp and keyDown events on iOS 13.4 and later</title><description>How to observe iOS 13.4‚Äôs new granular keyboard events.</description><link>https://www.swiftbysundell.com/tips/handling-keyup-and-keydown-events</link><pubDate>Mon, 6 Apr 2020 19:45:00 +0200</pubDate><content:encoded><![CDATA[<p>In iOS 13.4 Apple (<em>finally</em>) added support for detecting when an external keyboard key is either pressed or released, which can be incredibly useful in a number of different situations. While it was previously possible to <a href="https://www.swiftbysundell.com/articles/building-ipad-pro-features-in-swift/%23keyboard-shortcuts">register keyboard shortcuts</a> using the <code>UIKeyCommand</code> API, we now get direct access to what‚Äôs commonly referred to as <code>keyUp</code> and <code>keyDown</code> events.</p><p>As an example, let‚Äôs say that we‚Äôre working on an app that includes some form of editor, and that we want to add richer support for controlling that editor using an external keyboard. The first thing that we‚Äôll need to do in order to make that happen is to override three methods that‚Äôll let us handle <code>UIPress</code> events ‚Äî since that class has now been upgraded with a new <code>key</code> property, which gives us information about pressed (and released) keys.</p><p>We can override those three methods on any <code>UIResponder</code>, for example our <code>EditorViewController</code>, and within each implementation we‚Äôll unwrap the new <code>key</code> property in order to pass its <code>UIKey</code> value to one of two private methods ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> EditorViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">override func</span> pressesBegan(<span class="s-keyword">_</span> presses: <span class="s-type">Set</span>&lt;<span class="s-type">UIPress</span>&gt;,
                               with event: <span class="s-type">UIPressesEvent</span>?) {
        <span class="s-keyword">super</span>.<span class="s-call">pressesBegan</span>(presses, with: event)
        presses.<span class="s-property">first</span>?.<span class="s-property">key</span>.<span class="s-call">map</span>(keyPressed)
    }

    <span class="s-keyword">override func</span> pressesEnded(<span class="s-keyword">_</span> presses: <span class="s-type">Set</span>&lt;<span class="s-type">UIPress</span>&gt;,
                               with event: <span class="s-type">UIPressesEvent</span>?) {
        <span class="s-keyword">super</span>.<span class="s-call">pressesEnded</span>(presses, with: event)
        presses.<span class="s-property">first</span>?.<span class="s-property">key</span>.<span class="s-call">map</span>(keyReleased)
    }

    <span class="s-keyword">override func</span> pressesCancelled(<span class="s-keyword">_</span> presses: <span class="s-type">Set</span>&lt;<span class="s-type">UIPress</span>&gt;,
                                   with event: <span class="s-type">UIPressesEvent</span>?) {
        <span class="s-keyword">super</span>.<span class="s-call">pressesCancelled</span>(presses, with: event)
        presses.<span class="s-property">first</span>?.<span class="s-property">key</span>.<span class="s-call">map</span>(keyReleased)
    }
}</code></pre><p class="info">Another option would be to implement the above within a dedicated ‚Äúkeyboard handling‚Äù <a href="https://www.swiftbysundell.com/basics/child-view-controllers">child view controller</a>, which we could then <a href="https://www.swiftbysundell.com/articles/using-child-view-controllers-as-plugins-in-swift">plug into</a> our main <code>EditorViewController</code>.</p><p>Next, let‚Äôs implement those private methods, starting with <code>keyPressed</code>. The cool thing about <code>UIKey</code> is that it isn‚Äôt just a numeric key code (which is how these things have often worked historically), it‚Äôs a class that contains all sorts of useful information about a key‚Äôs state ‚Äî for example whether a modifier key is also currently pressed. It also provides a completely type-safe API for identifying keys, which enables us to implement our handling logic using a single <code>switch</code> statement:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">EditorViewController</span> {
    <span class="s-keyword">func</span> keyPressed(<span class="s-keyword">_</span> key: <span class="s-type">UIKey</span>) {
        <span class="s-keyword">switch</span> key.<span class="s-property">keyCode</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardP</span>:
            <span class="s-call">selectTool</span>(.<span class="s-dotAccess">pen</span>)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardB</span>:
            <span class="s-call">selectTool</span>(.<span class="s-dotAccess">brush</span>)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardE</span> <span class="s-keyword">where</span> key.<span class="s-property">modifierFlags</span>.<span class="s-call">contains</span>(.<span class="s-dotAccess">command</span>):
            <span class="s-call">eraseSelection</span>()
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardLeftShift</span>, .<span class="s-dotAccess">keyboardRightShift</span>:
            <span class="s-call">activateBoxedSelectionMode</span>()
        <span class="s-keyword">default</span>:
            <span class="s-keyword">break</span>
        }
    }
}</code></pre><p>Finally, let‚Äôs also implement our <code>keyReleased</code> method using the exact same technique:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">EditorViewController</span> {
    <span class="s-keyword">func</span> keyReleased(<span class="s-keyword">_</span> key: <span class="s-type">UIKey</span>) {
        <span class="s-keyword">switch</span> key.<span class="s-property">keyCode</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">keyboardLeftShift</span>, .<span class="s-dotAccess">keyboardRightShift</span>:
            <span class="s-call">deactivateBoxedSelectionMode</span>()
        <span class="s-keyword">default</span>:
            <span class="s-keyword">break</span>
        }
    }
}</code></pre><p>Apple might‚Äôve taken quite a long time to add full keyboard event support to iOS, but now that it‚Äôs finally here, its API is incredibly nice.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-3</guid><title>A guide to the SwiftUI layout system - Part 3</title><description>This week, we‚Äôll wrap up the SwiftUI layout system series by taking a look at how we can customize the layout behaviors of our views, using tools like layout priorities and alignment guides.</description><link>https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-3</link><pubDate>Sun, 5 Apr 2020 17:45:00 +0200</pubDate><content:encoded><![CDATA[<p>Initially, SwiftUI‚Äôs layout system might seem a bit inflexible, as its default suite of concepts and APIs doesn‚Äôt give us a lot of pixel-level control, and instead focuses on leveraging a strong set of platform-defined defaults ‚Äî which in turn enables the system to make many common layout decisions on our behalf.</p><p>However, once we look beneath the surface, there‚Äôs a ton of different customization options and overrides that we can apply to tweak the SwiftUI layout system and its default set of behaviors. So, in this third and final part of this series of articles, let‚Äôs explore some of those customization options, and how they can let us resolve common conflicts and remove sources of ambiguity when defining SwiftUI layouts.</p><p class="info">The articles on this site are, for the most part, not tutorials. However, this article was (just like <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">part one</a> and <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2">part two</a>) written to enable you to easily code along within a SwiftUI-based iOS app project in Xcode, if you wish to do so. Each code sample will show a complete implementation, with no details omitted, except for the views that were built during the previous parts.</p><h2>Encountering conflicts</h2><p>Picking up where we left off at the end of <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2">part two</a> ‚Äî after adding both a header and a footer to our event view, let‚Äôs now add some actual content to it. Just like previously, we‚Äôll stick to placeholder content within this article, to be able to fully focus on exploring the SwiftUI layout system itself.</p><p>Let‚Äôs start by creating a new view that‚Äôll let us render a placeholder for an image using a <code>RoundedRectangle</code> shape, that‚Äôs placed within a <code>ZStack</code> along with a <code>Text</code>:</p><pre data-preview="image-placeholder"><code><span class="s-keyword">struct</span> ImagePlaceholder: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            <span class="s-type">RoundedRectangle</span>(cornerRadius: <span class="s-number">10</span>).<span class="s-call">stroke</span>()
            <span class="s-type">Text</span>(<span class="s-string">"Image placeholder"</span>)
        }
    }
}</code></pre><p>Next, let‚Äôs add an instance of the above <code>ImagePlaceholder</code>, as well as a description text, to our main <code>ContentView</code> ‚Äî which will now contain the final set of views that we‚Äôll display as part of our event screen:</p><pre data-preview="short-description"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
            <span class="s-type">Text</span>(<span class="s-string">"This is a description"</span>)
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>The result of the above code (which you can show a preview of using the <code>PREVIEW</code> button) shows us one really interesting aspect of SwiftUI‚Äôs various shapes ‚Äî just like spacers, they always occupy as much space as they can. So, given that our description text is currently very short, our image placeholder ends up stretching itself to take up a quite substantial part of the screen.</p><p>Now let‚Äôs see what would happen if we were to change that by making our description much longer ‚Äî for example by repeating the same text that we used above 50 times, like this:</p><pre data-preview="long-description"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}

<span class="s-keyword">private extension</span> <span class="s-type">ContentView</span> {
    <span class="s-keyword">func</span> makeDescription() -&gt; <span class="s-type">String</span> {
        <span class="s-type">String</span>(repeating: <span class="s-string">"This is a description "</span>, count: <span class="s-number">50</span>)
    }
}</code></pre><p>This is where things are starting to get <em>really interesting</em>. Not only does the SwiftUI layout system truncate our now much longer text, it also truncates the text of our trailing <code>EventInfoBadge</code> at the bottom of the screen ‚Äî all while still giving a substantial part of the available space to our <code>ImagePlaceholder</code> (which, ironically, is the view that is arguably best suited to be resized in this scenario).</p><p><em>So what‚Äôs going on here?</em> It all comes down to how SwiftUI‚Äôs fundamental layout rules (which we took a look at in <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">part one</a>) work ‚Äî in that each view is responsible for determining its own size, and only <em>after that</em> is each parent deciding how to position and fit its children within its own frame.</p><p>As a result, since our <code>ImagePlaceholder</code> and our description text are now both requesting frames that are much larger than what could simultaneously fit within our <code>VStack</code> ‚Äî the layout system is forced to compromise, by first compressing each view as much as possible (which is what causes our <code>EventInfoBadge</code> to get truncated), and then splitting the available space evenly among its children.</p><p>Thankfully, SwiftUI ships with a number of tools that we can use to resolve the above sort of layout conflicts ‚Äî without having to resort to things like manually drawing each of our views ourselves, or by <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match/">escaping</a> into UIKit or AppKit land.</p><h2>Layout priorities</h2><p>Let‚Äôs start by taking a look at <em>layout priorities</em>, which enable us to tell the SwiftUI layout system which views that are the most (or least) important in terms of respecting their preferred sizes. Each view starts out with a layout priority of zero, which can then either be reduced or increased by applying the <code>layoutPriority()</code> modifier. Here‚Äôs how we could do just that to give our description a slightly higher priority:</p><pre data-preview="description-priority"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())<span class="highlight">.<span class="s-call">layoutPriority</span>(<span class="s-number">1</span>)</span>
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p class="info">Note that there‚Äôs no need to go to extremes and use layout priority values like <code>999</code> or <code>.infinity</code> ‚Äî any value larger than zero will have an impact on our layout.</p><p>The above tweak definitely makes our view look nicer (again, you can use the <code>PREVIEW</code> button to see what it currently looks like) ‚Äî with our description now getting a much larger portion of the available space. However, our trailing <code>EventInfoBadge</code> still remains squashed, and our image placeholder now has a much smaller height.</p><p>One way to fix that <code>EventInfoBadge</code> problem would be to do the inverse of what we did above, and <em>lower</em> our image placeholder‚Äôs layout priority, rather than <em>increasing</em> the one for our description ‚Äî like this:</p><pre data-preview="image-priority"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()<span class="highlight">.<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)</span>
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>That‚Äôs once again better, but our image placeholder still gets shrunken down to its absolutely smallest height (equal to the line height of its text), which doesn‚Äôt look great. To resolve that issue, let‚Äôs also give our placeholder a minimum height using the <code>.frame()</code> modifier:</p><pre data-preview="image-min-height"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
                .<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)
                <span class="highlight">.<span class="s-call">frame</span>(minHeight: <span class="s-number">100</span>)</span>
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Our image placeholder now looks great, and so does our description text ‚Äî however, our <code>EventInfoBadge</code> text once again gets truncated. To solve that final issue, let‚Äôs raise the layout priority of our <code>EventInfoList</code>, to tell the layout system to prioritize its height above all else:</p><pre data-preview="info-list-priority"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
                .<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)
                .<span class="s-call">frame</span>(minHeight: <span class="s-number">100</span>)
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()<span class="highlight">.<span class="s-call">layoutPriority</span>(<span class="s-number">1</span>)</span>
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>SwiftUI‚Äôs layout priorities system is a simple yet powerful tool that enables us to specify an explicit order in which our views get laid out ‚Äî which can help us resolve conflicts in terms of how our views get resized to fit within the space that‚Äôs available.</p><h2>Fixed dimensions</h2><p>One issue with layout priorities, however, is that applying them can occasionally feel like playing a game of <em>‚ÄúWhack-a-mole‚Äù</em> ‚Äî in that for every tweak and fix that we apply, a new issue pops up. We already saw that starting to happen above, when we had to both raise and lower layout priorities in response to various issues.</p><p>So while adjusting a view‚Äôs layout priority can be a great way to apply one-off fixes, it‚Äôs thankfully not the <em>only</em> tool that lets us tweak SwiftUI‚Äôs layout behaviors. Another of those tools is the <code>fixedSize()</code> modifier, which (like the name implies) enables us to <em>fix</em> a view‚Äôs size at either its preferred width or height (or both).</p><p>Using that modifier, we can achieve the exact same result as in the previous example, only this time without having to introduce additional layout priorities (except the image placeholder one) ‚Äî by giving our <code>EventInfoList</code> a fixed vertical size, which prevents it from being compressed:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
                .<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)
                .<span class="s-call">frame</span>(minHeight: <span class="s-number">100</span>)
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()<span class="highlight">.<span class="s-call">fixedSize</span>(horizontal: <span class="s-keyword">false</span>, vertical: <span class="s-keyword">true</span>)</span>
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>To further illustrate how the <code>fixedSize()</code> modifier works, let‚Äôs see w<span class="highlight">hat would happen if we were to also give our <code>EventInfoList</code> a fixed <em>horizontal</em> size as well:</p><pre data-preview="info-list-fixed-width"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">ImagePlaceholder</span>()
                .<span class="s-call">layoutPriority</span>(-<span class="s-number">1</span>)
                .<span class="s-call">frame</span>(minHeight: <span class="s-number">100</span>)
            <span class="s-type">Text</span>(<span class="s-call">makeDescription</span>())
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>().<span class="s-call">fixedSize</span>(horizontal: <span class="s-keyword">true</span>,</span> vertical: <span class="s-keyword">true</span>)
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>As the preview of the above example shows us, fixing our info list‚Äôs width causes the entire <code>ContentView</code> to get stretched beyond the bounds of the screen, which might initially seem quite odd.</p><p>The reason for that is, since we‚Äôre now preventing the layout system from adjusting the width of our <code>EventInfoList</code>, our root <code>VStack</code> will be forced to stretch itself to occupy that same large width (since a stack always resizes itself to fit all of its children within it) ‚Äî which in turn gives the rest of our subviews more horizontal space, even though that space is partly out of bounds.</p><h2>Custom alignment guides</h2><p>Finally, let‚Äôs take a look at using custom alignment guides, and how they can be a great alternative to using other forms of alignment tools ‚Äî such as <em>padding</em> and <em>offset</em>. For that, we‚Äôre going to go back to our <em>verified badge</em> from <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1/%23zstacks-and-offset">part one</a>, which ‚Äî as a quick reminder ‚Äî we ended up implementing as a <code>View</code> extension using a <code>ZStack</code> and the <code>.offset()</code> modifier:</p><pre data-preview="calendar-initial"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">offset</span>(x: <span class="s-number">3</span>, y: -<span class="s-number">3</span>)
            }
        }
    }
}</code></pre><p>While the above code definitely works, it does make certain assumptions about the size of the badge that we‚Äôll end up displaying ‚Äî as our offset is currently hard-coded to 3x3 points, irrespective of the size of the image that the system will render.</p><p>To address that issue, let‚Äôs replace our use of the <code>.offset()</code> modifier with two custom alignment guides. By applying the <code>.alignmentGuide()</code> modifier to a view, we can tweak how it gets positioned when a given horizontal or vertical alignment is used, using a custom computation closure.</p><p>Since our <code>ZStack</code> currently uses the <code>.topTrailing</code> alignment, let‚Äôs use that set of alignments to tweak our badge‚Äôs position, by placing its center according to those two guides ‚Äî like this:</p><pre data-preview="calendar-alignment-guides"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">alignmentGuide</span>(<span class="s-type">HorizontalAlignment</span>.<span class="s-property">trailing</span>) {
                        $0[<span class="s-type">HorizontalAlignment</span>.<span class="s-property">center</span>]
                    }
                    .<span class="s-call">alignmentGuide</span>(<span class="s-type">VerticalAlignment</span>.<span class="s-property">top</span>) {
                        $0[<span class="s-type">VerticalAlignment</span>.<span class="s-property">center</span>]
                    }
            }
        }
    }
}</code></pre><p>The result of the above looks fine, but not as nice as our view previously looked when it was using a hard-coded set of metrics. Essentially, we want to slightly offset our badge image towards the center of the calendar icon itself, to make it feel more <em>attached</em> to its host view.</p><p>To make that happen in a way that doesn‚Äôt involve any fixed offset values, let‚Äôs perform our alignment using a percentage of our badge image‚Äôs width and height, rather than using its center. That‚Äôs quite easily done, since the <code>ViewDimensions</code> context that is passed into each custom alignment guide‚Äôs closure also contains the width and height of the view that is being aligned:</p><pre data-preview="calendar-final"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">alignmentGuide</span>(<span class="s-type">HorizontalAlignment</span>.<span class="s-property">trailing</span>) {
                        $0.<span class="s-property">width</span> * <span class="s-number">0.8</span>
                    }
                    .<span class="s-call">alignmentGuide</span>(<span class="s-type">VerticalAlignment</span>.<span class="s-property">top</span>) {
                        <span class="s-comment">// Here we first align our view's bottom edge
                        // according to its host view's top edge,
                        // and we then subtract 80% of its height.</span>
                        $0[.<span class="s-dotAccess">bottom</span>] - $0.<span class="s-property">height</span> * <span class="s-number">0.8</span>
                    }
            }
        }
    }
}</code></pre><p class="info">One small difference between this approach and our previous offset-based one is that the badge will now be included when computing its host view‚Äôs overall frame, which doesn‚Äôt make much of a difference in this case, and can be avoided by giving the badge a negative layout priority.</p><p>While custom alignment guides are really powerful, they‚Äôre quite <em>‚Äúheavy‚Äù</em> in terms of syntax ‚Äî so rather than keeping the above modifiers inline, let‚Äôs move them to a new <code>View</code> extension that can be applied to any view that we wish to align as a badge:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> alignAsBadge(withRatio ratio: <span class="s-type">CGFloat</span> = <span class="s-number">0.8</span>,
                      alignment: <span class="s-type">Alignment</span> = .<span class="s-dotAccess">topTrailing</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">alignmentGuide</span>(alignment.<span class="s-property">horizontal</span>) {
            $0.<span class="s-property">width</span> * ratio
        }
        .<span class="s-call">alignmentGuide</span>(alignment.<span class="s-property">vertical</span>) {
            $0[.<span class="s-dotAccess">bottom</span>] - $0.<span class="s-property">height</span> * ratio
        }
    }
}</code></pre><p>With the above extension in place, we can now heavily simplify our verified badge implementation to instead look like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">alignAsBadge</span>()
            }
        }
    }
}</code></pre><p>So the <code>.alignmentGuide()</code> modifier enables us to override and adjust how a view gets aligned given either a horizontal or vertical alignment ‚Äî which can be really useful when either building completely custom layouts, or when tweaking how a single view gets positioned. There‚Äôs also an API that enables us to define <em>completely custom</em> alignments (by implementing an <code>AlignmentID</code>), which we might take a closer look at in a future article.</p><h2>Conclusion</h2><p>We‚Äôve now reached the end of this three-part guide to the SwiftUI layout system. I hope that you enjoyed it, and that it has given you new insights into how the SwiftUI layout system works, and the various APIs and tools that can be used to customize its behaviors.</p><p>While my goal was definitely to make this guide as thorough as possible, there are of course many different aspects of the SwiftUI layout system that it didn‚Äôt cover ‚Äî so I‚Äôm sure that we‚Äôll revisit this topic again, perhaps sooner rather than later.</p><p>But for now, let‚Äôs again recap what was covered in this third and final part of this series:</p><ul><li>Adjusting <em>layout priorities</em> can be a great way to tweak how each view gets prioritized in terms of its preferred size.</li><li>Applying a <em>fixed frame size</em> to a view prevents it from being resized either horizontally or vertically (or both).</li><li>Custom alignment guides let us adjust how a view gets positioned when a given alignment is used, which can be really useful when we want to position one view in relation to another.</li></ul><p>Although I‚Äôve written <a href="https://www.swiftbysundell.com/tags">hundreds of articles</a> for this site, this was the first code-along guide that I‚Äôve ever made, so I‚Äôd love to hear your feedback on it ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>. You‚Äôre also more than welcome to ask me any questions that you might have, and if you enjoyed this series, feel free to share it with others ‚Äî I‚Äôd <em>really</em> appreciate that.</p><p>You can also find a ton of other freely available SwiftUI content on <a href="https://www.swiftbysundell.com/tags/swiftui">this category page</a>. Next Sunday, we‚Äôll explore a brand new topic ‚Äî which won‚Äôt be related to SwiftUI, I promise.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/protocols</guid><title>Basics: Protocols</title><description>What makes Swift a protocol-oriented language, and how can protocols be used to create abstractions and to enable code reuse? That‚Äôs what we‚Äôll take a look at in this Basics article.</description><link>https://www.swiftbysundell.com/basics/protocols</link><pubDate>Fri, 3 Apr 2020 19:10:00 +0200</pubDate><content:encoded><![CDATA[<p>While many languages support the concept of protocols (or <em>‚ÄúInterfaces‚Äù</em> as they‚Äôre also often called), Swift treats protocols as a true cornerstone of its overall design ‚Äî with Apple even going so far as to call Swift a <em>‚Äúprotocol-oriented programming language‚Äù</em>.</p><p>Essentially, protocols enable us to define APIs and requirements without tying them to one specific type or implementation. For example, let‚Äôs say that we‚Äôre working on some form of music player, and that we‚Äôve currently implemented our playback code as two separate methods within a <code>Player</code> class ‚Äî one for playing songs, and one for playing albums:</p><pre class="splash"><code><span class="s-keyword">class</span> Player {
    <span class="s-keyword">private let</span> avPlayer = <span class="s-type">AVPlayer</span>()

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> song: <span class="s-type">Song</span>) {
        <span class="s-keyword">let</span> item = <span class="s-type">AVPlayerItem</span>(url: song.<span class="s-property">audioURL</span>)
        avPlayer.<span class="s-call">replaceCurrentItem</span>(with: item)
        avPlayer.<span class="s-call">play</span>()
    }

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> album: <span class="s-type">Album</span>) {
        <span class="s-keyword">let</span> item = <span class="s-type">AVPlayerItem</span>(url: album.<span class="s-property">audioURL</span>)
        avPlayer.<span class="s-call">replaceCurrentItem</span>(with: item)
        avPlayer.<span class="s-call">play</span>()
    }
}</code></pre><p>Looking at the above implementation, we definitely have a fair amount of code duplication, since both of our <code>play</code> methods need to do more or less the exact same thing ‚Äî convert the resource that is being played into an <code>AVPlayerItem</code> and then play it using an <code>AVPlayer</code> instance.</p><p>That‚Äôs one of the kinds of problems that protocols can help us solve in a much more elegant manner. To get started, let‚Äôs define a new protocol called <code>Playable</code>, which will <em>require each type that‚Äôs conforming to it</em> to implement an <code>audioURL</code> property:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Playable {
    <span class="s-keyword">var</span> audioURL: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
}</code></pre><p class="info">The above <code>get</code> keyword is used to specify that in order to conform to our new protocol, a type only needs to declare a read-only <code>audioURL</code> property ‚Äî it doesn‚Äôt have to be writable.</p><p>We can then make different types <em>conform</em> to our new protocol in two ways. One way is to declare the conformance as part of the type declaration itself ‚Äî for example like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Song: <span class="s-type"><span class="highlight">Playable</span></span> { 
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> album: <span class="s-type">Album</span>
    <span class="s-keyword">var</span> audioURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> isLiked: <span class="s-type">Bool</span>
}</code></pre><p>The other way is to declare conformance through an extension ‚Äî which can simply be done using an empty extension in case a type already meets all of the protocol‚Äôs requirements (which is the case for our <code>Album</code> model below):</p><pre class="splash"><code><span class="s-keyword">struct</span> Album {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> imageURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> audioURL: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> isLiked: <span class="s-type">Bool</span>
}

<span class="s-keyword">extension</span> <span class="s-type">Album</span>: <span class="s-type"><span class="highlight">Playable</span></span> {} </code></pre><p>With the above changes in place we can now simplify our <code>Player</code> class quite a lot ‚Äî by merging our two previous <code>play</code> methods into one that, rather than accepting a <em>concrete type</em> (such as <code>Song</code> or <code>Album</code>), now accepts <em>any type</em> that conforms to our new <code>Playable</code> protocol:</p><pre class="splash"><code><span class="s-keyword">class</span> Player {
    <span class="s-keyword">private let</span> avPlayer = <span class="s-type">AVPlayer</span>()

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> resource: <span class="s-type">Playable</span>) {
        <span class="s-keyword">let</span> item = <span class="s-type">AVPlayerItem</span>(url: resource.<span class="s-property">audioURL</span>)
        avPlayer.<span class="s-call">replaceCurrentItem</span>(with: item)
        avPlayer.<span class="s-call">play</span>()
    }
}</code></pre><p>That‚Äôs much nicer! However, there is one tiny issue with our above protocol, and that‚Äôs its name. While <code>Playable</code> might‚Äôve initially seemed like an appropriate name, it sort of indicates that the types conforming to it can actually <em>perform playback</em>, which isn‚Äôt the case. Instead, since our protocol is all about <em>converting an instance into an audio URL</em>, let‚Äôs rename it to <code>AudioURLConvertible</code> ‚Äî to make things crystal clear:</p><pre class="splash"><code><span class="s-comment">// Renaming our declaration:</span>
<span class="s-keyword">protocol</span> AudioURLConvertible {
    <span class="s-keyword">var</span> audioURL: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
}

<span class="s-comment">// Song's conformance to it:</span>
<span class="s-keyword">struct</span> Song: <span class="s-type">AudioURLConvertible</span> {
    ...
}

<span class="s-comment">// The Album extension:</span>
<span class="s-keyword">extension</span> <span class="s-type">Album</span>: <span class="s-type">AudioURLConvertible</span> {}

<span class="s-comment">// And finally how we use it within our Player class:</span>
<span class="s-keyword">class</span> Player {
    <span class="s-keyword">private let</span> avPlayer = <span class="s-type">AVPlayer</span>()

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> resource: <span class="s-type">AudioURLConvertible</span>) {
        ...
    }
}</code></pre><p>On the flip side of the coin, let‚Äôs now take a look at a protocol that <em>does</em> require an action (or in other words, a method), which makes it a nice fit for the typical <em>‚Äú-able‚Äù</em> naming suffix. In this case we‚Äôll require a <em>mutating</em> method, since we want to enable any types conforming to our protocol to <em>mutate their own state</em> (that is, change property values) within their implementations:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Likeable {
    <span class="s-keyword">mutating func</span> markAsLiked()
}

<span class="s-keyword">extension</span> <span class="s-type">Song</span>: <span class="s-type">Likeable</span> {
    <span class="s-keyword">mutating func</span> markAsLiked() {
        isLiked = <span class="s-keyword">true</span>
    }
}</code></pre><p>Since most types that will conform to our new <code>Likeable</code> are likely (no pun intended) to implement our <code>markAsLiked</code> method requirement the exact same way as <code>Song</code> does, we might also choose to make that <code>isLiked</code> property our requirement instead (and also require it to be mutable by adding the <code>set</code> keyword).</p><pre class="splash"><code><span class="s-keyword">protocol</span> Likeable {
    <span class="s-keyword">var</span> isLiked: <span class="s-type">Bool</span> { <span class="s-keyword">get set</span> }
}</code></pre><p>The cool thing is that, if we still want our API to be <code>something.markAsLiked()</code>, then we can easily make that happen using a <em>protocol extension</em> ‚Äî which enable us to add new methods and computed properties to all types that conforms to a given protocol:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Likeable</span> {
    <span class="s-keyword">mutating func</span> markAsLiked() {
        isLiked = <span class="s-keyword">true</span>
    }
}</code></pre><p class="info">For more information about the <code>mutating</code> keyword, and a broader discussion around value and reference types, check out <a href="https://www.swiftbysundell.com/basics/value-and-reference-types/">this Basics article</a>.</p><p>With the above in place, we can now make both <code>Song</code> and <code>Album</code> conform to <code>Likeable</code> without having to write any additional code ‚Äî since they both already declare an <code>isLiked</code> property that‚Äôs mutable:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Song</span>: <span class="s-type">Likeable</span> {}
<span class="s-keyword">extension</span> <span class="s-type">Album</span>: <span class="s-type">Likeable</span> {}</code></pre><p>Besides enabling code reuse and unifying similar implementations, protocols can also be really useful when refactoring, or when we want to conditionally replace one implementation with another.</p><p>As an example, let‚Äôs say that we wanted to test a new implementation of our <code>Player</code> class from before ‚Äî that enqueues songs and other playback items, rather than immediately starting to play them. One way to do that would of course be to add that logic to our original <code>Player</code> implementation, but that could quickly get messy ‚Äî especially if we want to perform multiple tests and try out more kinds of variations.</p><p>Instead, let‚Äôs <em>create an abstraction</em> for our core playback API by implementing a protocol for it. In this case, we‚Äôll simply name it <code>PlayerProtocol</code>, and make it require our single <code>play</code> method from before:</p><pre class="splash"><code><span class="s-keyword">protocol</span> PlayerProtocol {
    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> resource: <span class="s-type">AudioURLConvertible</span>)
}</code></pre><p>Using our new protocol, we‚Äôre now free to implement as many different variants of our player as we wish ‚Äî each of which can have their own private implementation details, while still being compatible with the exact same public API:</p><pre class="splash"><code><span class="s-keyword">class</span> EnqueueingPlayer: <span class="s-type">PlayerProtocol</span> {
    <span class="s-keyword">private let</span> avPlayer = <span class="s-type">AVQueuePlayer</span>()

    <span class="s-keyword">func</span> play(<span class="s-keyword">_</span> resource: <span class="s-type">AudioURLConvertible</span>) {
        <span class="s-keyword">let</span> item = <span class="s-type">AVPlayerItem</span>(url: resource.<span class="s-property">audioURL</span>)
        avPlayer.<span class="s-call">insert</span>(item, after: <span class="s-keyword">nil</span>)
        avPlayer.<span class="s-call">play</span>()
    }
}

<span class="s-keyword">extension</span> <span class="s-type">Player</span>: <span class="s-type">PlayerProtocol</span> {}</code></pre><p>With the above in place, we can now conditionally use either of our player implementations by making whichever code that creates the app‚Äôs player return a <code>PlayerProtocol</code> conforming-instance, rather than a concrete type:</p><pre class="splash"><code><span class="s-keyword">func</span> makePlayer() -&gt; <span class="s-type">PlayerProtocol</span> {
    <span class="s-keyword">if</span> <span class="s-type">Settings</span>.<span class="s-property">useEnqueueingPlayer</span> {
        <span class="s-keyword">return</span> <span class="s-type">EnqueueingPlayer</span>()
    } <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> <span class="s-type">Player</span>()
    }
}</code></pre><p>Finally, let‚Äôs go back to that initial statement of Swift being a <em>‚Äúprotocol-oriented language‚Äù</em>. So far in this article, we‚Äôve seen that Swift does indeed support many powerful protocol-based features ‚Äî but what actually makes the language itself <em>protocol-oriented</em>?</p><p>In many ways, it comes down to how the standard library is designed ‚Äî which leverages features like protocol extensions to both optimize its own internal implementation, and to enable us to write our own functionality on top of its many protocols using those same extensions.</p><p>As an example, here‚Äôs how we could take the standard library‚Äôs <code>Collection</code> protocol (which all collections, such as <code>Array</code> and <code>Set</code>, conform to) and give it a <code>sum</code> method whenever the elements that are being stored conform to <code>Numeric</code> ‚Äî which is yet another standard library protocol that numeric types, such as <code>Int</code> and <code>Double</code>, conform to:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Collection</span> <span class="s-keyword">where</span> <span class="s-type">Element</span>: <span class="s-type">Numeric</span> {
    <span class="s-keyword">func</span> sum() -&gt; <span class="s-type">Element</span> {
        <span class="s-comment">// The reduce method is implemented using a protocol extension
        // within the standard library, which in turn enables us
        // to use it within our own extensions as well:</span>
        <span class="s-call">reduce</span>(<span class="s-number">0</span>, +)
    }
}</code></pre><p class="info">To learn more about why we‚Äôre able to pass the <code>+</code> operator directly to <code>reduce</code>, check out the <a href="https://www.swiftbysundell.com/clips/1">Swift Clips episode about first class functions</a>.</p><p>With the above in place, we can now easily sum up any collection of numbers, for example an array of <code>Int</code> values:</p><pre class="splash"><code><span class="s-keyword">let</span> numbers = [<span class="s-number">1</span>, <span class="s-number">2</span>, <span class="s-number">3</span>, <span class="s-number">4</span>]
numbers.<span class="s-call">sum</span>() <span class="s-comment">// 10</span></code></pre><p>So what makes protocols so incredibly useful is both that they enable us to create abstractions that let us hide implementation details behind shared interfaces ‚Äî which in turn makes it easier to share code that uses those interfaces ‚Äî and also that they enable us to customize and extend the standard library‚Äôs various APIs.</p><p>Protocols also have many more aspects and features that this Basics article didn‚Äôt cover (such as how they relate to testing and architecture). For a brief look at generic protocols, check out the <a href="https://www.swiftbysundell.com/basics/generics">Basics article about generics</a> ‚Äî and for other kinds of protocol-focused content, check out <a href="https://www.swiftbysundell.com/tags/protocols">this list</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/special/indie-support-weeks</guid><title>Indie Support Weeks</title><description>A two-week effort to help support indie developers shipping apps on Apple‚Äôs platforms who have been financially impacted by the COVID-19 pandemic.</description><link>https://www.swiftbysundell.com/special/indie-support-weeks</link><pubDate>Mon, 30 Mar 2020 11:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Independent app development has been an incredibly important part of the Apple developer community for decades. Not only do indie apps provide a ton of utility and delight for countless users around the world, they‚Äôre also often a major source of innovation on Apple‚Äôs platforms and beyond.</p><p>However, while working on your own projects can be greatly rewarding, being an indie developer can at times also be really difficult. Working alone or with a small team on increasingly sophisticated products can occasionally feel overwhelming, and without the financial security that a major company often provides ‚Äî every new project, feature, and release always comes with a certain amount of personal risk.</p><p>Right now, there‚Äôs no doubt that the global COVID-19 pandemic is causing tremendous amounts of uncertainty, hardship and suffering all around the world. There‚Äôs an enormous number of people who need help and support, and although many tech workers have been fortunate enough to be able to keep working remotely with (in the grand scheme of things) relative ease ‚Äî it‚Äôs times like these that can prove to be extra challenging for those who run their own independent business.</p><p>As people are self-isolating around the world, businesses are closing, and many of our normal day-to-day activities are put on hold, many indie developers have seen their sales numbers take a big hit. For some developers, who rely on the income from their apps as the main way to support themselves and their families, this loss of revenue can lead to tricky and difficult situations, to say the least.</p><p>When it comes to providing support and helping others in situations like this, it‚Äôs quite common to feel a bit <em>overwhelmed</em>. No single person can stop the current pandemic by themselves, or solve all of the world‚Äôs problems. No one can do everything. But everyone can do <em>something</em>.</p><p>So I decided that I wanted to do something for our community‚Äôs indies.</p><p>Normally, this site (and all of my other work) is funded by <a href="https://www.swiftbysundell.com/sponsor">sponsorships</a> ‚Äî through non-tracking, privacy-focused (and JavaScript-free) ads that I run on a weekly basis. But for the next two weeks there will be no ads on this site. Instead, each day, I‚Äôll promote a new indie app whose developer has been financially impacted by the current pandemic. For free, with no strings attached.</p><p>I hope that, with your support, these indie developers will regain some of that lost revenue through this effort, and that we will all get to discover a few great new apps as well.</p><p>Now, I was originally only planning to do this by myself ‚Äî just on this site, and for one week only. However, when I <a href="https://twitter.com/johnsundell/status/1240642670688698368">announced this project on Twitter</a>, I was met with an absolutely wonderful amount of support from all over the community. Thousands of people reached out offering their support in various ways, so I decided to make this an <a href="https://github.com/JohnSundell/indiesupportweeks">open effort</a> that anyone can now join.</p><p>Among the people who reached out to offer their support was <a href="https://twitter.com/_sa_s">Sven A. Schmidt</a>, creator of the indie app <a href="https://finestructure.co/hummingbird">Hummingbird</a>, who made an incredibly generous offer ‚Äî to help me pay for the weekly expenses of running this site so that I could extend this effort to two weeks instead of just one. So, thanks to Sven, I‚Äôll be able to help promote twice the amount of indie apps than I originally thought ‚Äî which I‚Äôm incredibly grateful for.</p><p><em>Now, Sven didn‚Äôt tell me to do this, but I also want to give a special shoutout to his fantastic app <a href="https://finestructure.co/hummingbird">Hummingbird</a>, which I personally use to make managing my Mac‚Äôs windows so much easier when working on a laptop. I highly recommend it.</em></p><p>So welcome to <em>Indie Support Weeks</em> ‚Äî two weeks during which you‚Äôll see indie apps being promoted by various channels all around the Apple developer community. Feel free to return to this site each day during these two weeks to find a new fantastic indie app, and if you see an app that you find interesting, please check it out to support its developer.</p><p>Also, I‚Äôd love to see you share your own <a href="https://github.com/JohnSundell/indiesupportweeks#apps">favorite indie apps</a> on Twitter and other social networks ‚Äî and if you do, feel free to use the hashtag <a href="https://twitter.com/hashtag/indiesupportweeks"><code>#IndieSupportWeeks</code></a> to make those tweets and posts easier to find for everyone who‚Äôs following this effort.</p><p>Thanks for reading, and I hope that you‚Äôll enjoy Indie Support Weeks! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2</guid><title>A guide to the SwiftUI layout system - Part 2</title><description>Let‚Äôs continue exploring the SwiftUI layout system by taking a look at a couple of more advanced techniques, such as how we can align views with dynamic dimensions and how to read a view‚Äôs geometry in order to build custom layouts.</description><link>https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2</link><pubDate>Sun, 29 Mar 2020 18:57:00 +0200</pubDate><content:encoded><![CDATA[<p>Let‚Äôs pick up where we left off <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">last week</a>, and continue to explore the SwiftUI layout system and how its various APIs and concepts work. This week, we‚Äôll take a look at a couple of more advanced techniques ‚Äî such as how we can align views with dynamic dimensions and how to read a view‚Äôs surrounding geometry in order to build completely custom layouts.</p><p class="info">The articles on this site are, for the most part, not tutorials. However, this article was (just like <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">part one</a>) written to enable you to easily code along within a SwiftUI-based iOS app project in Xcode, if you wish to do so. Each code sample will show a complete implementation, with no details omitted, except for the views that were built during part one.</p><h2>Handling dynamic content</h2><p>While certain parts of an app‚Äôs UI might be relatively static and predictable in terms of their content, chances are high that the majority of the views that we‚Äôll display within any given app are going to be highly dynamic.</p><p>Not only do we often have to account for content that‚Äôs not known at compile-time (for example text and images downloaded from a server), we also have to make sure that our views scale well according to localized strings and other resources that might differ depending on the environment that our app is run in.</p><p>Thankfully, SwiftUI was designed around the fact that most modern apps are indeed very dynamic ‚Äî and will automatically adapt the views that we declare according to their content, their environment (taking things like the current device size and color scheme into account), and other factors. However, sometimes we might need to make a few tweaks and adjustments to enable SwiftUI to scale and position our views exactly the way we want.</p><p>As an example, let‚Äôs continue working on our event view from <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1">last week</a>, by adding a row of <em>‚Äúinfo badges‚Äù</em> at the bottom of the screen ‚Äî which will display certain information about the current event to the user. To get started, we‚Äôll write a simple <code>EventInfoBadge</code> view using some of the layout techniques that were covered in part one ‚Äî such as using a <code>VStack</code> to group two views vertically, as well as rendering a system icon with a fixed size:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
        }
    }
}</code></pre><p>In isolation, the above implementation looks perfectly fine. However, if we now try to render a horizontal row consisting of three <code>EventInfoBadge</code> instances at the bottom of our <code>ContentView</code>, things won‚Äôt look as nice as we might‚Äôve expected:</p><pre data-preview="info-badge-row-first-iteration"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">Spacer</span>()
            <span class="s-type">HStack</span> {
                <span class="s-type">EventInfoBadge</span>(
                    iconName: <span class="s-string">"video.circle.fill"</span>,
                    text: <span class="s-string">"Video call available"</span>
                )
                <span class="s-type">EventInfoBadge</span>(
                    iconName: <span class="s-string">"doc.text.fill"</span>,
                    text: <span class="s-string">"Files are attached"</span>
                )
                <span class="s-type">EventInfoBadge</span>(
                    iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                    text: <span class="s-string">"Invites allowed"</span>
                )
            }
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p class="info">We‚Äôre again hard-coding all of our view‚Äôs strings and images, since this article is entirely focused on the SwiftUI layout system, and won‚Äôt cover data binding.</p><p>We have two main problems (which you can see by using the <em>Preview</em> button above) ‚Äî first, our icons are scaled using an incorrect aspect ratio, making them look stretched. Second, since each of our info badges are rendering different strings, they‚Äôll end up getting different widths ‚Äî which makes our UI look quite uneven.</p><p>Let‚Äôs first fix our icon stretching problem by applying the <code>.aspectRatio()</code> modifier to our <code>Image</code> ‚Äî telling it to fit its content into its bounds when resized, like this:</p><pre data-preview="aspect-ratio-fix"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                <span class="highlight">.<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)</span>
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
        }
    }
}</code></pre><p>Next, to make our three info badges occupy the same amount of horizontal space within our <code>ContentView</code>, we need to make each badge take up as much space as it possibly can within its container. That‚Äôll force the parent view (our bottom <code>HStack</code> in this case) to evenly divide the available space among each of its children, rather than giving the most space to the child with the longest text.</p><p>To make that happen, let‚Äôs give the <code>Text</code> within our <code>EventInfoBadge</code> an infinite max width ‚Äî which will make the layout system scale it as much as possible on the horizontal axis before splitting it up into multiple lines:</p><pre data-preview="text-fix"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
                <span class="highlight">.<span class="s-call">frame</span>(maxWidth: .<span class="s-dotAccess">infinity</span>)</span>
        }
    }
}</code></pre><p>With the above two fixes in place, our view now looks a lot nicer ‚Äî so let‚Äôs wrap our <code>EventInfoBadge</code> implementation up by center-aligning its text and by giving it some padding, a background color, and rounded corners:</p><pre data-preview="improved-visuals"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
                .<span class="s-call">frame</span>(maxWidth: .<span class="s-dotAccess">infinity</span>)
                .<span class="s-call">multilineTextAlignment</span>(.<span class="s-dotAccess">center</span>)
        }
        .<span class="s-call">padding</span>(.<span class="s-dotAccess">vertical</span>, <span class="s-number">10</span>)
        .<span class="s-call">padding</span>(.<span class="s-dotAccess">horizontal</span>, <span class="s-number">5</span>)
        .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
        .<span class="s-call">cornerRadius</span>(<span class="s-number">10</span>)
    }
}</code></pre><p>Finally, let‚Äôs again follow the same practice as we did during part one, and move our list of info badges out from our <code>ContentView</code> and into a new stand-alone component ‚Äî to prevent our content view from <a href="https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views">becoming massive</a>:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventInfoList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"video.circle.fill"</span>,
                text: <span class="s-string">"Video call available"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"doc.text.fill"</span>,
                text: <span class="s-string">"Files are attached"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                text: <span class="s-string">"Invites enabled"</span>
            )
        }
    }
}</code></pre><p>Rather than creating the above <code>HStack</code> inline within our <code>ContentView</code>, we can now simply initialize an instance of <code>EventInfoList</code> and we‚Äôre good to go:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">Spacer</span>()
            <span class="s-type">EventInfoList</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Plus, if we ever want to render the same type of list elsewhere within our app, we‚Äôll now be able to easily do that.</p><h2>Geometry, preferences, and layout dependencies</h2><p>However, it turns out that our <code>EventInfoBadge</code> still has one remaining issue. While our current implementation handles dynamic text lengths in terms of <em>width</em>, we still have to address the fact that our badges might end up with different <em>heights</em> ‚Äî for example if we make one of our texts slightly longer:</p><pre data-preview="vertical-issue"><code><span class="s-keyword">struct</span> EventInfoList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"video.circle.fill"</span>,
                text: <span class="s-string">"Video call available"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"doc.text.fill"</span>,
                text: <span class="s-string">"Files are attached"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                text: <span class="s-string"><span class="highlight">"Invites enabled, 5 people maximum"</span></span>
            )
        }
    }
}</code></pre><p>The above result might not be a deal-breaker, but our UI would arguably look a lot nicer if we instead were able to give each of our badges the exact same height. To make that happen, we‚Äôll have to come up with a way to notify our <code>EventInfoList</code> of the maximum height among its children, so that it then can resize the remaining child views to also occupy that same vertical space.</p><p>Since this is a piece of functionality that we‚Äôll likely want to reuse in different parts of our app (or even between projects), let‚Äôs implement it as a new stand-alone view called <code>HeightSyncedRow</code>. We‚Äôll start by using the <code>@ViewBuilder</code> <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/%23function-builders">function builder</a> attribute to enable our new view to be used with the same <a href="https://www.swiftbysundell.com/articles/building-dsls-in-swift">DSL</a>-like syntax that SwiftUI‚Äôs built-in containers and stacks are using. We‚Äôll then assign a <code>childHeight</code> to the result of that DSL expression, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HeightSyncedRow&lt;Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> content: <span class="s-type">Content</span>
    <span class="s-keyword">@State private var</span> childHeight: <span class="s-type">CGFloat</span>?

    <span class="s-keyword">init</span>(<span class="s-keyword">@ViewBuilder</span> content: () -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = <span class="s-call">content</span>()
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            content.<span class="s-call">frame</span>(height: childHeight)
        }
    }
}</code></pre><p>The great thing about using the same <code>@ViewBuilder</code> attribute as SwiftUI‚Äôs built-in views is that we can now go back to our <code>EventInfoList</code> and simply replace its <code>HStack</code> with our new <code>HeightSyncedRow</code> ‚Äî without having to make any additional changes:</p><pre class="splash"><code><span class="s-keyword">struct</span> EventInfoList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type"><span class="highlight">HeightSyncedRow</span></span> { 
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"video.circle.fill"</span>,
                text: <span class="s-string">"Video call available"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"doc.text.fill"</span>,
                text: <span class="s-string">"Files are attached"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                text: <span class="s-string">"Invites enabled, 5 people maximum"</span>
            )
        }
    }
}</code></pre><p>Next, let‚Äôs compute the <code>childHeight</code> value that our <code>HeightSyncedRow</code> will assign to each of its children. To do that, we‚Äôre going to make each child report its current height upwards through the view hierarchy, by using SwiftUI‚Äôs <em>Preferences system</em> ‚Äî that enables us to associate a given value with a preference key within a child view, which can then later be read within one of its parents.</p><p>Doing so first requires us to implement a <code>PreferenceKey</code>, which both includes the preference‚Äôs <code>defaultValue</code>, as well as a method for reducing two values (the previous and next) into one ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">private struct</span> HeightPreferenceKey: <span class="s-type">PreferenceKey</span> {
    <span class="s-keyword">static let</span> defaultValue: <span class="s-type">CGFloat</span> = <span class="s-number">0</span>

    <span class="s-keyword">static func</span> reduce(value: <span class="s-keyword">inout</span> <span class="s-type">CGFloat</span>,
                       nextValue: () -&gt; <span class="s-type">CGFloat</span>) {
        value = <span class="s-call">nextValue</span>()
    }
}</code></pre><p>Next, we‚Äôre going to use SwiftUI‚Äôs <code>GeometryReader</code> type ‚Äî which is a view that, among other things, enables us to read the size of the current view‚Äôs container. By embedding a <code>GeometryReader</code> as a given view‚Äôs <code>background</code>, we can perform that sort of reading without affecting that view‚Äôs layout in any way ‚Äî as a background view will always just occupy the same frame as the view that it‚Äôs attached to.</p><p>Finally, we‚Äôll wrap all of that functionality into a <code>View</code> extension that enables us to sync any view‚Äôs height into a given <code>Binding</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a> ‚Äî which gives us this implementation:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> syncingHeightIfLarger(than height: <span class="s-type">Binding</span>&lt;<span class="s-type">CGFloat</span>?&gt;) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">background</span>(<span class="s-type">GeometryReader</span> { proxy <span class="s-keyword">in</span>
            <span class="s-comment">// We have to attach our preference assignment to
            // some form of view, so we just use a clear color
            // here to make that view completely transparent:</span>
            <span class="s-type">Color</span>.<span class="s-property">clear</span>.<span class="s-call">preference</span>(
                key: <span class="s-type">HeightPreferenceKey</span>.<span class="s-keyword">self</span>,
                value: proxy.<span class="s-property">size</span>.<span class="s-property">height</span>
            )
        })
        .<span class="s-call">onPreferenceChange</span>(<span class="s-type">HeightPreferenceKey</span>.<span class="s-keyword">self</span>) {
            height.<span class="s-property">wrappedValue</span> = <span class="s-call">max</span>(height.<span class="s-property">wrappedValue</span> ?? <span class="s-number">0</span>, $0)
        }
    }
}</code></pre><p>With the above in place, we can now go back to our <code>HeightSyncedRow</code> and simply make it apply our new <code>syncingHeightIfLarger</code> modifier to its <code>content</code> view ‚Äî which in turn will make each of its children adopt the exact same height:</p><pre class="splash"><code><span class="s-keyword">struct</span> HeightSyncedRow&lt;Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> content: <span class="s-type">Content</span>
    <span class="s-keyword">@State private var</span> childHeight: <span class="s-type">CGFloat</span>?

    <span class="s-keyword">init</span>(<span class="s-keyword">@ViewBuilder</span> content: () -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = <span class="s-call">content</span>()
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            content<span class="highlight">.<span class="s-call">syncingHeightIfLarger</span>(than: $childHeight)</span>
                   .<span class="s-call">frame</span>(height: childHeight)
        }
    }
}</code></pre><p>However, if we now render our main <code>ContentView</code> again, we won‚Äôt actually be able to tell that all of our info badges have the same height ‚Äî since we‚Äôre applying the <code>.frame()</code> modifier <em>after</em> we‚Äôve given each of our info badges their background color. To illustrate that problem we can again use the classic <em>‚Äúred background color trick‚Äù</em>, just like we did in part one:</p><pre data-preview="vertical-sync"><code><span class="s-keyword">struct</span> HeightSyncedRow&lt;Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> content: <span class="s-type">Content</span>
    <span class="s-keyword">@State private var</span> childHeight: <span class="s-type">CGFloat</span>?

    <span class="s-keyword">init</span>(<span class="s-keyword">@ViewBuilder</span> content: () -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = <span class="s-call">content</span>()
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            content.<span class="s-call">syncingHeightIfLarger</span>(than: $childHeight)
                   .<span class="s-call">frame</span>(height: childHeight)
                   <span class="highlight">.<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)</span>
        }
    }
}</code></pre><p>Now, to fix the problem, let‚Äôs move our background assignment out from <code>EventInfoBadge</code> and into our <code>HeightSyncedRow</code> instead. That way, we‚Äôll be able to first assign each view‚Äôs frame, and then add its background ‚Äî which will give all of our background views the correct size. To still let <code>HeightSyncedRow</code> remain a reusable component, let‚Äôs add support for injecting a <code>Background</code> view as part of its initializer, which we‚Äôll then assign to each child ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HeightSyncedRow&lt;Background: <span class="s-type">View</span>, Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> background: <span class="s-type">Background</span>
    <span class="s-keyword">private let</span> content: <span class="s-type">Content</span>
    <span class="s-keyword">@State private var</span> childHeight: <span class="s-type">CGFloat</span>?

    <span class="s-keyword">init</span>(background: <span class="s-type">Background</span>,
         <span class="s-keyword">@ViewBuilder</span> content: () -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">background</span> = background
        <span class="s-keyword">self</span>.<span class="s-property">content</span> = <span class="s-call">content</span>()
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            content.<span class="s-call">syncingHeightIfLarger</span>(than: $childHeight)
                   .<span class="s-call">frame</span>(height: childHeight)
                   .<span class="s-call">background</span>(background)
        }
    }
}</code></pre><p>With the above in place, let‚Äôs now go back to <code>EventInfoList</code> and update it to pass the background view from <code>EventInfoBadge</code> when creating its <code>HeightSyncedRow</code> ‚Äî like this:</p><pre data-preview="streched-backgrounds"><code><span class="s-keyword">struct</span> EventInfoList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HeightSyncedRow</span>(background: <span class="s-type">Color</span>.<span class="s-property">secondary</span>.<span class="s-call">cornerRadius</span>(<span class="s-number">10</span>)) {
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"video.circle.fill"</span>,
                text: <span class="s-string">"Video call available"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"doc.text.fill"</span>,
                text: <span class="s-string">"Files are attached"</span>
            )
            <span class="s-type">EventInfoBadge</span>(
                iconName: <span class="s-string">"person.crop.circle.badge.plus"</span>,
                text: <span class="s-string">"Invites enabled, 5 people maximum"</span>
            )
        }
    }
}</code></pre><p>Now all that remains is to remove the background assignment from our <code>EventInfoBadge</code> and our implementation will be complete:</p><pre data-preview="finished"><code><span class="s-keyword">struct</span> EventInfoBadge: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
                .<span class="s-call">resizable</span>()
                .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
                .<span class="s-call">frame</span>(width: <span class="s-number">25</span>, height: <span class="s-number">25</span>)
            <span class="s-type">Text</span>(text)
                .<span class="s-call">frame</span>(maxWidth: .<span class="s-dotAccess">infinity</span>)
                .<span class="s-call">multilineTextAlignment</span>(.<span class="s-dotAccess">center</span>)
        }
        .<span class="s-call">padding</span>(.<span class="s-dotAccess">vertical</span>, <span class="s-number">10</span>)
        .<span class="s-call">padding</span>(.<span class="s-dotAccess">horizontal</span>, <span class="s-number">5</span>)
    }
}</code></pre><p>What we essentially had to deal with during this whole exercise is <em>layout dependencies</em> ‚Äî when one view‚Äôs layout depends on another view somehow. In our case, we couldn‚Äôt determine the final frame of each <code>EventInfoBadge</code> before first knowing the maximum height among them.</p><p>While layout dependencies should arguably be avoided whenever possible (as they tend to make our views quite tightly coupled), sometimes it‚Äôs necessary to establish a chain of communication between a set of child views and their parent ‚Äî and if we can do that through generic abstractions (such as the <code>HeightSyncedRow</code> that we built), then we can often find a way to manage our layout dependencies in a way that still makes our code modular and easy to change.</p><h2>Conclusion</h2><p>That concludes part two of this guide to the SwiftUI layout system. Next week, we‚Äôll wrap up this series by taking a look at how we can make our views scale even better across multiple screen sizes, and how to define layout priorities and even more custom layouts. But for now, let‚Äôs summarize what we covered in this part:</p><ul><li>The <code>.aspectRatio()</code> modifier lets us adjust how a view‚Äôs content gets scaled as the view is resized. It‚Äôs particularly useful for images.</li><li>Using <code>.frame(maxWidth: .infinity)</code> (or its height equivalent) can be a great way to tell a view to occupy as much space as it can within a given dimension ‚Äî which in turn can be used to ‚Äúforce‚Äù its parent to divide all available space evenly among its children.</li><li><code>GeometryReader</code> is a special view that reads its surrounding geometry, and lets us build custom layouts accordingly.</li><li>Using SwiftUI‚Äôs Preferences system, we can communicate upwards through a view hierarchy, for example in order to notify a parent of a child view‚Äôs computed size.</li></ul><p>I hope you enjoyed the second part of this series. If you did, feel free to share this article with a friend or on social media (that really helps support my work). Also, let me know if you have any questions, comments or feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p><strong><a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-3">You can find the third and final part of this article series here</a></strong>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/inline-wrapping-of-uikit-or-appkit-views-within-swiftui</guid><title>Tip: Inline wrapping of UIKit or AppKit views within SwiftUI</title><description></description><link>https://www.swiftbysundell.com/tips/inline-wrapping-of-uikit-or-appkit-views-within-swiftui</link><pubDate>Sat, 28 Mar 2020 19:30:00 +0100</pubDate><content:encoded><![CDATA[<p>The fact that any UIKit or AppKit view can be wrapped in order to become SwiftUI-compatible is incredibly useful, as that sort of provides an <em>‚Äúescape hatch‚Äù</em> for whenever SwiftUI does not yet natively support a given type of control or UI element.</p><p>However, if we need to rely on a lot of (for the lack of a better term) <em>‚Äúlegacy‚Äù</em> views, having to constantly write wrappers for each of them can start to become a bit tedious ‚Äî especially for simpler views that don‚Äôt require any sophisticated logic, or views that we only want to use in a single place.</p><p>For example, let‚Äôs say we wanted to use <code>UIActivityIndicatorView</code> to display a loading spinner within a SwiftUI-based iOS app. In order to do that, we‚Äôd have to write a wrapper that‚Äôll look something like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ActivityIndicator: <span class="s-type">UIViewRepresentable</span> {
    <span class="s-keyword">func</span> makeUIView(context: <span class="s-type">Context</span>) -&gt; <span class="s-type">UIActivityIndicatorView</span> {
        <span class="s-type">UIActivityIndicatorView</span>(style: .<span class="s-dotAccess">medium</span>)
    }

    <span class="s-keyword">func</span> updateUIView(<span class="s-keyword">_</span> view: <span class="s-type">UIActivityIndicatorView</span>, context: <span class="s-type">Context</span>) {
        view.<span class="s-call">startAnimating</span>()
    }
}</code></pre><p>While writing a wrapper that conforms to <code>UIViewRepresentable</code> (or <code>NSViewRepresentable</code> on the Mac) isn‚Äôt a huge task ‚Äî wouldn‚Äôt it be nice if we instead could just wrap any legacy view inline, right where we need to use it?</p><p>Let‚Äôs make that happen by writing a generic type that can be used to wrap any <code>UIView</code>. Let‚Äôs call it <code>Wrap</code>, and have it take two closures, each corresponding to one of the method requirements of <code>UIViewRepresentable</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Wrap&lt;Wrapped: <span class="s-type">UIView</span>&gt;: <span class="s-type">UIViewRepresentable</span> {
    <span class="s-keyword">typealias</span> Updater = (<span class="s-type">Wrapped</span>, <span class="s-type">Context</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">var</span> makeView: () -&gt; <span class="s-type">Wrapped</span>
    <span class="s-keyword">var</span> update: (<span class="s-type">Wrapped</span>, <span class="s-type">Context</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> makeView: <span class="s-keyword">@escaping @autoclosure</span> () -&gt; <span class="s-type">Wrapped</span>,
         updater update: <span class="s-keyword">@escaping</span> <span class="s-type">Updater</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">makeView</span> = makeView
        <span class="s-keyword">self</span>.<span class="s-property">update</span> = update
    }

    <span class="s-keyword">func</span> makeUIView(context: <span class="s-type">Context</span>) -&gt; <span class="s-type">Wrapped</span> {
        <span class="s-call">makeView</span>()
    }

    <span class="s-keyword">func</span> updateUIView(<span class="s-keyword">_</span> view: <span class="s-type">Wrapped</span>, context: <span class="s-type">Context</span>) {
        <span class="s-call">update</span>(view, context)
    }
}</code></pre><p class="info">To make an equivalent generic wrapper for macOS, simply replace all instances of ‚ÄúUI‚Äù with ‚ÄúNS‚Äù.</p><p>Note the usage of <a href="https://www.swiftbysundell.com/articles/using-autoclosure-when-designing-swift-apis"><code>@autoclosure</code></a> above, which will enable us to keep following the conventions of <code>UIViewRepresentable</code> and create our views lazily, without requiring any additional syntax at the call sites.</p><p>However, when updating our view, our new <code>Wrap</code> type currently requires us to always handle both the view itself, and the current <code>Context</code>. While having access to the <code>Context</code> argument might be important for some use cases, let‚Äôs make it optional ‚Äî by also introducing two convenience APIs that‚Äôll let us either accept just our view as a single argument, or to opt out of updates entirely in case our view is completely static:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Wrap</span> {
    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> makeView: <span class="s-keyword">@escaping @autoclosure</span> () -&gt; <span class="s-type">Wrapped</span>,
         updater update: <span class="s-keyword">@escaping</span> (<span class="s-type">Wrapped</span>) -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">makeView</span> = makeView
        <span class="s-keyword">self</span>.<span class="s-property">update</span> = { view, <span class="s-keyword">_ in</span> <span class="s-call">update</span>(view) }
    }

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> makeView: <span class="s-keyword">@escaping @autoclosure</span> () -&gt; <span class="s-type">Wrapped</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">makeView</span> = makeView
        <span class="s-keyword">self</span>.<span class="s-property">update</span> = { <span class="s-keyword">_</span>, <span class="s-keyword">_ in</span> }
    }
}</code></pre><p>With the above in place, we can now easily wrap any <code>UIView</code> completely inline, while also being able to update it whenever our underlying state changes ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">ViewModel</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            ...
            <span class="s-type">Wrap</span>(<span class="s-type">UIActivityIndicatorView</span>()) {
                <span class="s-keyword">if self</span>.<span class="s-property">viewModel</span>.<span class="s-property">isLoading</span> {
                    $0.<span class="s-call">startAnimating</span>()
                } <span class="s-keyword">else</span> {
                    $0.<span class="s-call">stopAnimating</span>()
                }
            }
        }
    }
}</code></pre><p>Very nice! This of course doesn‚Äôt mean that we should completely abandon building proper wrappers for certain views, but for simpler ones the above <code>Wrap</code> type is incredibly convenient.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/explicit-type-annotations</guid><title>Tip: Explicit type annotations</title><description></description><link>https://www.swiftbysundell.com/tips/explicit-type-annotations</link><pubDate>Thu, 26 Mar 2020 18:15:00 +0100</pubDate><content:encoded><![CDATA[<p>One of Swift‚Äôs most important features is, without a doubt, its type inference engine. Without it, we‚Äôd have to always explicitly specify the type of each of our variables, closure arguments, and other expressions ‚Äî which would dramatically increase the verbosity of our code.</p><p>However, even though Swift‚Äôs type inference engine is incredibly powerful, sometimes it does need a bit of a helping hand ‚Äî and in those situations, being able to add explicit type annotations can be really useful.</p><p>As an example, let‚Äôs take a look at a <code>Task</code> type, which enables us to run closures in the background using the <a href="https://www.swiftbysundell.com/clips/2"><code>DispatchQueue</code></a> API:</p><pre class="splash"><code><span class="s-keyword">struct</span> Task&lt;Input, Output&gt; {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">Output</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">var</span> body: (<span class="s-type">Input</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Output</span>

    <span class="s-keyword">func</span> perform(with input: <span class="s-type">Input</span>,
                 on queue: <span class="s-type">DispatchQueue</span> = .<span class="s-call">global</span>(),
                 then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        queue.<span class="s-call">async</span> {
            <span class="s-call">handler</span>(<span class="s-type">Result</span> { <span class="s-keyword">try self</span>.<span class="s-call">body</span>(input) })
        }
    }
}</code></pre><p class="info">The above type is just an example. For a much more thorough implementation of a task-based concurrency system, see <a href="https://www.swiftbysundell.com/articles/task-based-concurrency-in-swift">this article</a>.</p><p>Since the above <code>Task</code> type is a <a href="https://www.swiftbysundell.com/basics/generics">generic</a> (which is great in terms of type safety), the compiler will need to <em>specialize</em> each instance of it according to which <code>Input</code> and <code>Output</code> types are used at each given call site. While that‚Äôs exactly what the type inference engine can often take care of, completely automatically ‚Äî sometimes our code might not contain enough type information for that to be possible.</p><p>For example, here we‚Äôre constructing a <code>Task</code> for loading a <code>Config</code> model over the network, by taking a <code>URL</code> as input and then returning a decoded instance of our model as output:</p><pre class="splash"><code><span class="s-keyword">let</span> loadConfigTask = <span class="s-type">Task</span> { url <span class="s-keyword">in
    let</span> data = <span class="s-keyword">try</span> <span class="s-type">Data</span>(contentsOf: url)
    <span class="s-keyword">let</span> decoder = <span class="s-type">JSONDecoder</span>()
    <span class="s-keyword">return try</span> decoder.<span class="s-call">decode</span>(<span class="s-type">Config</span>.<span class="s-keyword">self</span>, from: data)
}</code></pre><p>If we try to compile the above code, the compiler will throw an error for both <code>Input</code> and <code>Output</code>, saying that neither of those two types could be inferred. So how can we fix this problem? One way is to explicitly type the <code>Task</code> instance itself, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> loadConfigTask = <span class="s-type">Task</span><span class="highlight">&lt;<span class="s-type">URL</span>, <span class="s-type">Config</span>&gt;</span> { url <span class="s-keyword">in</span>
    ...
}</code></pre><p>With the above change in place, no additional type information will be needed within our closure ‚Äî since the compiler will be able to connect the <code>Input</code> and <code>Output</code> types to our closure‚Äôs parameter and return type. However, if we wanted to, we could‚Äôve also opted to specify those closure types instead ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">let</span> loadConfigTask = <span class="s-type">Task</span> { <span class="highlight">(url: <span class="s-type">URL</span>) -&gt; <span class="s-type">Config</span></span> <span class="s-keyword">in</span>
    ...
}</code></pre><p>Above we‚Äôre specifying <em>both</em> the input and output type of our closure, however, if we‚Äôre able to reduce its body to something that the compiler can more easily type-check (for example a single expression) ‚Äî then we only have to specify the input type, and Swift‚Äôs type inference engine will take care of the rest:</p><pre class="splash"><code><span class="s-keyword">let</span> loadConfigTask = <span class="s-type">Task</span> { <span class="highlight">(url: <span class="s-type">URL</span>)</span> <span class="s-keyword">in</span>
    <span class="s-keyword">try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(
        <span class="s-type">Config</span>.<span class="s-keyword">self</span>,
        from: <span class="s-type">Data</span>(contentsOf: url)
    )
}</code></pre><p>The above techniques can be great to keep in mind when dealing with generic code, since they often enable us to resolve many different kinds of ambiguous type information.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1</guid><title>A guide to the SwiftUI layout system - Part 1</title><description>Let‚Äôs take a look at the SwiftUI layout system by starting to build a full-screen view from scratch. Along the way, we‚Äôll use many different techniques and APIs, which lets us explore the underlying rules of the SwiftUI layout system.</description><link>https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1</link><pubDate>Sun, 22 Mar 2020 20:55:00 +0100</pubDate><content:encoded><![CDATA[<p>Along with its declarative DSL and powerful data bindings, SwiftUI also features a brand new layout system, which in many ways combines the explicitness of manual frame calculations with the adaptiveness of Auto Layout. The result is a system that may appear simple at first glance, but that offers a huge amount of flexibility and power once we start combining its various building blocks into increasingly sophisticated layouts.</p><p>This week, let‚Äôs explore the SwiftUI layout system by starting to build a full-screen view from scratch. Along the way, we‚Äôll use many different kinds of layout techniques and APIs ‚Äî which together will demonstrate what the underlying rules of the SwiftUI layout system are, and how each of those rules relate to each other.</p><p class="info">The articles on this site are, for the most part, not tutorials. However, this article was written to enable you to easily code along within a new SwiftUI-based iOS app project in Xcode, if you wish to do so. Each code sample will show a complete implementation, with no details omitted.</p><h2>Setting a view‚Äôs frame</h2><p>Let‚Äôs get started with a simple <code>ContentView</code> that renders a calendar image as its <code>body</code>, by referencing one of Apple‚Äôs built-in <a href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview">SF Symbols</a>:</p><pre data-preview="centered-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
    }
}</code></pre><p>By default, SwiftUI lets each view pick its own size based on the container that it‚Äôs rendered in, and will then center it within its parent. So the result of the above code is a small icon rendered at the center of the screen ‚Äî not at the top-left or bottom-left as we might‚Äôve expected based on how UIKit and AppKit work.</p><p>Next, let‚Äôs make our icon a bit larger, let‚Äôs say 50x50 points. An initial idea on how to achieve that might be to use the <code>.frame()</code> <a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views/%23modifier-types">view modifier</a> to tell our view to adopt that size, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
    }
}</code></pre><p>However, while the above code <em>will</em> result in <em>a view</em> that‚Äôs 50x50 points, the size of our icon will remain exactly the same as it was before ‚Äî which might at first seem a bit strange. To explore the reason why that is, let‚Äôs give our view a background color so that we can easily see its on-screen frame:</p><pre data-preview="framed-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
    }
}</code></pre><p>With the above in place, we can see that our view is indeed the right size ‚Äî it‚Äôs just that our icon seems to be completely unaffected by our <code>.frame()</code> modifier, which is actually true. When applying a modifier to a view, we‚Äôre often not <em>modifying</em> the view at all, but rather encapsulating it in a new, transparent view. So when calling <code>.background()</code> above, we‚Äôre actually applying that background modifier to a new view that <em>wraps</em> our image, rather than to the image itself.</p><p>So, from a layout perspective, our image remains exactly the same ‚Äî it‚Äôs still centered within its parent ‚Äî only this time its parent is a new 50x50 transparent wrapper view instead of the main hosting view, but the rendered result is still the same.</p><p>Since SwiftUI views are responsible for determining their own size, we need to tell our image to resize itself to occupy all available space, rather than sticking to its default size. To make that happen, we simply have to apply the <code>.resizable()</code> modifier to it ‚Äî like this:</p><pre data-preview="resized-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
    }
}</code></pre><p>We now have a 50x50 calendar icon rendered at the center of the screen ‚Äî perfect!</p><h2>Applying padding</h2><p>Next, let‚Äôs take a look at how <em>padding</em> works in SwiftUI. Just like in other layout systems, like CSS, padding enables us to offset the contents of a view within its own frame. However, depending on where in our chain of view modifiers we apply our padding, we can get quite different results. For example, let‚Äôs start by applying a default set of padding by appending the <code>.padding()</code> modifier at the end of our chain:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
            .<span class="s-call">padding</span>()
    }
}</code></pre><p>Again, the result of the above might not be what we were expecting, as we‚Äôve essentially given our calendar icon <em>outer padding</em> ‚Äî additional whitespace that doesn‚Äôt include its background color. If we think about it, this is the exact same behavior as we encountered before when applying our <code>.frame()</code> modifier ‚Äî calling <code>.padding()</code> doesn‚Äôt actually mutate our earlier views and modifiers, it simply adds whitespace around the result of the preceding expressions.</p><p>In fact, if we add a second <code>.background()</code> modifier after the call to <code>.padding()</code>, this behavior becomes a lot more clear ‚Äî as the second background color will be rendered within the padding itself:</p><pre data-preview="padded-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
            .<span class="s-call">padding</span>()
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">blue</span>)
    }
}</code></pre><p>So if we‚Äôre looking to add <em>inner padding</em> that takes a view‚Äôs background into account, we need to apply that padding <em>before</em> adding the background ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">padding</span>()
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
    }
}</code></pre><p>To further illustrate that each modifier essentially wraps the view that it‚Äôs called on within yet another view ‚Äî if we were to instead call <code>.padding()</code> <em>before</em> applying our <code>.frame()</code> modifier, our icon would shrink, since that padding would be applied within our fixed 50x50 container ‚Äî forcing our resizable image to adopt a smaller size:</p><pre data-preview="smaller-calendar"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">padding</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
    }
}</code></pre><p>To finish our calendar icon view, let‚Äôs also a apply a bit of corner radius to it and make its foreground color white ‚Äî and finally extract all of that code into a new view called <code>CalendarView</code>, like this:</p><pre data-preview="finished-calendar"><code><span class="s-keyword">struct</span> CalendarView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">padding</span>()
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
            .<span class="s-call">cornerRadius</span>(<span class="s-number">10</span>)
            .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">white</span>)
    }
}</code></pre><p>In general, whenever we‚Äôve finished defining a UI piece that could act as its own self-contained building block, it‚Äôs often a good idea to extract that code into a new <code>View</code> implementation ‚Äî in order to <a href="https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views">avoid building massive views</a>.</p><h2>Stacks and spacers</h2><p>Like we took a look at in the <a href="https://www.swiftbysundell.com/clips/3">third episode of Swift Clips</a>, SwiftUI‚Äôs various stacks and spacers may at first seem quite simple and limited, but can actually be used to express a nearly infinite combination of layouts. To get started exploring how they work, let‚Äôs replace the <code>body</code> of our <code>ContentView</code> with our new <code>CalendarView</code> wrapped within a vertical stack:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">CalendarView</span>()
        }
    }
}</code></pre><p>What‚Äôs interesting is that the above <code>VStack</code> doesn‚Äôt actually affect our layout at all, since SwiftUI stacks don‚Äôt stretch themselves to occupy their parent ‚Äî instead they simply resize themselves according to the total size of their children, which in this case is just our <code>CalendarView</code> from before.</p><p>To actually move our <code>CalendarView</code>, we also have to add a <code>Spacer</code> to our stack. When placed within an <code>HStack</code> or <code>VStack</code>, spacers always occupy as much space that they can, which in this case will cause our <code>CalendarView</code> to be pushed to the top of the screen:</p><pre data-preview="calendar-at-top"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">CalendarView</span>()
            <span class="s-type">Spacer</span>()
        }
    }
}</code></pre><p>The cool thing about stacks is that they can be nested in order to express increasingly complex layouts without any form of manual frame calculations. For example, here‚Äôs how we could push our <code>CalendarView</code> to the top-leading corner of the screen, by nesting our above <code>VStack</code> within an <code>HStack</code> that also contains a <code>Spacer</code> (we‚Äôll also apply some outer padding to our view hierarchy as well, to inset our content a bit):</p><pre data-preview="calendar-at-leading-top"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">VStack</span> {
                <span class="s-type">CalendarView</span>()
                <span class="s-type">Spacer</span>()
            }
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Next, let‚Äôs add a <code>Text</code> to our view, in order to start turning it into a screen that can be used to view a set of details about a calendar event. Since we‚Äôll stick to only exploring SwiftUI‚Äôs layout system within this article, we‚Äôll hard-code the content of our <code>Text</code> for now:</p><pre data-preview="calendar-with-text"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">VStack</span> {
                <span class="s-type">CalendarView</span>()
                <span class="s-type">Spacer</span>()
            }
            <span class="s-type">Text</span>(<span class="s-string">"Event title"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">title</span>)
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Looking at the above code, we might expect our new <code>Text</code> to be rendered right next to our <code>CalendarView</code> ‚Äî and while that‚Äôs true on the horizontal axis, on the vertical axis it gets centered according to the full height of the screen. The reason for that is that our <code>Spacer</code> only affects the <code>VStack</code> in which our <code>CalendarView</code> is placed, so in order to get the same layout behavior for our <code>Text</code> as well, we‚Äôd either have to also wrap it within a <code>VStack</code> containing a spacer ‚Äî or we can simply tell our root <code>HStack</code> to align all of its children towards the top, like this:</p><pre data-preview="calendar-with-top-text"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span>(alignment: .<span class="s-dotAccess">top</span>) {
            <span class="s-type">VStack</span> {
                <span class="s-type">CalendarView</span>()
                <span class="s-type">Spacer</span>()
            }
            <span class="s-type">Text</span>(<span class="s-string">"Event title"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">title</span>)
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Similarly, we can also adjust how a <code>VStack</code> positions its children horizontally, for example in order to render a <code>Text</code> showing the location of our imagined calendar event below the event‚Äôs title ‚Äî while keeping both of those labels aligned according to the leading edge of our root view:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span>(alignment: .<span class="s-dotAccess">top</span>) {
            <span class="s-type">VStack</span> {
                <span class="s-type">CalendarView</span>()
                <span class="s-type">Spacer</span>()
            }
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(<span class="s-string">"Event title"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">title</span>)
                <span class="s-type">Text</span>(<span class="s-string">"Location"</span>)
            }
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>However, while the above layout works, it could arguably be simplified in order to be easier to mentally visualize. It‚Äôs not very intuitive that all of our view‚Äôs content is being pushed to the top by a <code>Spacer</code> that‚Äôs nested within two stacks, and in order to keep iterating on our view vertically, we would also ideally like our root stack to be a <code>VStack</code>.</p><p>So let‚Äôs again extract the body of our <code>ContentView</code> into a dedicated component while refactoring it. This time, let‚Äôs call our new view <code>EventHeader</code>, and make it a vertically centered <code>HStack</code> that adds a bit of spacing between its children ‚Äî which‚Äôll let us achieve an improved version of our earlier layout, all while simplifying our code as well:</p><pre data-preview="event-header"><code><span class="s-keyword">struct</span> EventHeader: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span>(spacing: <span class="s-number">15</span>) {
            <span class="s-type">CalendarView</span>()
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(<span class="s-string">"Event title"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">title</span>)
                <span class="s-type">Text</span>(<span class="s-string">"Location"</span>)
            }
            <span class="s-type">Spacer</span>()
        }
    }
}</code></pre><p>Going back to our <code>ContentView</code>, we can now turn its body into a single <code>VStack</code> containing our new <code>EventHeader</code> component, as well as our vertical spacer from before ‚Äî which is now placed in a much better location in terms of making our layout code easier to understand:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContentView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">EventHeader</span>()
            <span class="s-type">Spacer</span>()
        }.<span class="s-call">padding</span>()
    }
}</code></pre><p>Again, we‚Äôre following the same principle of continuously extracting the body of our <code>ContentView</code> into dedicated components whenever possible. Working that way can often enable us to naturally separate our UI into atomic parts, without requiring us to do a ton of architectural design work up-front.</p><h2>ZStacks and offset</h2><p>Finally, let‚Äôs take a quicker look at SwiftUI‚Äôs <code>ZStack</code> type, which enables us to stack a series of views in terms of depth, using a back-to-front order.</p><p>As an example, let‚Äôs say that we wanted to add support for displaying a small <em>‚Äúverified badge‚Äù</em> on top of our calendar view from before ‚Äî by placing a checkmark icon at its top-trailing corner. To implement that in a slightly more generic way, let‚Äôs extend <code>View</code> with an API that lets us wrap any view within a <code>ZStack</code> (which in of itself won‚Äôt affect the view‚Äôs layout), that‚Äôll also optionally contain our checkmark icon ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> addVerifiedBadge(<span class="s-keyword">_</span> isVerified: <span class="s-type">Bool</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span>(alignment: .<span class="s-dotAccess">topTrailing</span>) {
            <span class="s-keyword">self

            if</span> isVerified {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"checkmark.circle.fill"</span>)
                    .<span class="s-call">offset</span>(x: <span class="s-number">3</span>, y: -<span class="s-number">3</span>)
            }
        }
    }
}</code></pre><p>Note how a <code>ZStack</code> gives us full two-dimensional control over its <code>alignment</code>, which we can use to position our icon in the parent view‚Äôs top-trailing corner. We then also apply the <code>.offset()</code> modifier to our badge, which‚Äôll move it slightly outside of the bounds of its parent view.</p><p>With the above in place, we can now conditionally add our new badge to our <code>CalendarView</code> in case an <code>eventIsVerified</code> property was set to <code>true</code> (which we‚Äôll currently default to, for simplicity):</p><pre data-preview="verified-event"><code><span class="s-keyword">struct</span> CalendarView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> eventIsVerified = <span class="s-keyword">true

    var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Image</span>(systemName: <span class="s-string">"calendar"</span>)
            .<span class="s-call">resizable</span>()
            .<span class="s-call">frame</span>(width: <span class="s-number">50</span>, height: <span class="s-number">50</span>)
            .<span class="s-call">padding</span>()
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">red</span>)
            .<span class="s-call">cornerRadius</span>(<span class="s-number">10</span>)
            .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">white</span>)
            .<span class="s-call">addVerifiedBadge</span>(eventIsVerified)
    }
}</code></pre><p>Using a <code>ZStack</code> along with the <code>.offset()</code> modifier can be a great way to add various kinds of overlays to a view, without impacting that view‚Äôs own layout at all. We can use that technique to implement loading spinners, in-app notifications, and many other kinds of views that we wish to render on top of an existing view hierarchy.</p><h2>Conclusion</h2><p>That concludes part one of this guide to the SwiftUI layout system. In <a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2">part two</a>, we‚Äôll continue by taking a look at slightly more powerful ways to build completely custom layouts, but for now ‚Äî let‚Äôs summarize what we‚Äôve covered so far:</p><ul><li>SwiftUI‚Äôs core layout engine works by asking each child view to determine its own size based on the bounds of its parent, and then asks each parent to position its children within its own bounds.</li><li>View modifiers often wrap the current view within yet another view, which is why we can get completely different layout results depending on which order that we call our modifiers in.</li><li>Using the <code>.frame()</code> and <code>.padding()</code> modifiers lets us adjust a view‚Äôs size and internal margin, as long as that view is configured to resize itself accordingly.</li><li>Using <code>HStack</code>, <code>VStack</code> and <code>ZStack</code> we can stack views together either horizontally, vertically, or depth-wise.</li><li>Using <code>offset()</code> we can move a view without affecting its surroundings, which is very useful when implementing overlays and other kinds of overlapping views.</li></ul><p>I hope you enjoyed this first part. If you did, feel free to share this article with a friend or on social media, or check out this week‚Äôs sponsor (that really helps support my work). Also, let me know if you have any questions, comments or feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p><strong><a href="https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2">You can find part two of this article series here</a></strong>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/making-properties-overridable-only-in-debug-builds</guid><title>Tip: Making properties overridable only in debug builds</title><description>Implementing a property wrapper to enable certain properties to be overridden only in debug mode.</description><link>https://www.swiftbysundell.com/tips/making-properties-overridable-only-in-debug-builds</link><pubDate>Fri, 20 Mar 2020 19:50:00 +0100</pubDate><content:encoded><![CDATA[<p>Occasionally, we might want to override certain properties in order to facilitate testing, to be able to work on a new feature, or to debug a problem. That‚Äôs particularly common when using Storyboard-based view controllers, and other objects that the system initializes for us, as that typically prevents us from using <a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift/%23initializer-based">initializer-based dependency injection</a>.</p><p>In those situations, opening up properties to be mutated can be a pragmatic way to give us the flexibility that we need. For example, here we‚Äôre enabling a view controller‚Äôs <code>UserDefaults</code> and <code>Cache</code> instances to be overridden by making them mutable properties:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">var</span> userDefaults = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>
    <span class="s-keyword">var</span> cache = <span class="s-type">Cache</span>()
    ...
}</code></pre><p>However, while the above approach opens up doors in terms of flexibility, making a type contain additional <em>mutable state</em> can also end up causing new problems ‚Äî as we might now accidentally mutate our object in ways we didn‚Äôt expect within our production code.</p><p>Here‚Äôs a way to mitigate that problem, using Swift‚Äôs new <em><a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrappers</a></em> feature in combination with the <code>DEBUG</code> compiler flag. By creating a <code>DebugOverridable</code> property wrapper, we can enforce that the properties that we wish to override during testing and development are not actually overridden within any of our code that we‚Äôre shipping to production:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper
struct</span> DebugOverridable&lt;Value&gt; {
    <span class="s-preprocessing">#if DEBUG</span>
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span>
    <span class="s-preprocessing">#else</span>
    <span class="s-keyword">let</span> wrappedValue: <span class="s-type">Value</span>
    <span class="s-preprocessing">#endif</span>
}</code></pre><p class="info">Note that we could‚Äôve also used a custom compiler flag above, for example if we also needed to run our tests in release mode.</p><p>With the above property wrapper in place, we can now go back to the properties that we only wish to be mutable within <code>DEBUG</code>, and simply mark them with <code>@DebugOverridable</code> to make that happen ‚Äî no matter which form of abstraction that we use for our dependencies:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">@DebugOverridable
    var</span> userDefaults = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>
    <span class="s-keyword">@DebugOverridable
    var</span> fileManager: <span class="s-type">FileManagerProtocol</span> = <span class="s-type">FileManager</span>.<span class="s-property">default</span>
    <span class="s-keyword">@DebugOverridable
    var</span> cache = <span class="s-type">Cache</span>()
    <span class="s-keyword">@DebugOverridable
    var</span> dateProvider: () -&gt; <span class="s-type">Date</span> = <span class="s-type">Date</span>.<span class="s-property">init</span>
    ...
}</code></pre><p>Of course, in an ideal world, we would always be able to do initializer-based dependency injection, and then keep our objects as immutable as possible ‚Äî but when working with various frameworks and SDKs (including UIKit and AppKit), that‚Äôs not always possible ‚Äî even if there is now a <a href="https://developer.apple.com/documentation/uikit/uistoryboard/3213989-instantiateviewcontroller">dependency injection-friendly API</a> when using Storyboards, introduced in iOS 13.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/result</guid><title>Basics: The Result Type</title><description>A look at the standard library‚Äôs Result type, what kind of situations that it might be useful in, and tips and tricks that can be good to keep in mind when working with it.</description><link>https://www.swiftbysundell.com/basics/result</link><pubDate>Thu, 19 Mar 2020 12:30:00 +0100</pubDate><content:encoded><![CDATA[<p>The Swift standard library‚Äôs <code>Result</code> type enables us to express the outcome of a given operation ‚Äî whether it succeeded or failed ‚Äî using a single, unified type. Let‚Äôs take a look at what kind of situations that <code>Result</code> might be useful in, and a few tips and tricks that can be good to keep in mind when starting to work with that type.</p><p>While there are many different ways to model a <code>Result</code> type, the one that comes built into the Swift standard library is declared as a <a href="https://www.swiftbysundell.com/basics/generics">generic</a> <a href="https://www.swiftbysundell.com/basics/enums">enum</a> that‚Äôs <em>strongly typed</em> for both the successful value that the result might contain, as well as for any error that was encountered. It looks like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> Result&lt;Success, Failure&gt; <span class="s-keyword">where</span> <span class="s-type">Failure</span>: <span class="s-type">Error</span> {
    <span class="s-keyword">case</span> success(<span class="s-type">Success</span>)
    <span class="s-keyword">case</span> failure(<span class="s-type">Failure</span>)
}</code></pre><p>Like the above declaration shows, we can use <code>Result</code> to represent any success/failure combination, as long as the <code>Failure</code> type conforms to Swift‚Äôs <a href="https://www.swiftbysundell.com/basics/error-handling"><code>Error</code></a> protocol. So how can we use the above type in practice, and what are the advantages of doing so?</p><p>As an example, let‚Äôs take a look at <code>URLSession</code>, and one of its most commonly used APIs ‚Äî which uses a <a href="https://www.swiftbysundell.com/basics/closures">closure</a>-based design to return a <a href="https://www.swiftbysundell.com/basics/networking">network request‚Äôs</a> various results in an asynchronous fashion:</p><pre class="splash"><code><span class="s-keyword">let</span> url = <span class="s-type">URL</span>(string: <span class="s-string">"https://www.swiftbysundell.com"</span>)!

<span class="s-keyword">let</span> task = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTask</span>(with: url) {
    data, response, error <span class="s-keyword">in
    
    if let</span> error = error {
        <span class="s-comment">// Handle error</span>
        ...
    } <span class="s-keyword">else if let</span> data = data {
        <span class="s-comment">// Handle successful response data</span>
        ...
    }
}

task.<span class="s-call">resume</span>()</code></pre><p>While <code>URLSession</code> has evolved a lot over the years, and has an incredibly capable suite of APIs, deciding exactly how to handle the result of a network call can at times be a bit tricky ‚Äî since, like the above example shows, both the <code>data</code> and potential <code>error</code> results are passed into our closure as optionals ‚Äî which in turn requires us to unwrap each of those values every time we make a network call.</p><p>Let‚Äôs take a look at how using <code>Result</code> could help us solve that problem. We‚Äôll start by extending <code>URLSession</code> with a new API that passes a <code>Result&lt;Data, Error&gt;</code> value into its completion handler, rather than a group of optionals. To make that happen, we‚Äôll unwrap the optionals that the standard API gives us (similar to what we do above) in order to construct our <code>Result</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">URLSession</span> {
    <span class="s-keyword">func</span> dataTask(
        with url: <span class="s-type">URL</span>,
        handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) -&gt; <span class="s-type">URLSessionDataTask</span> {
        <span class="s-call">dataTask</span>(with: url) { data, <span class="s-keyword">_</span>, error <span class="s-keyword">in
            if let</span> error = error {
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            } <span class="s-keyword">else</span> {
                <span class="s-call">handler</span>(.<span class="s-call">success</span>(data ?? <span class="s-type">Data</span>()))
            }
        }
    }
}</code></pre><p class="info">Note how we‚Äôve simplified things a bit above, by ignoring the default API‚Äôs <code>URLResponse</code> value (using an underscore instead of its parameter name within our closure). That‚Äôs not something that we might always want to do, although for simpler networking tasks, there might not be a need to inspect that response value.</p><p>If we now go back to our earlier call site and update it to use our new API, we can see that our code becomes a lot more clear ‚Äî as we can now write completely separate code paths for both the <code>success</code> and <code>failure</code> case, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> task = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTask</span>(with: url) { result <span class="s-keyword">in
    switch</span> result {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> data):
        <span class="s-comment">// Handle successful response data</span>
        ...
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
        <span class="s-comment">// Handle error</span>
        ...
    }
}</code></pre><p>One interesting detail about the way we use <code>Result</code> above is that we‚Äôve specified its <code>Failure</code> type simply as <code>Error</code>. That means that any error can be passed into our result, which in turn limits our options for more specific error handling at the call site (since we don‚Äôt have any exhaustive list of potential errors to handle). While that‚Äôs tricky to change when working directly with a system API that, in turn, can throw any error ‚Äî when we‚Äôre building a more specific form of abstraction we can often design a more <a href="https://www.swiftbysundell.com/articles/providing-a-unified-swift-error-api">unified error API</a> for it.</p><p>For example, let‚Äôs say that we‚Äôre building a very simple image loader that‚Äôll let us load an image over the network, again using <code>URLSession</code>. But before we start actually implementing our loader itself, let‚Äôs first define an enum that lists all potential errors that it could encounter. For now, we‚Äôll only have two cases ‚Äî either a network error occurred, or the data that we downloaded turned out to be invalid:</p><pre class="splash"><code><span class="s-keyword">enum</span> ImageLoadingError: <span class="s-type">Error</span> {
    <span class="s-keyword">case</span> networkFailure(<span class="s-type">Error</span>)
    <span class="s-keyword">case</span> invalidData
}</code></pre><p>Then, when building our image loader, we can now specialize <code>Result</code> with the above error type ‚Äî which in turn enables us to send much more rich error information to our call sites:</p><pre class="splash"><code><span class="s-keyword">struct</span> ImageLoader {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">UIImage</span>, <span class="s-type">ImageLoadingError</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">var</span> session = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>

    <span class="s-keyword">func</span> loadImage(at url: <span class="s-type">URL</span>,
                   then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">let</span> task = session.<span class="s-call">dataTask</span>(with: url) { result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> data):
                <span class="s-keyword">if let</span> image = <span class="s-type">UIImage</span>(data: data) {
                    <span class="s-call">handler</span>(.<span class="s-call">success</span>(image))
                } <span class="s-keyword">else</span> {
                    <span class="s-call">handler</span>(.<span class="s-call">failure</span>(.<span class="s-dotAccess">invalidData</span>))
                }
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(.<span class="s-call">networkFailure</span>(error)))
            }
        }

        task.<span class="s-call">resume</span>()
    }
}</code></pre><p>The above design then enables us to handle each potential error in a much more granular fashion when using our image loader, for example like this:</p><pre class="splash"><code><span class="s-keyword">let</span> imageURL = <span class="s-type">URL</span>(string: <span class="s-string">"https://www.swiftbysundell.com/images/logo.png"</span>)!
<span class="s-keyword">let</span> imageLoader = <span class="s-type">ImageLoader</span>()

imageLoader.<span class="s-call">loadImage</span>(at: imageURL) { result <span class="s-keyword">in
    switch</span> result {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> image):
        <span class="s-comment">// Handle image</span>
        ...
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(.<span class="s-dotAccess">invalidData</span>):
        <span class="s-comment">// Handle an invalid data failure</span>
        ...
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(.<span class="s-call">networkFailure</span>(<span class="s-keyword">let</span> error)):
        <span class="s-comment">// Handle any network error</span>
        ...
    }
}</code></pre><p>Swift‚Äôs built-in <code>Result</code> type might just take a handful of lines of code to declare, but the patterns that it enables us to adopt are really powerful, and can lead to much simpler code ‚Äî especially when performing asynchronous operations, such as network calls.</p><p>To learn a lot more about result types in general, and some of the built-in type‚Äôs more powerful APIs, check out <em><a href="https://www.swiftbysundell.com/articles/the-power-of-result-types-in-swift">‚ÄúThe power of Result types in Swift‚Äù</a></em>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used</guid><title>Tip: When can a struct‚Äôs memberwise initializer be used?</title><description>How Swift‚Äôs memberwise initializers work, and when those initializers can be used.</description><link>https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used</link><pubDate>Tue, 17 Mar 2020 17:50:00 +0100</pubDate><content:encoded><![CDATA[<p>In Swift, types defined as structs automatically get a default initializer synthesized by the compiler ‚Äî a so-called <em>‚Äúmemberwise initializer‚Äù</em>, as the compiler will generate it based on the given struct‚Äôs <em>members</em> (that is, its stored properties).</p><p>For example, if we‚Äôve defined a <code>User</code> struct that has a <code>name</code> and a <code>preferences</code> property, we can use its memberwise initialize to create instances simply by passing values for those two properties:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> preferences: <span class="s-type">Preferences</span>
}

<span class="s-keyword">let</span> user = <span class="s-type">User</span>(name: <span class="s-string">"John"</span>, preferences: <span class="s-type">Preferences</span>())</code></pre><p>Computed properties, on the other hand, are completely ignored when the compiler synthesizes a memberwise initializer ‚Äî so even if we add one, we can still keep using the above initializer just like before:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> preferences: <span class="s-type">Preferences</span>
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span> { .<span class="s-dotAccess">user</span> }
}

<span class="s-keyword">let</span> user = <span class="s-type">User</span>(name: <span class="s-string">"John"</span>, preferences: <span class="s-type">Preferences</span>())</code></pre><p>As of Swift 5.1, memberwise initializers also take default property values into account ‚Äî meaning that if we give our <code>preferences</code> property a default value, we‚Äôll be able to create a <code>User</code> instance by just passing a <code>name</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> preferences = <span class="s-type">Preferences</span>()
}

<span class="s-keyword">let</span> user = <span class="s-type">User</span>(name: <span class="s-string">"John"</span>)</code></pre><p>One cool thing is that we can keep using a type‚Äôs memberwise initializer even if that type has <em>private</em> properties ‚Äî as long as those properties have a default value, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">private var</span> preferences = <span class="s-type">Preferences</span>()
}

<span class="s-keyword">let</span> user = <span class="s-type">User</span>(name: <span class="s-string">"John"</span>)</code></pre><p>However, if a private property doesn‚Äôt have a default value, we‚Äôll have to write that type‚Äôs initializer manually ‚Äî in order to be able to inject a value for that property from the outside:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">private var</span> preferences: <span class="s-type">Preferences</span>

    <span class="s-keyword">init</span>(name: <span class="s-type">String</span>, preferences: <span class="s-type">Preferences</span> = .<span class="s-keyword">init</span>()) {
        <span class="s-keyword">self</span>.<span class="s-property">name</span> = name
        <span class="s-keyword">self</span>.<span class="s-property">preferences</span> = preferences
    }
}</code></pre><p>One thing to keep in mind, though, is that memberwise initializers will never have an <a href="https://www.swiftbysundell.com/basics/access-control">access level</a> higher than <code>internal</code>, which means that we can only use them internally within the module in which their type is defined.</p><p>That might initially seem like a strange restriction, but it does have merits, as we should arguably always design explicit APIs for public consumption ‚Äî without making them tied to the internal structure of our data.</p><p>So, to sum up, we can use a struct‚Äôs memberwise initializer when:</p><ul><li>All of its members are either visible, or have a default value.</li><li>We are creating an instance within the same module that the struct is defined in.</li></ul><p>All other cases require us to manually implement an initializer, at least for now.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/writing-small-utility-functions-in-swift</guid><title>Writing small utility functions in Swift</title><description>Let‚Äôs take a look at how even the smallest utility functions can have quite a big impact on the way we write code on a day-to-day basis, by making common tasks easier and preferred patterns simpler.</description><link>https://www.swiftbysundell.com/articles/writing-small-utility-functions-in-swift</link><pubDate>Sun, 15 Mar 2020 21:15:00 +0100</pubDate><content:encoded><![CDATA[<p>Sometimes, it might seem like the only way to truly impact the overall state of a code base is to make big, sweeping changes ‚Äî such as changing its architecture, modifying the way data and actions flow through the system, or by adopting new frameworks.</p><p>However, while such bigger changes can sometimes be important to make, there‚Äôs also often a ton of value to be found in simply addressing more minor pain points, and by making it slightly smoother to iterate on our code during our day-to-day work.</p><p>This week, let‚Äôs take a look at one way of doing just that ‚Äî by writing small utility functions that make common tasks easier to perform, and preferred patterns simpler to adopt.</p><h2>Configuration closures</h2><p>A fair amount of the code within any given project is likely going to be dedicated to configuring certain objects for use ‚Äî especially when constructing views using object-oriented UI frameworks, such as UIKit. Like we took a look at in <a href="https://www.swiftbysundell.com/articles/encapsulating-configuration-code-in-swift">‚ÄúEncapsulating configuration code in Swift‚Äù</a>, finding neat ways to isolate such code can really improve the overall clarity of our actual logic, and this is an area in which utility functions can become especially useful.</p><p>As an example, let‚Äôs say that we‚Äôre currently using the quite popular pattern of structuring the setup of each view‚Äôs various subviews using <em><a href="https://www.swiftbysundell.com/articles/using-lazy-properties-in-swift/%23using-a-self-executing-closure">self-executing closures</a></em> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> HeaderView: <span class="s-type">UIView</span> {
    <span class="s-keyword">let</span> imageView: <span class="s-type">UIImageView</span> = {
        <span class="s-keyword">let</span> view = <span class="s-type">UIImageView</span>()
        view.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
        view.<span class="s-property">contentMode</span> = .<span class="s-dotAccess">scaleAspectFit</span>
        view.<span class="s-property">image</span> = .<span class="s-dotAccess">placeholder</span>
        <span class="s-keyword">return</span> view
    }()

    <span class="s-keyword">let</span> label: <span class="s-type">UILabel</span> = {
        <span class="s-keyword">let</span> view = <span class="s-type">UILabel</span>()
        view.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
        view.<span class="s-property">numberOfLines</span> = <span class="s-number">2</span>
        view.<span class="s-property">font</span> = .<span class="s-call">preferredFont</span>(forTextStyle: .<span class="s-dotAccess">headline</span>)
        <span class="s-keyword">return</span> view
    }()
    
    ...
}</code></pre><p>There‚Äôs nothing really wrong with the above implementation, but it would be great if we could reduce the amount of code associated with each property ‚Äî as each line that we add <em>‚Äúpushes‚Äù</em> our type‚Äôs actual implementation and logic further down. While there are a number of different approaches we could take here, such as <a href="https://www.swiftbysundell.com/articles/using-lazy-properties-in-swift/%23using-a-factory-method">using factory methods</a> instead of self-executing closures ‚Äî let‚Äôs see if we could write a simple utility function to help us make the above code a bit more compact, while still using the same basic pattern.</p><p>Let‚Äôs start by introducing a function called <code>configure</code>, which will take a value that we wish to configure, and a closure in which we can encapsulate all of our configuration code. We‚Äôll also mark that closure‚Äôs parameter with the <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift/%23simplifying-repeated-mutations"><code>inout</code></a> keyword to enable our new function to easily be used with value types:</p><pre class="splash"><code><span class="s-keyword">func</span> configure&lt;T&gt;(
    <span class="s-keyword">_</span> value: <span class="s-type">T</span>,
    using closure: (<span class="s-keyword">inout</span> <span class="s-type">T</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Void</span>
) <span class="s-keyword">rethrows</span> -&gt; <span class="s-type">T</span> {
    <span class="s-keyword">var</span> value = value
    <span class="s-keyword">try</span> <span class="s-call">closure</span>(&amp;value)
    <span class="s-keyword">return</span> value
}</code></pre><p>With the above in place, we can now go back to our <code>HeaderView</code>, and make its subview configuration code read a lot nicer:</p><pre class="splash"><code><span class="s-keyword">class</span> HeaderView: <span class="s-type">UIView</span> {
    <span class="s-keyword">let</span> imageView = <span class="s-call">configure</span>(<span class="s-type">UIImageView</span>()) {
        $0.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
        $0.<span class="s-property">contentMode</span> = .<span class="s-dotAccess">scaleAspectFit</span>
        $0.<span class="s-property">image</span> = .<span class="s-dotAccess">placeholder</span>
    }

    <span class="s-keyword">let</span> label = <span class="s-call">configure</span>(<span class="s-type">UILabel</span>()) {
        $0.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
        $0.<span class="s-property">numberOfLines</span> = <span class="s-number">2</span>
        $0.<span class="s-property">font</span> = .<span class="s-call">preferredFont</span>(forTextStyle: .<span class="s-dotAccess">headline</span>)
    }
    
    ...
}</code></pre><p>Gone are the local variables and the need to <code>return</code> each view after it‚Äôs been configured ‚Äî leading to more compact code that‚Äôs not any harder to read. In fact, it could even be argued that the above code is <em>easier</em> to read, since we‚Äôre now calling a function that‚Äôs explicitly named <em>‚Äúconfigure‚Äù</em> ‚Äî rather than relying on a convention, like we did before when using self-executing closures.</p><p>While there are a number of other approaches that we could‚Äôve taken in order to achieve a similar result, one advantage of our new <code>configure</code> function is that it‚Äôs completely generic, and can be used with any type ‚Äî whether it‚Äôs a <code>UIView</code> subclass, any other type of object, or even value types.</p><p>For example, here we‚Äôre using the exact same pattern as above when setting up a <code>URLRequest</code> value to be used to sync data when the user is on a WiFi-based connection:</p><pre class="splash"><code><span class="s-keyword">struct</span> SyncNetworkTask {
    <span class="s-keyword">var</span> request = <span class="s-call">configure</span>(<span class="s-type">URLRequest</span>(url: .<span class="s-dotAccess">syncEndpoint</span>)) {
        $0.<span class="s-property">httpMethod</span> = <span class="s-string">"PATCH"</span>
        $0.<span class="s-call">addValue</span>(<span class="s-string">"application/json"</span>,
            forHTTPHeaderField: <span class="s-string">"Content-Type"</span>
        )
        $0.<span class="s-property">allowsCellularAccess</span> = <span class="s-keyword">false</span>
    }
    
    ...
}</code></pre><p>The beauty of utility functions in general is that they in many cases enable us to unify various code patterns and styles across each code base ‚Äî by making the <em>right way</em> to perform a certain task (or at least the way that‚Äôs preferred within the project) also become the <em>easiest way</em>.</p><h2>The power of rethrowing functions</h2><p>One detail of the above <code>configure</code> function that can be easy to miss is the fact that it‚Äôs marked with the <code>rethrows</code> keyword. What that keyword does is that it tells the Swift compiler to only treat that function as <em>throwing</em> if the closure passed to it <em>also throws</em>.</p><p>That‚Äôs incredibly useful, as it both enables non-throwing use cases like the ones above (without having to use the <code>try</code> keyword in those cases), while also giving us the freedom to throw errors within our configuration closures if needed:</p><pre class="splash"><code><span class="s-keyword">let</span> webView = <span class="s-keyword">try</span> <span class="s-call">configure</span>(<span class="s-type">WKWebView</span>()) {
    <span class="s-keyword">let</span> html = <span class="s-keyword">try</span> <span class="s-call">loadBundledHTML</span>()
    <span class="s-keyword">try</span> $0.<span class="s-call">loadHTMLString</span>(html, baseURL: <span class="s-keyword">nil</span>)
    ...
}</code></pre><p>Whenever we‚Äôre designing any API that accepts synchronous closures, it‚Äôs definitely worth considering marking our functions with <code>rethrows</code> ‚Äî as doing so enables us to throw errors when needed, without making our non-throwing call sites any more complicated.</p><h2>Reducing boilerplate</h2><p>Besides letting us codify conventions, utility functions can also often help us avoid common mistakes, and enable us to reduce boilerplate ‚Äî even when it comes to more specific tasks, such as defining layouts and computing colors.</p><p>Especially when using Auto Layout in code, there‚Äôs a number of things that we always have to keep in mind ‚Äî such as remembering to tell each view not to translate its auto resizing mask into constraints (at least in most cases), and to activate each layout constraint that we define ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">let</span> label = <span class="s-type">UILabel</span>()
label.<span class="s-property">translatesAutoresizingMaskIntoConstraints</span> = <span class="s-keyword">false</span>
view.<span class="s-call">addSubview</span>(label)

<span class="s-type">NSLayoutConstraint</span>.<span class="s-call">activate</span>([
    label.<span class="s-property">topAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">topAnchor</span>),
    label.<span class="s-property">leadingAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">leadingAnchor</span>),
    ...
])</code></pre><p>Whenever we have to manually remember to write certain kinds of setup code over and over again, that‚Äôs typically a great candidate for a utility function. When it comes to the above example in particular, we‚Äôre not looking to introduce a brand new UI abstraction, or to completely change the way we write layout code ‚Äî our only goal is to make defining constraints <em>slightly</em> easier and more robust.</p><p>For example, we might opt for something as simple as a <code>UIView</code> extension that automatically prepares a given view to be used with Auto Layout, and then activates an array of constraints:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIView</span> {
    <span class="s-keyword">func</span> layout(using constraints: [<span class="s-type">NSLayoutConstraint</span>]) {
        translatesAutoresizingMaskIntoConstraints = <span class="s-keyword">false</span>
        <span class="s-type">NSLayoutConstraint</span>.<span class="s-call">activate</span>(constraints)
    }
}</code></pre><p>With just that tiny extension in place, we can actually make our original code read quite a bit nicer ‚Äî now looking like this:</p><pre class="splash"><code><span class="s-keyword">let</span> label = <span class="s-type">UILabel</span>()
view.<span class="s-call">addSubview</span>(label)

label.<span class="s-call">layout</span>(using: [
    label.<span class="s-property">topAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">topAnchor</span>),
    label.<span class="s-property">leadingAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">leadingAnchor</span>),
    ...
])</code></pre><p>That may seem like quite a minor change, but the nice thing about utility functions is that they don‚Äôt need to make an enormous impact on our code to be useful ‚Äî simply removing a few sources of boilerplate and potential mistakes is typically enough for them to be worth the effort.</p><p>Along those same lines, let‚Äôs take a look at another example in which we aim to make it as easy as possible to define dynamic colors that automatically adapt to whether the user‚Äôs device is currently running in either light mode or dark mode. The official iOS API for doing just that (apart from defining colors within asset catalogs) looks like this:</p><pre class="splash"><code><span class="s-keyword">let</span> backgroundColor = <span class="s-type">UIColor</span> { traitCollection <span class="s-keyword">in
    switch</span> traitCollection.<span class="s-property">userInterfaceStyle</span> {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">dark</span>:
        <span class="s-keyword">return</span> <span class="s-type">UIColor</span>(white: <span class="s-number">0.15</span>, alpha: <span class="s-number">1</span>)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">light</span>, .<span class="s-dotAccess">unspecified</span>:
        <span class="s-keyword">return</span> <span class="s-type">UIColor</span>(white: <span class="s-number">0.85</span>, alpha: <span class="s-number">1</span>)
    }
}</code></pre><p>That‚Äôs a quite nice API, but always having to write a closure containing a <code>switch</code> statement every time we want to define a dynamic color can quickly get tiresome ‚Äî so let‚Äôs again see if we can reduce some of the above verbosity using a utility function.</p><p>Since we‚Äôre essentially looking to define pairs of colors to use in either light or dark mode, let‚Äôs name our new function <code>colorPair</code>, and have it accept one <code>UIColor</code> to use for light mode, and another one for dark mode. We‚Äôll then call the official <code>UIColor</code> API and return the appropriate color for each <code>UIUserInterfaceStyle</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">func</span> colorPair(light: <span class="s-type">UIColor</span>, dark: <span class="s-type">UIColor</span>) -&gt; <span class="s-type">UIColor</span> {
    <span class="s-type">UIColor</span> { traitCollection -&gt; <span class="s-type">UIColor</span> <span class="s-keyword">in
        switch</span> traitCollection.<span class="s-property">userInterfaceStyle</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">dark</span>:
            <span class="s-keyword">return</span> dark
        <span class="s-keyword">case</span> .<span class="s-dotAccess">light</span>, .<span class="s-dotAccess">unspecified</span>:
            <span class="s-keyword">return</span> light
        }
    }
}</code></pre><p class="info">Worth noting is that the above function requires us to always create both of our colors at once, rather than only creating the one that‚Äôs needed for the current mode. However, that‚Äôs something that we could address using <a href="https://www.swiftbysundell.com/articles/using-autoclosure-when-designing-swift-apis"><code>@autoclosure</code></a> if needed.</p><p>With the above in place, we can reduce the amount of code needed to define each color pair quite drastically ‚Äî making our above <code>backgroundColor</code> declaration now look like this:</p><pre class="splash"><code><span class="s-keyword">let</span> backgroundColor = <span class="s-call">colorPair</span>(
    light: <span class="s-type">UIColor</span>(white: <span class="s-number">0.85</span>, alpha: <span class="s-number">1</span>),
    dark: <span class="s-type">UIColor</span>(white: <span class="s-number">0.15</span>, alpha: <span class="s-number">1</span>)
)</code></pre><p>Combine the above with another quick utility function that lets us define any gray scale <code>UIColor</code> using dot-syntax, and we‚Äôve got ourselves a really neat way of defining dynamic colors ‚Äî again without any huge abstraction or reinvention of the way colors work on iOS:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIColor</span> {
    <span class="s-keyword">static func</span> grayScale(<span class="s-keyword">_</span> white: <span class="s-type">CGFloat</span>,
                          alpha: <span class="s-type">CGFloat</span> = <span class="s-number">1</span>) -&gt; <span class="s-type">UIColor</span> {
        <span class="s-type">UIColor</span>(white: white, alpha: alpha)
    }
}

<span class="s-keyword">let</span> backgroundColor = <span class="s-call">colorPair</span>(
    light: .<span class="s-call">grayScale</span>(<span class="s-number">0.85</span>),
    dark: .<span class="s-call">grayScale</span>(<span class="s-number">0.15</span>)
)</code></pre><p>While writing utility functions such as the ones above, we might start to ask ourselves questions like <em>‚ÄúWhy aren‚Äôt the default APIs designed this way?‚Äù</em>. Like with most things in programming, designing great APIs is often about balancing a certain set of trade-offs.</p><p>While the standard APIs need to optimize both for flexibility, and for a certain degree of consistency with the rest of the platform‚Äôs SDK ‚Äî our own utility functions are free to use a more lightweight, specific design ‚Äî while still <em>complementing</em> the platforms‚Äôs native APIs, rather than aiming to replace them.</p><p>That way, we can use our new utility functions whenever possible, while easily be able to fall back to the standard platform APIs whenever we need more power or customization options.</p><h2>Conclusion</h2><p>Utility functions can help us codify our conventions, reduce boilerplate, and make common tasks easier to perform. By constantly looking for small ways that we can make writing code smoother and more enjoyable, we‚Äôll keep making our work gradually easier over time ‚Äî even though each change might seem relatively minor in isolation.</p><p>Of course, we shouldn‚Äôt go <em>too far</em>, and wrap every single task within some form of convenience API. The process of writing truly great utility functions is, in my opinion, really about identifying common bottlenecks and pain points, and then addressing those ‚Äî through lightweight APIs that complement the system frameworks, rather than aiming to replace them or completely hide them behind an abstraction.</p><p>What do you think? What are some of your favorite utility functions, and have you tried using some variant of the examples shown in this article already? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/meta/working-remotely</guid><title>Working remotely</title><description>My top five tips and learnings from years of working remotely.</description><link>https://www.swiftbysundell.com/meta/working-remotely</link><pubDate>Tue, 10 Mar 2020 19:15:00 +0100</pubDate><content:encoded><![CDATA[<p>Having the freedom to work remotely ‚Äî either from home, from a co-working space, or from anywhere else ‚Äî can be incredibly liberating, fun, and actually lead to a quite substantial boost in productivity and overall focus. However, working remotely can also be really challenging, especially in the beginning ‚Äî as it typically requires a much greater degree of personal accountability and organization than working on-site.</p><p>I‚Äôve personally been working remotely for many years, and I still am. So, in this article, I thought I‚Äôd share my top five tips and learnings as to how I try to get the very most out of my day-to-day work as a remote developer, writer, and podcaster.</p><p class="info">Like always with articles that are of a more personal nature, I just want to point out that the content of this article is based purely on my <strong>personal experiences</strong>, not on any form of wider research.</p><h2>Office hours</h2><p>One of the most challenging aspects of remote work, especially when working from home, is to clearly separate work time from free time. Doing so might not seem like a big deal in the beginning, especially for people who have flexible working hours ‚Äî but for me, it‚Äôs truly essential.</p><p>I love my job, and will often choose to code not only for work, but also as a hobby, and for fun. There‚Äôs of course nothing wrong with that, but when your home is also your place of work, there‚Äôs a risk that work simply becomes a bit <em>too accessible</em>.</p><p>A very common fallacy about remote work in general is that people who work remotely will often slack off or get distracted with non-work tasks ‚Äî but I‚Äôve found that I need to worry a lot more about <em>over-working</em> than <em>under-working</em>. Left unchecked, I could easily work for 10, 12 hours per day ‚Äî which isn‚Äôt very healthy in the long run.</p><p>To address this issue, I typically set up office hours that I try my very best to follow, and to have days on which I don‚Äôt work at all. If you‚Äôre only working from home temporarily, or if you‚Äôre part of a team that already has office hours in place, I‚Äôd recommend following those times as much as possible. Because regardless if you‚Äôre passionate about code or not, we all still need to rest.</p><h2>Setting up a dedicated workspace</h2><p>Continuing on the topic of work/free time separation, one of the easiest ways that I‚Äôve found to achieve a clear distinction between when I‚Äôm at work versus when I‚Äôm simply at home, is to set up a dedicated workspace within my home.</p><p>While I personally have a dedicated room within my apartment that‚Äôs essentially my office and podcast recording studio, that might not be possible for everyone. However, even you live in a small place or don‚Äôt have any spare rooms, there‚Äôs still often a way to set up a somewhat separate place for working.</p><p>For example, you might be able to put a small table or desk somewhere, or to mark a certain part of an existing table as your ‚Äúdesk‚Äù, at least during office hours. You might also be able to buy a cheap desk second-hand, or from a low-cost furniture store (I personally used the 15 Euro <em>‚ÄúLinnmon‚Äù</em> IKEA desk for my first few years of working remotely).</p><p>Not only does having a dedicated workspace have ergonomic advantages (working from a couch or bed can be cozy for a while, but often isn‚Äôt very comfortable or healthy in the long run), for me, it also lets me literally walk away from work when I‚Äôm done for the day ‚Äî which in turn enables me to truly relax when I‚Äôm not working.</p><h2>Maintaining routines</h2><p>When commuting and going to a specific place to work, we often tend to form our routines around going back and forth between our home and our workplace. From getting ready to leave in the morning, to perhaps picking up groceries on the way home from work ‚Äî there are many kinds of routines that can easily start to break down when working from home.</p><p>I think actively maintaining those kinds of routines is crucial in order for each day to have a certain degree of structure. Call me old fashioned, but I still get ready in the morning <em>as if</em> I was going to an office. I still have breakfast away from my computer, and I still take breaks for lunch and run my errands after I‚Äôm done with work for the day. I‚Äôve found that whenever I compromise those routines (for example by having lunch at my desk, or by starting to work immediately after I wake up), my stress levels rise significantly over time.</p><p>At the end of the day, these first three tips all come down to maintaining a solid work/life balance ‚Äî which may seem like basic stuff, but once you bring your work into your home, I think actively working on that balance and maintaining a robust set of routines becomes increasingly important ‚Äî at least for me.</p><h2>Daily and weekly planning</h2><p>Depending on whether you work as an independent developer or freelancer, or whether you‚Äôre part of a team, working remotely might also require you to take a lot more responsibility for organizing your own work.</p><p>While the way each person prefers to organize their tasks might differ quite a lot, one thing that I‚Äôve found particularly useful when it comes to staying focused and productive while working remotely is to make daily and weekly lists of tasks that I‚Äôm aiming to complete. Not only does that give me a more concrete plan for each day of work, it also gives me a sense of accomplishment whenever I can mark one of those tasks as done.</p><p>Like I wrote about in my <a href="https://www.swiftbysundell.com/meta/productivity"><em>‚ÄúProductivity‚Äù</em> article</a> back in 2017, apart from my main lists of tasks and goals, I also like to maintain a separate list of <em>‚ÄùQuick wins‚Äù</em> ‚Äî smaller tasks that I can pick up whenever I‚Äôm between two of my main tasks, or when I‚Äôm waiting for someone to complete a set of work that I depend on. By starting each day by completing a small task (like replying to an email, or making a small UI tweak, or doing a code review), I feel like I‚Äôm getting started on the right track.</p><h2>The wonder of video</h2><p>Whether its via Slack, GitHub or any other channel ‚Äî I think it‚Äôs fair to say that many developers are very used to communicating via text (and sometimes GIFs), so it‚Äôs quite easy for that to become the <em>only</em> means of communication and collaboration when working remotely. While text does has a certain efficiency to it, I also think that the value of having face-to-face meetings and discussions shouldn‚Äôt be under-estimated.</p><p>Thankfully, in this day and age, we have access to so many tools that let us run all sorts of meetings and collaboration sessions over audio, video, and beyond (VR meetings, anyone?). While many teams already do things like agile standups and daily planning sessions over video services like Skype, Slack and Google Hangouts ‚Äî there are a ton of other ways to incorporate audio and video calls into our daily work.</p><p>For example, if I feel like a few other developers and I are getting stuck in a text-based discussion on Slack or GitHub, I typically suggest that we jump on a quick call to discuss the problem face-to-face instead. That way we can resolve misunderstandings, show examples, and come up with a solution much quicker than if we kept going in circles via text.</p><p>Pair programming, designing architectures, workshops, and even having agile meetings like retrospectives are all tasks that are 100% possible (and can even be great!) to do over video call. All it takes is to try to foster a culture within the team that having a video call is not necessarily like having a <em>‚Äúserious meeting‚Äù</em> ‚Äî it can sort of be the remote working equivalent of a <em>‚Äúwater cooler discussion‚Äù</em>.</p><h2>Conclusion</h2><p>How much each individual person will enjoy working remotely will of course vary a lot from person to person. Some people will love the freedom and independence it brings, while others might find themselves missing the presence of coworkers, or struggling with maintaining a solid work/life balance over time.</p><p>Regardless, there are definitely ways to improve and refine most kinds of remote work situations, and while most of those improvements will likely require a fair amount of experimentation to get right ‚Äî I hope that this article has given you some inspiration as to what sort of practices that could be useful to explore.</p><p>Becoming a truly successful remote worker is also rarely something that can be done alone ‚Äî it requires everyone on the team to work together to get better at asynchronous communication, using tools like video calls to bridge the gap between each individual developer, and for everyone to give each other feedback and tips as to what‚Äôs working and what‚Äôs not. Because even though it might seem like remote work can be a somewhat lonely endeavor, it really doesn‚Äôt have to be.</p><p>Got questions, comments or feedback? Find me <a href="https://twitter.com/johnsundell">on Twitter</a> or contact me <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views</guid><title>Avoiding massive SwiftUI views</title><description>This week, let‚Äôs explore the topic of UI modularization in the context of SwiftUI, by taking a look at a few different techniques that can be useful in order to avoid trading Massive View Controllers for Massive Views.</description><link>https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views</link><pubDate>Sun, 8 Mar 2020 22:45:00 +0100</pubDate><content:encoded><![CDATA[<p>When writing any form of UI code, it can often be challenging to decide when and how to split various view implementations up into smaller pieces. It‚Äôs so easy to end up with views that each represent an entire screen or feature ‚Äî leading to code that‚Äôs often hard to change, refactor and reuse.</p><p>For UIKit-based apps (and to some extent AppKit-based ones, too), a very common manifestation of this problem is the <em>‚ÄúMassive View Controller‚Äù</em> syndrome ‚Äî which is when a view controller ends up taking on too many responsibilities, resulting in a <em>massive</em> implementation, both in terms of scope and line count.</p><p>Now, as we‚Äôre collectively moving towards SwiftUI as the go-to framework for building UIs for all of Apple‚Äôs platforms, it might first seem that this problem will simply go away. No view controllers, no problems, right? However, while SwiftUI‚Äôs overall design <em>does</em> encourage us to write more composable, decoupled code by default ‚Äî it still requires us to design and factor our view code in a way that doesn‚Äôt put too many responsibilities on individual types.</p><p>This week, let‚Äôs explore that topic, and take a look at a few different techniques that can be useful in order to avoid trading Massive View Controllers for <em>Massive Views</em>.</p><h2>Extract, reuse, repeat</h2><p>Since SwiftUI views are not concrete representations of pixels on screen, but rather lightweight descriptions of the various views that we wish to render, they often lend themselves quite well to being extracted into smaller pieces that can then be reused within various contexts.</p><p>For example, let‚Äôs say that we‚Äôre working on an app for browsing movies. To render a list of movies, we‚Äôve built a <code>MovieList</code> view ‚Äî which observes a <a href="https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift">view model</a> and renders its various subviews like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieList: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">MovieListViewModel</span>
    <span class="s-keyword">@Binding var</span> selectedMovie: <span class="s-type">Movie</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(viewModel.<span class="s-property">movies</span>, selection: $selectedMovie) { movie <span class="s-keyword">in</span>
            <span class="s-type">HStack</span> {
                <span class="s-type">Image</span>(uiImage: movie.<span class="s-property">image</span>)
                    .<span class="s-call">resizable</span>()
                    .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
                    .<span class="s-call">frame</span>(maxWidth: <span class="s-number">100</span>)
                <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                    <span class="s-type">Text</span>(movie.<span class="s-property">name</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                    <span class="s-type">HStack</span> {
                        <span class="s-type">Image</span>(systemName: <span class="s-string">"person"</span>)
                        <span class="s-type">Text</span>(<span class="s-string">"Director:"</span>)
                    }.<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
                    <span class="s-type">Text</span>(movie.<span class="s-property">director</span>)
                    <span class="s-type">HStack</span> {
                        <span class="s-type">Image</span>(systemName: <span class="s-string">"square.grid.2x2"</span>)
                        <span class="s-type">Text</span>(<span class="s-string">"Genre:"</span>)
                    }.<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
                    <span class="s-type">Text</span>(movie.<span class="s-property">genre</span>)
                }
            }
        }
    }
}</code></pre><p>If we only look at the above view‚Äôs <em>line count</em>, it isn‚Äôt really <em>massive</em> at all. However, it‚Äôs arguably quite difficult to quickly get a grasp of what the resulting UI will look like, given that we‚Äôre currently constructing all of our view‚Äôs various parts in one single place ‚Äî and that problem is likely to keep growing as we keep adding new UI variations and features.</p><p>Instead, let‚Äôs see if we can structure the above view as a collection of individual <em>components</em>, rather than as as a single unit. That way, we‚Äôd both be able to individually reuse those components within other views, and we should also be able to make our UI code read much nicer.</p><p>Let‚Äôs start with our <code>Image</code>, which doesn‚Äôt really warrant a new <code>View</code> implementation ‚Äî since we‚Äôre only applying a set of modifiers to make each image render as a smaller <em>‚Äúthumbnail‚Äù</em>. So, like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/configuring-swiftui-views">‚ÄúConfiguring SwiftUI views‚Äù</a></em>, let‚Äôs instead write an extension that groups those modifiers together in order to make them more semantically meaningful:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Image</span> {
    <span class="s-keyword">func</span> asThumbnail(withMaxWidth maxWidth: <span class="s-type">CGFloat</span> = <span class="s-number">100</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-call">resizable</span>()
            .<span class="s-call">aspectRatio</span>(contentMode: .<span class="s-dotAccess">fit</span>)
            .<span class="s-call">frame</span>(maxWidth: maxWidth)
    }
}</code></pre><p>Next, let‚Äôs refactor the subviews that render our two main pieces of information ‚Äî the movie‚Äôs director and genre ‚Äî into a single reusable component called <code>InfoView</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> InfoView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> icon: <span class="s-type">Image</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
            <span class="s-type">HStack</span> {
                icon
                <span class="s-type">Text</span>(title)
            }.<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">secondary</span>)
            <span class="s-type">Text</span>(text)
        }
    }
}</code></pre><p class="info">During the refactoring process, we also took the opportunity to make the above view completely unaware of its underlying model ‚Äî as it now simply renders an icon, a title and a text, rather than a <code>Movie</code> model. Check out <a href="https://www.swiftbysundell.com/articles/preventing-views-from-being-model-aware-in-swift">‚ÄúPreventing views from being model aware in Swift‚Äù</a> to learn more about that approach.</p><p>The above may seem like minor changes in the grand scheme of things, but if we now go back to our <code>MovieList</code> and update it to use our new components, we can see that we‚Äôve actually made its implementation quite a lot easier to read:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieList: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">MovieListViewModel</span>
    <span class="s-keyword">@Binding var</span> selectedMovie: <span class="s-type">Movie</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(viewModel.<span class="s-property">movies</span>, selection: $selectedMovie) { movie <span class="s-keyword">in</span>
            <span class="s-type">HStack</span> {
                <span class="s-type">Image</span>(uiImage: movie.<span class="s-property">image</span>).<span class="s-call">asThumbnail</span>()
                <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                    <span class="s-type">Text</span>(movie.<span class="s-property">name</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                    <span class="s-type">InfoView</span>(
                        icon: <span class="s-type">Image</span>(systemName: <span class="s-string">"person"</span>),
                        title: <span class="s-string">"Director:"</span>,
                        text: movie.<span class="s-property">director</span>
                    )
                    <span class="s-type">InfoView</span>(
                        icon: <span class="s-type">Image</span>(systemName: <span class="s-string">"square.grid.2x2"</span>),
                        title: <span class="s-string">"Genre:"</span>,
                        text: movie.<span class="s-property">genre</span>
                    )
                }
            }
        }
    }
}</code></pre><p>Even though we just barely reduced our list view‚Äôs line count during or refactor, we‚Äôve now set its implementation up to grow in a much more maintainable fashion, as we can now iterate on each of its individual components separately ‚Äî which typically goes a long way to prevent views from becoming massive.</p><p>However, let‚Äôs not stop there, because the beauty of SwiftUI‚Äôs highly composable design is that we can keep splitting our UI up into separate pieces until we‚Äôve reached a level of separation that we‚Äôre completely happy with. For example, rather than having <code>MovieList</code> itself be responsible for configuring each of its rows ‚Äî we could encapsulate all those subviews into yet another component, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieRow: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> movie: <span class="s-type">Movie</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(uiImage: movie.<span class="s-property">image</span>).<span class="s-call">thumbnail</span>()
            <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
                <span class="s-type">Text</span>(movie.<span class="s-property">name</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                <span class="s-type">InfoView</span>(
                    icon: <span class="s-type">Image</span>(systemName: <span class="s-string">"person"</span>),
                    title: <span class="s-string">"Director:"</span>,
                    text: movie.<span class="s-property">director</span>
                )
                <span class="s-type">InfoView</span>(
                    icon: <span class="s-type">Image</span>(systemName: <span class="s-string">"square.grid.2x2"</span>),
                    title: <span class="s-string">"Genre:"</span>,
                    text: movie.<span class="s-property">genre</span>
                )
            }
        }
    }
}</code></pre><p>While we could‚Äôve also made the above <code>MovieRow</code> model-agnostic, it‚Äôs questionable whether doing so would be worth it in this case ‚Äî as it essentially acts as a <em>‚Äúcomposition layer‚Äù</em> between our core components (such as <code>InfoView</code>) and our <code>Movie</code> model.</p><p>With the above in place, we can now go back to <code>MovieList</code> one more time, and heavily simplify its implementation. It can now simply be concerned with one single task ‚Äî being a list ‚Äî and let its subviews configure and manage themselves:</p><pre class="splash"><code><span class="s-keyword">struct</span> MovieList: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> viewModel: <span class="s-type">MovieListViewModel</span>
    <span class="s-keyword">@Binding var</span> selectedMovie: <span class="s-type">Movie</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">List</span>(viewModel.<span class="s-property">movies</span>,
            selection: $selectedMovie,
            rowContent: <span class="s-type">MovieRow</span>.<span class="s-property">init</span>
        )
    }
}</code></pre><p>Since SwiftUI will automatically re-render each view whenever any of its data dependencies change, we don‚Äôt need to manually manage any form of state between our <code>MovieList</code> and its subviews ‚Äî it‚Äôs all being taken care of by the framework.</p><h2>Binding mutable state</h2><p>However, what if we need one of our subviews to be able to mutate some form of state that‚Äôs owned by its parent? While SwiftUI always propagates state changes <em>downward</em> through our view hierarchy, to also make changes <em>upward</em>, we‚Äôll need to create <em>two-way bindings</em> that‚Äôll let updates flow in both directions.</p><p>Let‚Äôs now say that we‚Äôre working on an app for ordering some form of products, and that we‚Äôre looking to refactor our main <code>OrderForm</code> to become more modular ‚Äî similar to what we did to our <code>MovieList</code> view above. This view uses SwiftUI‚Äôs built-in <code>Form</code> API to render a series of sections that each contain input controls for mutating the user‚Äôs current <code>Order</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> OrderForm: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> productManager: <span class="s-type">ProductManager</span>
    <span class="s-keyword">var</span> handler: (<span class="s-type">Order</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">@State private var</span> order = <span class="s-type">Order</span>()

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">Form</span> {
                <span class="s-type">Section</span>(header: <span class="s-type">Text</span>(<span class="s-string">"Shipping address"</span>)) {
                    <span class="s-type">TextField</span>(<span class="s-string">"Name"</span>, text: $order.<span class="s-property">recipient</span>)
                    <span class="s-type">TextField</span>(<span class="s-string">"Address"</span>, text: $order.<span class="s-property">address</span>)
                    <span class="s-type">TextField</span>(<span class="s-string">"Country"</span>, text: $order.<span class="s-property">country</span>)
                }
                <span class="s-type">Section</span>(header: <span class="s-type">Text</span>(<span class="s-string">"Product"</span>)) {
                    <span class="s-type">Picker</span>(
                        selection: $order.<span class="s-property">product</span>,
                        label: <span class="s-type">Text</span>(<span class="s-string">"Select product"</span>),
                        content: {
                            <span class="s-type">ForEach</span>(productManager.<span class="s-property">products</span>) { product <span class="s-keyword">in</span>
                                <span class="s-type">Text</span>(product.<span class="s-property">name</span>).<span class="s-call">tag</span>(product)
                            }
                        }
                    )
                }
                ...
                <span class="s-type">Button</span>(
                    action: { <span class="s-keyword">self</span>.<span class="s-call">handler</span>(<span class="s-keyword">self</span>.<span class="s-property">order</span>) },
                    label: { <span class="s-type">Text</span>(<span class="s-string">"Place order"</span>) }
                )
            }
        }
    }
}</code></pre><p class="info">Note the use of <code>NavigationView</code> above, which is needed when using the default <code>Picker</code> style on iOS ‚Äî as such a picker pushes its view for selecting an option onto the current navigation stack.</p><p>So how could we split the above view up while still enabling each part to mutate the same <code>Order</code> state? Let‚Äôs take some inspiration from SwiftUI‚Äôs built-in views, and use the <code>@Binding</code> <a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift">property wrapper</a> to create two-way bindings between our new subviews and their parent‚Äôs state. Here‚Äôs how we might do just that when extracting our form‚Äôs <em>‚ÄúShipping address‚Äù</em> section:</p><pre class="splash"><code><span class="s-keyword">struct</span> ShippingAddressFormSection: <span class="s-type">View</span> {
    <span class="s-keyword">@Binding var</span> order: <span class="s-type">Order</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Section</span>(header: <span class="s-type">Text</span>(<span class="s-string">"Shipping address"</span>)) {
            <span class="s-type">TextField</span>(<span class="s-string">"Name"</span>, text: $order.<span class="s-property">recipient</span>)
            <span class="s-type">TextField</span>(<span class="s-string">"Address"</span>, text: $order.<span class="s-property">address</span>)
            <span class="s-type">TextField</span>(<span class="s-string">"Country"</span>, text: $order.<span class="s-property">country</span>)
        }
    }
}</code></pre><p>Above we give our new stand-alone section access to the complete <code>Order</code> model, as it needs to mutate several of its properties. However, for the <em>‚ÄúProduct‚Äù</em> section, we‚Äôll take a slightly different approach ‚Äî and only give it access to an array of products to pick from, and a binding <code>Product</code> value to assign the user‚Äôs selection to:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductPickerFormSection: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> products: [<span class="s-type">Product</span>]
    <span class="s-keyword">@Binding var</span> selection: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Section</span>(header: <span class="s-type">Text</span>(<span class="s-string">"Product"</span>)) {
            <span class="s-type">Picker</span>(selection: $selection, label: <span class="s-type">Text</span>(<span class="s-string">"Select product"</span>)) {
                <span class="s-type">ForEach</span>(products) { product <span class="s-keyword">in</span>
                    <span class="s-type">Text</span>(product.<span class="s-property">name</span>).<span class="s-call">tag</span>(product)
                }
            }
        }
    }
}</code></pre><p>Once we‚Äôve extracted all of our sections like we did above, we can then go back to our <code>OrderForm</code> and simply have it pass binding references to its own <code>Order</code> state when creating its sections ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> OrderForm: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> productManager: <span class="s-type">ProductManager</span>
    <span class="s-keyword">var</span> handler: (<span class="s-type">Order</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">@State private var</span> order = <span class="s-type">Order</span>()

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">Form</span> {
                <span class="s-type">ShippingAddressFormSection</span>(order: $order)
                <span class="s-type">ProductPickerFormSection</span>(
                    products: productManager.<span class="s-property">products</span>,
                    selection: $order.<span class="s-property">product</span>
                )
                ...
                <span class="s-type">Button</span>(
                    action: { <span class="s-keyword">self</span>.<span class="s-call">handler</span>(<span class="s-keyword">self</span>.<span class="s-property">order</span>) },
                    label: { <span class="s-type">Text</span>(<span class="s-string">"Place order"</span>) }
                )
            }
        }
    }
}</code></pre><p>The fact that we can turn any form of local <code>State</code> property into a two-way <code>Binding</code> value, simply by prefixing it with <code>$</code> (which accesses its <em><a href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift/%23projected-values">projected value</a></em>), is incredibly powerful ‚Äî as it gives us complete freedom as to how we split our views up, even if those subviews then need to mutate their parent‚Äôs state.</p><h2>Out-of-body delegation</h2><p>Finally, let‚Äôs take a look at how we could break some of our larger <code>View</code> implementations up by delegating certain tasks to external objects. For example, let‚Äôs say that we‚Äôre building a <code>HomeView</code> that acts as the initial navigation destination for an app. It shows a menu implemented as a <code>List</code>, which in turn contains a series of rows each wrapped within a <code>NavigationLink</code>, to enable new views to be pushed onto the navigation stack ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span> {
                <span class="s-type">NavigationLink</span>(destination: ...) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Catalog"</span>, icon: .<span class="s-dotAccess">browse</span>)
                }
                <span class="s-type">NavigationLink</span>(destination: ...) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Recommendations"</span>, icon: .<span class="s-dotAccess">star</span>)
                }
                <span class="s-type">NavigationLink</span>(destination: ...) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Profile"</span>, icon: .<span class="s-dotAccess">user</span>)
                }
                ...
            }.<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Home"</span>)
        }
    }
}</code></pre><p>Now the question is, how should we create the above <code>destination</code> views? One option would of course be to create each destination inline within the above view itself ‚Äî however, doing so would not only risk making our <code>HomeView</code> quite massive, it would also require it to carry all of the dependencies needed by each of its destinations.</p><p>While we‚Äôll take a closer look at various ways of managing dependencies when using SwiftUI in much more detail in upcoming articles, one way to prevent <code>HomeView</code> from taking on too many responsibilities in this case would be to introduce a separate object that can handle the complexity of creating all of our destinations.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift/">‚ÄúDependency injection using factories in Swift‚Äù</a></em> and <em><a href="https://www.swiftbysundell.com/articles/managing-objects-using-locks-and-keys-in-swift/">‚ÄúManaging objects using Locks and Keys in Swift‚Äù</a></em>, using the <em>factory pattern</em> can be a great way to decouple various views and screens from the rest of an app ‚Äî as it lets us move the creation of navigation destinations away from where the navigation is triggered. Here‚Äôs how we might do exactly that for our <code>HomeView</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> factory: <span class="s-type">HomeViewFactory</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span> {
                <span class="s-type">NavigationLink</span>(destination: factory.<span class="s-call">makeCatalogView</span>()) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Catalog"</span>, icon: .<span class="s-dotAccess">browse</span>)
                }
                <span class="s-type">NavigationLink</span>(destination: factory.<span class="s-call">makeRecommendationsView</span>()) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Recommendations"</span>, icon: .<span class="s-dotAccess">star</span>)
                }
                <span class="s-type">NavigationLink</span>(destination: factory.<span class="s-call">makeProfileView</span>()) {
                    <span class="s-type">MenuRow</span>(title: <span class="s-string">"Profile"</span>, icon: .<span class="s-dotAccess">user</span>)
                }
                ...
            }.<span class="s-call">navigationBarTitle</span>(<span class="s-string">"Home"</span>)
        }
    }
}</code></pre><p>The <code>HomeViewFactory</code> that we use above can then contain all of the dependencies needed by our destinations, and be responsible for setting up each destination view in a way that leaves <code>HomeView</code> completely unaware of those details:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeViewFactory {
    <span class="s-keyword">var</span> database: <span class="s-type">Database</span>
    <span class="s-keyword">var</span> networkController: <span class="s-type">NetworkController</span>
    ...

    <span class="s-keyword">func</span> makeCatalogView() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-keyword">let</span> viewModel = <span class="s-type">CatalogViewModel</span>(database: database, ...)
        <span class="s-keyword">return</span> <span class="s-type">CatalogView</span>(viewModel: viewModel)
    }
    
    <span class="s-keyword">func</span> makeRecommendationsView() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        ...
    }
    
    <span class="s-keyword">func</span> makeProfileView() -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        ...
    }
}</code></pre><p>While we probably don‚Äôt want to move <em>all</em> of our view creation code into factory types, delegating the setup of complex navigation hierarchies to <em>some form</em> of external object can often be a good idea, and the same is true for other types of complex tasks as well ‚Äî such as event handling, input validation, and so on.</p><h2>Conclusion</h2><p>The fact that SwiftUI was designed with composition and two-way data binding in mind gives us an enormous amount of flexibility when it comes to how we structure our views and their various components. By starting to break our UIs up into smaller building blocks early, and by making our lower-level components as unaware of our domain-specific models as possible, we can often achieve a very flexible setup that lets us tweak and iterate on our UI with ease.</p><p>While we should always think twice before introducing new abstractions, delegating certain tasks to external objects could also help us make our top-level views simpler ‚Äî as doing so could let them simply focus on connecting a set of UI components to a specific piece of state, and to mutate that state according to user input.</p><p>What do you think? How do you plan to avoid massive SwiftUI views, both now and as you continue to iterate on your code base? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either <a href="https://twitter.com/johnsundell">on Twitter</a> or via <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-swifts-built-in-randomization-apis</guid><title>Tip: Using Swift‚Äôs built-in randomization APIs</title><description></description><link>https://www.swiftbysundell.com/tips/using-swifts-built-in-randomization-apis</link><pubDate>Wed, 4 Mar 2020 21:30:00 +0100</pubDate><content:encoded><![CDATA[<p>Swift offers quite a few different APIs that enable us to add various randomness features to our code. For example, let‚Äôs say that we wanted to generate a random number between 0 and 99 ‚Äî that can be done simply by calling the static <code>random()</code> method on different numeric types, such as <code>Int</code> and <code>Double</code>:</p><pre class="splash"><code><span class="s-keyword">let</span> randomInt = <span class="s-type">Int</span>.<span class="s-call">random</span>(in: <span class="s-number">0</span>..&lt;<span class="s-number">100</span>)
<span class="s-keyword">let</span> randomDouble = <span class="s-type">Double</span>.<span class="s-call">random</span>(in: <span class="s-number">0</span>..&lt;<span class="s-number">100</span>)</code></pre><p>Worth noting is that when generating random <code>Double</code> or <code>Float</code> values (or any other non-integer type), fractional values are also included. So while the above <code>randomInt</code> has 100 potential values, <code>randomDouble</code> can contain any valid <code>Double</code> from <code>0.0</code> to <code>99.99...</code>, giving us an amount of potential values that‚Äôs several orders of magnitude larger.</p><p>Swift‚Äôs various collections also ship with built-in randomization APIs as well. For example, here‚Äôs how we could extract a random element, or completely shuffle a collection:</p><pre class="splash"><code><span class="s-comment">// Drawing a random card from a deck</span>
<span class="s-keyword">let</span> deckOfCards: [<span class="s-type">Card</span>] = <span class="s-call">makeDeck</span>()
<span class="s-keyword">let</span> card = deckOfCards.<span class="s-call">randomElement</span>()

<span class="s-comment">// Shuffling a list of players to randomize who gets to go first</span>
<span class="s-keyword">var</span> players: [<span class="s-type">Player</span>] = <span class="s-call">loadPlayers</span>()
players.<span class="s-call">shuffle</span>()</code></pre><p class="info">Note that <code>randomElement</code> returns an optional, since we might be calling it on an empty collection.</p><p>One thing to keep in mind when adding randomization to a piece of code is how doing so might impact our ability to test that code. When writing unit tests, we‚Äôd ideally like to control the entire environment that our code is executed in, as to not cause <a href="https://www.swiftbysundell.com/articles/reducing-flakiness-in-swift-tests">flakiness</a> (when tests start to sporadically fail) ‚Äî and randomness is kind of the exact opposite of that sort of control.</p><p>To work around that problem, we could use <a href="https://www.swiftbysundell.com/articles/simple-swift-dependency-injection-with-functions">function-based dependency injection</a> to inject the randomization functions that we‚Äôre using into the types that we call them from. That way we‚Äôll later be able to override those functions with <a href="https://www.swiftbysundell.com/articles/mock-free-unit-tests-in-swift/%23functional-behavior">predictable stubs</a> within our tests.</p><p>For example, here we‚Äôre using that form of dependency injection to inject a <code>Randomizer</code> function into an <code>AudioPlayer</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> AudioPlayer {
    <span class="s-keyword">typealias</span> Randomizer = (<span class="s-type">Range</span>&lt;<span class="s-type">Int</span>&gt;) -&gt; <span class="s-type">Int</span>

    <span class="s-keyword">private let</span> playlist: <span class="s-type">Playlist</span>
    <span class="s-keyword">private let</span> randomizer: <span class="s-type">Randomizer</span>

    <span class="s-keyword">init</span>(playlist: <span class="s-type">Playlist</span>,
         randomizer: <span class="s-keyword">@escaping</span> <span class="s-type">Randomizer</span> = <span class="s-type">Int</span>.<span class="s-property">random</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">playlist</span> = playlist
        <span class="s-keyword">self</span>.<span class="s-property">randomizer</span> = randomizer
    }

    <span class="s-keyword">func</span> playRandomSong() {
        <span class="s-keyword">let</span> index = <span class="s-call">randomizer</span>(<span class="s-number">0</span>..&lt;playlist.<span class="s-property">songs</span>.<span class="s-property">count</span>)
        <span class="s-call">playSong</span>(atIndex: index)
    }
    
    ...
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/splitting-up-swift-types</guid><title>Splitting up Swift types</title><description>This week, let‚Äôs take a look at a few tips and techniques that can help us make our types more well-defined, by splitting them up once their responsibilities have started to grow beyond the ideal scope of a single type.</description><link>https://www.swiftbysundell.com/articles/splitting-up-swift-types</link><pubDate>Sun, 1 Mar 2020 20:10:00 +0100</pubDate><content:encoded><![CDATA[<p>The idea that an app‚Äôs various features and systems should ideally be kept clearly separated in terms of their responsibilities and concerns is something that‚Äôs quite widely accepted across the entire software industry. So many architectural patterns, techniques and principles have been invented over the years in attempts to guide us into writing more clearly decoupled code ‚Äî both in Swift and in many other languages as well.</p><p>However, regardless of which kind of architecture that we‚Äôve chosen to adopt within any given project, making sure that each of our types has a narrow and clearly defined set of responsibilities can at times be quite challenging ‚Äî especially as a code base keeps evolving with new features, and in response to platform changes.</p><p>This week, let‚Äôs take a look at a few tips and techniques that can help us do just that, by splitting our types up once their responsibilities have started to grow beyond the ideal scope of a single type.</p><h2>States and scopes</h2><p>One really common source of code complexity is when a single type needs to handle multiple scopes and separate states. For example, let‚Äôs say that we‚Äôre working on the networking layer of an app, and that we‚Äôve currently implemented that entire layer within a single class called <code>NetworkController</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> NetworkController {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">NetworkError</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">var</span> accessToken: <span class="s-type">AccessToken</span>?
    
    ...

    <span class="s-keyword">func</span> request(<span class="s-keyword">_</span> endpoint: <span class="s-type">Endpoint</span>,
                 then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">var</span> request = <span class="s-type">URLRequest</span>(url: endpoint.<span class="s-property">url</span>)

        <span class="s-keyword">if let</span> token = accessToken {
            request.<span class="s-call">addValue</span>(<span class="s-string">"Bearer</span> \(token)<span class="s-string">"</span>,
                forHTTPHeaderField: <span class="s-string">"Authorization"</span>
            )
        }

        <span class="s-comment">// Perform the request</span>
        ...
    }
}</code></pre><p class="info">Above we‚Äôre using an <code>Endpoint</code> type to define the various server endpoints that our app is communicating with. Check out <a href="https://www.swiftbysundell.com/articles/constructing-urls-in-swift">‚ÄúConstructing URLs in Swift‚Äù</a> for more information on that approach.</p><p>While implementing an entire feature or system within a single class is not necessarily a bad thing, in this case, doing so has left us with a quite major source of ambiguity. Since we‚Äôre using the same API to request both public endpoints, as well as those that require authentication, each of the developers on our team needs to always remember which endpoint that belongs to which group ‚Äî or else we‚Äôll end up with runtime errors when a protected endpoint was accidentally requested without a logged in user.</p><p>It would arguably be a lot better if we could utilize Swift‚Äôs type system to prevent any endpoint that requires authentication from being called without a valid access token. That way we would both be able to validate our networking code much more thoroughly at compile time, and also make that system easier to use ‚Äî as it‚Äôd be crystal clear which endpoint that may be requested within any given scope.</p><p>To make that happen, let‚Äôs start by moving all of the code that deals with authentication and access tokens out from <code>NetworkController</code> and into a new <em>variant</em> of that class, which we‚Äôll name <code>AuthenticatedNetworkController</code>. Just like its predecessor, our new controller will enable us to perform endpoint-based network calls ‚Äî only this time we‚Äôll both initialize it with its required tokens, and we‚Äôll also ensure that those tokens are kept up to date before we perform each request, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> AuthenticatedNetworkController {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">NetworkError</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">private var</span> tokens: <span class="s-type">NetworkTokens</span>
    ...

    <span class="s-keyword">init</span>(tokens: <span class="s-type">NetworkTokens</span>, ...) {
        <span class="s-keyword">self</span>.<span class="s-property">tokens</span> = tokens
        ...
    }

    <span class="s-keyword">func</span> request(<span class="s-keyword">_</span> endpoint: <span class="s-type">AuthenticatedEndpoint</span>,
                 then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-call">refreshTokensIfNeeded</span> { tokens <span class="s-keyword">in
            var</span> request = <span class="s-type">URLRequest</span>(url: endpoint.<span class="s-property">url</span>)

            request.<span class="s-call">addValue</span>(<span class="s-string">"Bearer</span> \(tokens.<span class="s-property">access</span>)<span class="s-string">"</span>,
                forHTTPHeaderField: <span class="s-string">"Authorization"</span>
            )
            
            <span class="s-comment">// Perform the request</span>
            ...
        }
    }
}</code></pre><p>Worth noting is that we‚Äôve also given our new network controller its own, dedicated endpoint type ‚Äî <code>AuthenticatedEndpoint</code>. That‚Äôs to also clearly separate our endpoint definitions, so that an endpoint which requires authentication won‚Äôt accidentally be passed to our previous <code>NetworkController</code>.</p><p>Since that type no longer has to deal with any authenticated requests, we can heavily simplify it, and rename it (and its endpoint type) to something that better describes its new role within our networking layer:</p><pre class="splash"><code><span class="s-keyword">class</span> NonAuthenticatedNetworkController {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">NetworkError</span>&gt;) -&gt; <span class="s-type">Void</span>
    
    ...

    <span class="s-keyword">func</span> request(<span class="s-keyword">_</span> endpoint: <span class="s-type">NonAuthenticatedEndpoint</span>,
                 then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">var</span> request = <span class="s-type">URLRequest</span>(url: endpoint.<span class="s-property">url</span>)
        ...
    }
}</code></pre><p>However, while the above kind of separation of concerns can give us a huge boost in terms of architecture and API clarity, it can also require a fair amount of code duplication. In this case, both of our network controllers need to create <code>URLRequest</code> instances and perform them, as well as handling tasks like caching and other networking-related operations ‚Äî so they could still share most of their underlying implementations, even though we wish to keep their APIs separate.</p><p>For starters, rather than having each of our networking-related types declare their own completion handler closure types, let‚Äôs define a generic one that they can easily share:</p><pre class="splash"><code><span class="s-keyword">typealias</span> NetworkResultHandler&lt;T&gt; = (<span class="s-type">Result</span>&lt;<span class="s-type">T</span>, <span class="s-type">NetworkError</span>&gt;) -&gt; <span class="s-type">Void</span></code></pre><p>We can then start moving parts of our underlying networking implementations out from the controllers themselves, and into smaller, dedicated types ‚Äî which should be able to remain fairly stateless. For example, here‚Äôs how we could create a private <code>NetworkRequestPerformer</code> type that both of our two controllers can use to actually perform their requests ‚Äî while still keeping our top-level APIs completely separate and type-safe:</p><pre class="splash"><code><span class="s-keyword">private struct</span> NetworkRequestPerformer {
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> accessToken: <span class="s-type">AccessToken</span>?
    <span class="s-keyword">var</span> cache: <span class="s-type">Cache</span>&lt;<span class="s-type">URL</span>, <span class="s-type">Data</span>&gt;

    <span class="s-keyword">func</span> perform(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">Data</span>&gt;) {
        <span class="s-keyword">if let</span> data = cache.<span class="s-call">data</span>(forKey: url) {
            <span class="s-keyword">return</span> <span class="s-call">handler</span>(.<span class="s-call">success</span>(data))
        }
                        
        <span class="s-keyword">var</span> request = <span class="s-type">URLRequest</span>(url: url)

        <span class="s-comment">// This if-statement is no longer a problem, since it's now
        // hidden behind a type-safe abstraction that prevents
        // accidential misuse.</span>
        <span class="s-keyword">if let</span> token = accessToken {
            request.<span class="s-call">addValue</span>(<span class="s-string">"Bearer</span> \(token)<span class="s-string">"</span>,
                forHTTPHeaderField: <span class="s-string">"Authorization"</span>
            )
        }
        
        ...
    }
}</code></pre><p>With the above in place, we can now let both of our network controllers focus solely on providing a type-safe API for performing requests ‚Äî while their underlying implementations are being kept in sync through privately shared utility types:</p><pre class="splash"><code><span class="s-keyword">class</span> AuthenticatedNetworkController {
    ...

    <span class="s-keyword">func</span> request(
        <span class="s-keyword">_</span> endpoint: <span class="s-type">AuthenticatedEndpoint</span>,
        then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">Data</span>&gt;
    ) {
        <span class="s-call">refreshTokensIfNeeded</span> { [cache] tokens <span class="s-keyword">in
            let</span> performer = <span class="s-type">NetworkRequestPerformer</span>(
                url: endpoint.<span class="s-property">url</span>,
                accessToken: tokens.<span class="s-property">access</span>,
                cache: cache
            )

            performer.<span class="s-call">perform</span>(then: handler)
        }
    }
}</code></pre><p>What we‚Äôve essentially done above is to utilize the power of <em>composition</em>, in that we‚Äôve shared various implementations by combining smaller types into the ones that define our public API. However, before we were able to <em>compose</em> our functionality, we first had to <em>decompose</em> the single type that we started out with. Doing that kind of decomposition on an ongoing basis is often key in order to keep a code base in tip-top shape, as our types tend to naturally grow as we add new features and functionality to our code base.</p><h2>Loading versus managing objects</h2><p>Next, let‚Äôs take a look at another type of situation which can make certain parts of a code base more complex than they need to be ‚Äî when the same type is responsible for both <em>loading</em> and <em>managing</em> a given object. A very common example of that is when everything related to user sessions has been implemented within a single type ‚Äî such as a <code>UserManager</code>.</p><p>For example, here such a type is responsible for both logging users in and out of our app, as well as keeping the currently logged in <code>User</code> instance in sync with our server:</p><pre class="splash"><code><span class="s-keyword">class</span> UserManager {
    <span class="s-keyword">private(set) var</span> user: <span class="s-type">User</span>?
    
    ...

    <span class="s-keyword">func</span> logIn(
        with credentials: <span class="s-type">LoginCredentials</span>,
        then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">User</span>&gt;
    ) {
        ...
    }

    <span class="s-keyword">func</span> sync(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">User</span>&gt;) {
        ...
    }

    <span class="s-keyword">func</span> logOut(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">Void</span>&gt;) {
        ...
    }
}</code></pre><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/managing-objects-using-locks-and-keys-in-swift">‚ÄúManaging objects using Locks and Keys in Swift‚Äù</a></em>, the main problem with the above sort of approach is that it forces us to implement our <code>User</code> property as an optional ‚Äî which in turn requires us to unwrap that optional within <em>all features</em> that somehow deals with the currently logged in user ‚Äî most of which likely <em>rely</em> on that value in order to actually perform their work.</p><p>To quote the article about <em>Locks and Keys</em> that‚Äôs linked above:</p><blockquote><p>What we're essentially dealing with here is a <em><a href="https://www.swiftbysundell.com/articles/handling-non-optional-optionals-in-swift">non-optional optional</a></em> ‚Äî a value that's technically optional, but is actually required by our program logic ‚Äî meaning that we risk ending up in an undefined state if it's missing, and the compiler has no way of helping us avoid that.</p></blockquote><p>So, without having to fully adopt a Locks and Keys-based architecture within our app ‚Äî how could we use <em>some</em> of the principles from that design pattern in order to split our <code>UserManager</code> up into smaller, more focused types?</p><p>The first thing we‚Äôll do is to extract all of the code related to loading <code>User</code> instances out from <code>UserManager</code> and into a new, separate type. We‚Äôll call it <code>UserLoader</code>, and it‚Äôll use our <code>AuthenticatedNetworkController</code> from before in order to request our server‚Äôs <code>user</code> endpoint, which requires authentication:</p><pre class="splash"><code><span class="s-keyword">struct</span> UserLoader {
    <span class="s-keyword">var</span> networkController: <span class="s-type">AuthenticatedNetworkController</span>

    <span class="s-keyword">func</span> loadUser(
        withID id: <span class="s-type">User</span>.<span class="s-type">ID</span>,
        then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">User</span>&gt;
    ) {
        networkController.<span class="s-call">request</span>(.<span class="s-call">user</span>(withID: id)) { result <span class="s-keyword">in</span>
            <span class="s-comment">// Decode the network result into a User instance,
            // then call the passed handler with the end result.</span>
            ...
        }
    }
}</code></pre><p>By decomposing our <code>UserManager</code> into smaller building blocks, like we did above, we can enable much of our functionality to be implemented as stateless structs ‚Äî since those types will simply perform tasks on behalf of other objects (just like our <code>NetworkRequestPerformer</code> from before).</p><p>We can keep doing the same thing with our login and logout code as well, for example by creating a <code>LoginPerformer</code> that uses our non-authenticated network controller to send a set of credentials to the server endpoint used to log a user into our app:</p><pre class="splash"><code><span class="s-keyword">struct</span> LoginPerformer {
    <span class="s-keyword">var</span> networking: <span class="s-type">NonAuthenticatedNetworkController</span>

    <span class="s-keyword">func</span> login(
        using credentials: <span class="s-type">LoginCredentials</span>,
        then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">NetworkTokens</span>&gt;
    ) {
        <span class="s-comment">// Send the passed credentials to our server's login
        // endpoint, and then call the passed completion handler
        // with the tokens that were returned.</span>
        ...
    }
}</code></pre><p>The beauty of the above approach is that we can now use either of our new types whenever we need to perform that type‚Äôs specific task, rather than always having to use the same <code>UserManager</code> type regardless of whether we‚Äôre logging in, out, or simply updating the current user.</p><p>For example, within our login code, we can now use <code>LoginPerformer</code> directly ‚Äî and we can then use <code>UserLoader</code> to load our newly logged in <code>User</code> before injecting both of those instances into our <code>UserManager</code> ‚Äî which now only has a single responsibility, to <em>manage</em> our current <code>User</code> instance:</p><pre class="splash"><code><span class="s-keyword">class</span> UserManager {
    <span class="s-keyword">private(set) var</span> user: <span class="s-type">User</span>
    <span class="s-keyword">private let</span> loader: <span class="s-type">UserLoader</span>

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, loader: <span class="s-type">UserLoader</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">user</span> = user
        <span class="s-keyword">self</span>.<span class="s-property">loader</span> = loader
    }

    <span class="s-keyword">func</span> sync(then handler: <span class="s-keyword">@escaping</span> <span class="s-type">NetworkResultHandler</span>&lt;<span class="s-type">User</span>&gt;) {
        loader.<span class="s-call">loadUser</span>(withID: user.<span class="s-property">id</span>) { [<span class="s-keyword">weak self</span>] result <span class="s-keyword">in
            if let</span> user = <span class="s-keyword">try</span>? result.<span class="s-call">get</span>() {
                <span class="s-keyword">self</span>?.<span class="s-property">user</span> = user
            }

            <span class="s-call">handler</span>(result)
        }
    }
}</code></pre><p class="info">We could even go ahead and rename the above type to <code>UserModelController</code>, since it‚Äôs now essentially a <a href="https://www.swiftbysundell.com/articles/model-controllers-in-swift">controller for our user model</a>.</p><p>Not only did the above refactor let us get rid of an unnecessary optional ‚Äî which in turn should let us remove a whole lot of awkward <code>if</code> and <code>guard</code> statements from any code that relies on a user being logged in ‚Äî it‚Äôll also give us a greater degree of flexibility, since we‚Äôre now able to pick which level of <code>User</code>-related abstraction that we‚Äôd like to work with within each new feature that we‚Äôll build.</p><h2>Conclusion</h2><p>Composition is an incredibly powerful concept, but before we can utilize it within our apps, we first need to <em>decompose</em> some of our larger types into smaller building blocks ‚Äî which can then be assembled into many different combinations and configurations.</p><p>Of course, we always have to try to strike a balance between splitting things up and still keeping our code base consistent and easy to navigate ‚Äî so the goal is definitely not to split things up as much as possible, but rather to create types that have a narrow set of responsibilities, which can then be combined into higher-level abstractions.</p><p>What do you think? When do you typically decide to split a type up into multiple smaller ones? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/what-makes-code-swifty</guid><title>What makes code ‚ÄúSwifty‚Äù?</title><description>The phrase ‚ÄúSwifty code‚Äù is often used to describe code that follows the conventions that are currently the most popular within the Swift community. But what exactly does that entail? Let‚Äôs take a look.</description><link>https://www.swiftbysundell.com/articles/what-makes-code-swifty</link><pubDate>Sun, 23 Feb 2020 20:35:00 +0100</pubDate><content:encoded><![CDATA[<p>Although programming languages are formally defined by their syntax, the ways in which they get used in practice are arguably just as much determined by their <em>current conventions</em>. After all, syntax-wise, most <em>‚ÄúC-influenced‚Äù</em> languages look incredibly similar ‚Äî to the point where you could write Swift in ways that almost makes it look like JavaScript, or C#, or C itself.</p><p>Within the Swift community, the phrase <em>‚ÄúSwifty code‚Äù</em> is often used to describe code that follows the conventions that are currently the most popular. However, while Swift‚Äôs core syntax hasn‚Äôt changed <em>that</em> much since its original introduction, its conventions have dramatically shifted over time.</p><p>For example, many Swift developers remember the transition from Swift 2 to Swift 3 as a big change in terms of syntax, but the majority of those changes weren‚Äôt really <em>syntax changes</em> ‚Äî they were changes to the standard library‚Äôs API based on a new set of naming conventions. Add Swift 4‚Äôs introduction of <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a> and <a href="https://www.swiftbysundell.com/basics/codable"><code>Codable</code></a>, Swift 5.1‚Äôs <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/">function builders, property wrappers and opaque return types</a>, and many more APIs and features that have been introduced over the years ‚Äî and it‚Äôs starting to become quite clear that what makes code <em>‚ÄúSwifty‚Äù</em> is somewhat of a <em>moving target</em>.</p><p>This week, let‚Äôs take a closer look at Swift‚Äôs core set of conventions, to try to come up with an answer to the question of <em>what really does make code ‚ÄúSwifty‚Äù</em>?</p><h2>Aligned goals</h2><p>In a way, a simple answer to the above question could be <em>‚Äúcode that‚Äôs well-aligned with Swift‚Äôs core set of goals‚Äù</em>. After all, while Swift‚Äôs various APIs, conventions and language features tend to change over time, its fundamental goals mostly remain the same ‚Äî so if we can write our own code in ways that matches those goals, then we‚Äôll have a much better chance of making our code feel natural and clear within any given Swift context.</p><p>So, what exactly are those goals? The <a href="https://swift.org/about">about page on Swift‚Äôs official website</a> lists three keywords: <strong>Safe</strong> in terms of minimizing developer mistakes, <strong>Fast</strong> when it comes to speed of execution, and <strong>Expressive</strong>, in that Swift aims to be as clear and as easy to understand as possible.</p><p>Let‚Äôs take a look at a few different things that can be good to keep in mind in order to make our own code follow those principles.</p><h2>Clarity through strong type safety</h2><p>Let‚Äôs start with the first keyword ‚Äî <em>safety</em>. The fact that Swift puts a very strong emphasis on type safety is hard to miss ‚Äî with its static type checks, a powerful generics system, and the need to do things like <a href="https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift">type erasure</a> in order for the compiler to be able to verify our code‚Äôs structure as it‚Äôs being compiled.</p><p>However, it‚Äôs quite common to encounter situations in which it‚Äôs less obvious that our code‚Äôs type safety could be improved ‚Äî which could also make it feel more <em>‚ÄúSwifty‚Äù</em>, and in turn, become easier to work with. For example, here we‚Äôre storing a collection of notes based on the name of the group that they belong to:</p><pre class="splash"><code><span class="s-keyword">struct</span> NoteCollection {
    <span class="s-keyword">var</span> notesByGroup: [<span class="s-type">String</span> : [<span class="s-type">Note</span>]]
    ...
}</code></pre><p>At first glance, the above code may seem perfectly fine. However, one detail that‚Äôs not at all obvious when looking at the declaration above is how we‚Äôre dealing with ungrouped values, as well as with a special group containing all of the user‚Äôs recently opened notes ‚Äî which is currently done by either passing an empty string, or <code>"recent"</code>, when subscripting our dictionary:</p><pre class="splash"><code><span class="s-keyword">let</span> groupedNotes = collection.<span class="s-property">notesByGroup</span>[<span class="s-string">"MyGroup"</span>]
<span class="s-keyword">let</span> ungroupedNotes = collection.<span class="s-property">notesByGroup</span>[<span class="s-string">""</span>]
<span class="s-keyword">let</span> recentNotes = collection.<span class="s-property">notesByGroup</span>[<span class="s-string">"recent"</span>]</code></pre><p>While the above design may have a perfectly valid justification (for example, the structure we‚Äôve used might be how our notes are organized when loading them over the network), it does lead to some of our call sites becoming quite cryptic ‚Äî which in turn increases the chances of developer mistakes. It‚Äôs easy to forget that an empty string means that all ungrouped notes should be retrieved, and what happens if the user names one of their custom groups <em>‚Äúrecent‚Äù</em>?</p><p>Let‚Äôs see if we can make the above code more type safe, and in doing that, make it feel more <em>‚ÄúSwifty‚Äù</em> as well. Since we have three distinct use cases for our <code>notesByGroup</code> dictionary, let‚Äôs replace its <code>String</code>-based keys with a custom enum that models those three variants as distinct cases, like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> Group: <span class="s-type">Hashable</span> {
    <span class="s-keyword">case</span> none
    <span class="s-keyword">case</span> recent
    <span class="s-keyword">case</span> named(<span class="s-type">String</span>)
}

<span class="s-keyword">struct</span> NoteCollection {
    <span class="s-keyword">var</span> notesByGroup: [<span class="s-type">Group</span> : [<span class="s-type">Note</span>]]
    ...
}</code></pre><p>The above may seem like a subtle change, but it makes our call sites a lot more clear, since we‚Äôre now leveraging the type system to distinguish between our three separate types of groups ‚Äî all without making our API any more complex:</p><pre class="splash"><code><span class="s-keyword">let</span> groupedNotes = collection.<span class="s-property">notesByGroup</span>[.<span class="s-call">named</span>(<span class="s-string">"MyGroup"</span>)]
<span class="s-keyword">let</span> ungroupedNotes = collection.<span class="s-property">notesByGroup</span>[.<span class="s-dotAccess">none</span>]
<span class="s-keyword">let</span> recentNotes = collection.<span class="s-property">notesByGroup</span>[.<span class="s-dotAccess">recent</span>]</code></pre><p>That‚Äôs perhaps the essence of what makes code <em>‚ÄúSwifty‚Äù</em> in terms of type safety. While there are many ways to make an API really complicated in order to make it more type-safe, the trick is to use Swift‚Äôs language features to find a way to add that type safety without making our code harder to understand or use.</p><p>While type safety is commonly used to prevent a value of type <code>B</code> from incorrectly being passed to an API that accepts <code>A</code>, strong typing also often provides a way to improve the semantics and logic of our code as well. In the following example, our code is <em>technically</em> type-safe ‚Äî as we are using Swift‚Äôs <a href="https://www.swiftbysundell.com/basics/generics">generics feature</a> to implement a <code>LoadingOperation</code> that can load any <code>Resource</code> that conforms to a <code>Loadable</code> protocol:</p><pre class="splash"><code><span class="s-keyword">class</span> LoadingOperation&lt;Resource: <span class="s-type">Loadable</span>&gt; {
    <span class="s-keyword">private let</span> resource: <span class="s-type">Resource</span>

    <span class="s-keyword">init</span>(resource: <span class="s-type">Resource</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">resource</span> = resource

        <span class="s-keyword">if let</span> preloadable = resource <span class="s-keyword">as</span>? <span class="s-type">Preloadable</span> {
            preloadable.<span class="s-call">preload</span>()
        }
    }
    
    ...
}</code></pre><p>However, the fact that we‚Äôre conditionally casting our <code>resource</code> to see if it also conforms to <code>Preloadable</code> (and if so, we preload that resource) is arguably a bit strange. Not only does the above implementation make it hard to understand how to make a resource preload (as the type system doesn‚Äôt give us any hints that we‚Äôre supposed to conform to <code>Preloadable</code> to make that happen), it‚Äôs also quite unintuitive to have preloading be a <a href="https://www.swiftbysundell.com/articles/initializers-in-swift/%23avoiding-complexity-and-side-effects">side-effect of initializing</a> an operation.</p><p>Instead, let‚Äôs make preloading an explicit API that‚Äôs only available when an operation‚Äôs <code>Resource</code> conforms to <code>Preloadable</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">LoadingOperation</span> <span class="s-keyword">where</span> <span class="s-type">Resource</span>: <span class="s-type">Preloadable</span> {
    <span class="s-keyword">func</span> preload() {
        resource.<span class="s-call">preload</span>()
    }
}</code></pre><p>The above change both makes it a lot more clear what the conditions are for a resource to be preloaded, and we can now remove our type casting side-effect from our initializer ‚Äî big win!</p><p>What‚Äôs important to note is that writing <em>‚ÄúSwifty‚Äù</em> code from a safety perspective is definitely <strong>not</strong> about using generics as much as possible. Rather, it‚Äôs about using the type system‚Äôs various aspects and features <em>selectively</em> to make our code easier to understand and use (and harder to misuse).</p><h2>The path to performance</h2><p>The second of Swift‚Äôs core goals, to be <em>fast</em>, is something that‚Äôs a bit trickier to reason about in general terms. After all, a major part of writing high-performance code comes down to measuring, fine-tuning, and measuring again. However, one way to make our code more aligned with Swift itself in terms of performance is to make full use of what the standard library has to offer ‚Äî particularly when working with collections, such as strings.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/string-parsing-in-swift">‚ÄúString parsing in Swift‚Äù</a></em> and <em><a href="https://www.swiftbysundell.com/articles/slicing-swift-collections">‚ÄúSlicing Swift collections‚Äù</a></em>, the Swift standard library is highly optimized for performance, and enables us to perform many common collection operations in a highly efficient manner ‚Äî given that we use the right APIs, that is.</p><p>For example, one common way to remove a certain set of characters from a string is to use the old <code>replacingOccurences(of:with:)</code> API that Swift‚Äôs <code>String</code> type inherited from its Objective-C cousin, <code>NSString</code>. Here we‚Äôre using a series of calls to that API to sanitize a string by removing a set of special characters:</p><pre class="splash"><code><span class="s-keyword">let</span> sanitizedString = string
    .<span class="s-call">replacingOccurrences</span>(of: <span class="s-string">"@"</span>, with: <span class="s-string">""</span>)
    .<span class="s-call">replacingOccurrences</span>(of: <span class="s-string">"#"</span>, with: <span class="s-string">""</span>)
    .<span class="s-call">replacingOccurrences</span>(of: <span class="s-string">"&lt;"</span>, with: <span class="s-string">""</span>)
    .<span class="s-call">replacingOccurrences</span>(of: <span class="s-string">"&gt;"</span>, with: <span class="s-string">""</span>)</code></pre><p>The problem with the above implementation is that it‚Äôll cause 4 separate iterations through our string ‚Äî which might not be a problem when working with shorter strings, or when doing the above within a code path that‚Äôs not hit very often, but it could become a bottleneck in situations when we need maximum performance.</p><p>Thankfully, Swift often doesn‚Äôt require us to pick between performant code and elegant code ‚Äî all we have to do is to switch to a more appropriate API, one that just makes one pass through our string in order to remove each character that‚Äôs contained within a <code>Set</code>, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> charactersToRemove: <span class="s-type">Set</span>&lt;<span class="s-type">Character</span>&gt; = [<span class="s-string">"@"</span>, <span class="s-string">"#"</span>, <span class="s-string">"&lt;"</span>, <span class="s-string">"&gt;"</span>]
string.<span class="s-call">removeAll</span>(where: charactersToRemove.<span class="s-property">contains</span>)</code></pre><p>So, to make our code more <em>‚ÄúSwifty‚Äù</em> from a performance point of view, sometimes all that we have to do is to explore what the standard library has to offer when faced with a given task ‚Äî and especially when it comes to collections, chances are quite high that there‚Äôs an elegant, simple API that also gives us great performance characteristics available.</p><h2>Clear, expressive naming</h2><p>Finally, let‚Äôs take a look at the third and last keyword ‚Äî <em>expressive</em>. While it‚Äôs easy to think of expressiveness as something that‚Äôs purely cosmetic, and that involves nitpicking method names until they all read as grammatically perfect English sentences, it‚Äôs ultimately all about making our code clearly convey its <em>meaning</em>.</p><p>Let‚Äôs say that we‚Äôve written a function that‚Äôs currently called <code>getContent</code>, which loads the data for a bundled <code>Content</code> model, and then decodes it:</p><pre class="splash"><code><span class="s-keyword">func</span> getContent(name: <span class="s-type">String</span>) -&gt; <span class="s-type">Content</span>? {
    <span class="s-keyword">guard let</span> url = <span class="s-type">Bundle</span>.<span class="s-property">main</span>.<span class="s-call">url</span>(
        forResource: name,
        withExtension: <span class="s-string">"json"</span>
    ) <span class="s-keyword">else</span> {
        <span class="s-keyword">return nil</span>
    }

    <span class="s-keyword">guard let</span> data = <span class="s-keyword">try</span>? <span class="s-type">Data</span>(contentsOf: url) <span class="s-keyword">else</span> {
        <span class="s-keyword">return nil</span>
    }

    <span class="s-keyword">return try</span>? <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">Content</span>.<span class="s-keyword">self</span>, from: data)
}</code></pre><p>Again, at first glance the above function may seem perfectly fine. There are no obvious bugs, and it gets the job done. However, in terms of being <em>expressive</em>, it could definitely be improved.</p><p>First of all, its current name ‚Äî <em>‚Äùget content‚Äù</em> ‚Äî doesn‚Äôt really tell us <em>how</em> the content will be retrieved. Will it simply be created as a new instance, will it be loaded over the network, or something else? Also, the fact that it simply returns <code>nil</code> in case an error occurred could make it harder to debug in case something ever starts to fail ‚Äî since we won‚Äôt get any indication as to what <em>actually</em> went wrong.</p><p>So let‚Äôs see if we can improve things, by first renaming our function to <code>loadBundledContent</code> (to make it clear that we‚Äôre loading the content from our app bundle). We‚Äôll also give it an external parameter label to make it read a bit nicer, and finally, we‚Äôll make it report any error that it encountered by throwing it ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">func</span> loadBundledContent(named name: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Content</span> {
    <span class="s-keyword">guard let</span> url = <span class="s-type">Bundle</span>.<span class="s-property">main</span>.<span class="s-call">url</span>(
        forResource: name,
        withExtension: <span class="s-string">"json"</span>
    ) <span class="s-keyword">else</span> {
        <span class="s-keyword">throw</span> <span class="s-type">Content</span>.<span class="s-type">Error</span>.<span class="s-property">missing</span>
    }

    <span class="s-keyword">guard let</span> data = <span class="s-keyword">try</span>? <span class="s-type">Data</span>(contentsOf: url) <span class="s-keyword">else</span> {
        <span class="s-keyword">throw</span> <span class="s-type">Content</span>.<span class="s-type">Error</span>.<span class="s-property">missing</span>
    }

    <span class="s-keyword">do</span> {
        <span class="s-keyword">return try</span> <span class="s-type">JSONDecoder</span>().<span class="s-call">decode</span>(<span class="s-type">Content</span>.<span class="s-keyword">self</span>, from: data)
    } <span class="s-keyword">catch</span> {
        <span class="s-keyword">throw</span> <span class="s-type">Content</span>.<span class="s-type">Error</span>.<span class="s-call">decodingFailed</span>(error)
    }
}</code></pre><p class="info">For more on the above way of designing throwing APIs, check out the very first article on this site ‚Äî <a href="https://www.swiftbysundell.com/articles/providing-a-unified-swift-error-api">‚ÄúProviding a unified Swift error API‚Äù</a>.</p><p>Here‚Äôs what the call site looks like before and after our change:</p><pre class="splash"><code><span class="s-comment">// Before</span>
<span class="s-keyword">let</span> content = <span class="s-call">getContent</span>(name: <span class="s-string">"Onboarding"</span>)

<span class="s-comment">// After</span>
<span class="s-keyword">let</span> content = <span class="s-keyword">try</span> <span class="s-call">loadBundledContent</span>(named: <span class="s-string">"Onboarding"</span>)</code></pre><p>While it‚Äôs important not to get <em>too</em> hung up on what we name our functions and types (it‚Äôs often a matter of taste and preference, after all), if we can find ways to more clearly convey what each of our APIs do, then that‚Äôs a big win ‚Äî as it not only makes it easier for new developers to familiarize themselves with our code base, it can also often make our code more pleasant to work with long-term.</p><h2>Conclusion</h2><p>In my opinion, writing <em>‚ÄúSwifty‚Äù</em> code is not about using as many language features as possible, or about making our code needlessly complex by deploying Swift‚Äôs most advanced features to solve simple problems ‚Äî it‚Äôs about aligning the way we design and express our code and its various APIs with Swift‚Äôs core set of principles.</p><p>By making our code use Swift‚Äôs type system both to ensure correctness and to make its functionality more clear, by fully utilizing the standard library, and by conveying the intent of our code through expressive naming and <a href="https://www.swiftbysundell.com/tags/api-design">API design</a> ‚Äî we often end up with code that better matches Swift itself, and isn‚Äôt that what writing <em>‚ÄúSwifty‚Äù</em> code is all about?</p><p>Got questions, comments or feedback? I‚Äôd love to hear from you! Either find me <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">send me an email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-swiftui-foreach-with-raw-values</guid><title>Tip: Using SwiftUI‚Äôs ForEach with raw values</title><description></description><link>https://www.swiftbysundell.com/tips/using-swiftui-foreach-with-raw-values</link><pubDate>Fri, 21 Feb 2020 19:00:00 +0100</pubDate><content:encoded><![CDATA[<p>SwiftUI‚Äôs <code>ForEach</code> type enables us to create a series of views by transforming each element within a collection. However, since <code>ForEach</code> reuses the views that it creates in order to optimize performance (just like other list-based views, like <code>UITableView</code> and <code>UICollectionView</code>, do), it requires us to provide a way to identify each of the elements that we‚Äôre basing its views on.</p><p>When the elements that we‚Äôre transforming conform to the <code>Identifiable</code> protocol, that kind of identification is taken care of automatically, and we can simply pass our collection of values directly to <code>ForEach</code>. For example, here we‚Äôre transforming an array of <code>User</code> values into a list of vertically arranged <code>UserView</code> instances:</p><pre class="splash"><code><span class="s-keyword">struct</span> User: <span class="s-type">Identifiable</span> {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
}

<span class="s-keyword">struct</span> UserList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> users = [<span class="s-type">User</span>]()

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">ForEach</span>(users) { user <span class="s-keyword">in</span>
                <span class="s-type">UserView</span>(user: user)
            }
        }
    }
}</code></pre><p class="info">Note how we could‚Äôve written the above <code>ForEach</code> expression as <code>ForEach(users, content: UserView.init)</code>, since Swift supports <a href="https://www.swiftbysundell.com/clips/1">first class functions</a>.</p><p>However, sometimes we might want to base a <code>ForEach</code> on a collection of simpler, raw values ‚Äî such as strings. Doing that might initially seem difficult, since we wouldn‚Äôt want to make <code>String</code> unconditionally conform to <code>Identifiable</code>. Thankfully, there‚Äôs a way to make that happen, by using the <code>\.self</code> key path to compute each element‚Äôs identifier ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> TagList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>]

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-comment">// Using '\.self', we can refer to each element directly,
            // and use the element's own value as its identifier:</span>
            <span class="s-type">ForEach</span>(tags, id: \.<span class="s-keyword">self</span>) { tag <span class="s-keyword">in</span>
                <span class="s-type">Text</span>(tag)
                    .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                    .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
                    .<span class="s-call">cornerRadius</span>(<span class="s-number">5</span>)
            }
        }
    }
}</code></pre><p>Another option would of course be to wrap our raw values using an <code>Identifiable</code> type, for example like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Tag: <span class="s-type">Identifiable</span> {
    <span class="s-keyword">var</span> id: <span class="s-type">String</span> { name }
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
}

<span class="s-keyword">struct</span> TagList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">Tag</span>]

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">ForEach</span>(tags) { tag <span class="s-keyword">in</span>
                <span class="s-type">Text</span>(tag.<span class="s-property">name</span>)
                    .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                    .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
                    .<span class="s-call">cornerRadius</span>(<span class="s-number">5</span>)
            }
        }
    }
}</code></pre><p class="info">When using either of the above two techniques, it‚Äôs important to first make sure that the values that we‚Äôre dealing with are all unique (at least within that collection), since otherwise <code>ForEach</code> might incorrectly reuse the resulting views.</p><p>Finally, if we plan to use <code>ForEach</code> with raw values in several places throughout our code base, we might want to create a simple convenience API for doing that, to avoid having to repeat that <code>\.self</code> key path argument within all those places:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ForEach</span> <span class="s-keyword">where</span> <span class="s-type">Data</span>.<span class="s-type">Element</span>: <span class="s-type">Hashable</span>, <span class="s-type">ID</span> == <span class="s-type">Data</span>.<span class="s-type">Element</span>, <span class="s-type">Content</span>: <span class="s-type">View</span> {
    <span class="s-keyword">init</span>(values: <span class="s-type">Data</span>, content: <span class="s-keyword">@escaping</span> (<span class="s-type">Data</span>.<span class="s-type">Element</span>) -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-keyword">init</span>(values, id: \.<span class="s-keyword">self</span>, content: content)
    }
}</code></pre><p class="info">Note how we use an external parameter label above, which the built-in <code>ForEach</code> APIs don‚Äôt. That‚Äôs very much by design, to avoid collisions, for example when using <code>Range&lt;Int&gt;</code>, which <code>ForEach</code> natively supports.</p><p>With the above extension in place we can now easily pass any collection of raw values, such as strings and integers, to <code>ForEach</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> TagList: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> tags: [<span class="s-type">String</span>]

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">ForEach</span>(values: tags) { tag <span class="s-keyword">in</span>
                <span class="s-type">Text</span>(tag)
                    .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                    .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
                    .<span class="s-call">cornerRadius</span>(<span class="s-number">5</span>)
            }
        }
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/optional-swiftui-views</guid><title>Tip: Optional SwiftUI views</title><description></description><link>https://www.swiftbysundell.com/tips/optional-swiftui-views</link><pubDate>Tue, 18 Feb 2020 17:45:00 +0100</pubDate><content:encoded><![CDATA[<p>Sometimes we might want one of our SwiftUI views to only be constructed and shown in case a certain optional value is available. For example, here we‚Äôre building a <code>HomeView</code> that should conditionally contain a <code>ProfileView</code> whenever a <code>LogInManager</code> contains a <code>loggedInUser</code> ‚Äî which we‚Äôve tried implementing using a standard <code>if let</code> statement:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> loginManager: <span class="s-type">LoginManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-keyword">if let</span> user = loginManager.<span class="s-property">loggedInUser</span> {
                <span class="s-type">ProfileView</span>(user: user)
            }

            ...
        }
    }
}</code></pre><p>Unfortunately, the above code will give us a compiler error:</p><p class="info">Closure containing control flow statement cannot be used with function builder <code>ViewBuilder</code>.</p><p>Since SwiftUI (for the most part) doesn‚Äôt use standard closures, but rather <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/%23function-builders">function builders</a>, we can‚Äôt put any arbitrary code within the closures used to configure views like <code>HStack</code> and <code>VStack</code>. So how can we handle optionals like the one above?</p><p>One way would be to push the responsibility of handling such optionals into the views that actually consume them. For example, here‚Äôs how we could make our <code>ProfileView</code> accept an optional <code>User</code>, rather than a concrete value:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProfileView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> user: <span class="s-type">User</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-keyword">guard let</span> user = user <span class="s-keyword">else</span> {
            <span class="s-comment">// We have to use 'AnyView' to perform type erasure here,
            // in order to give our 'body' a single return type:</span>
            <span class="s-keyword">return</span> <span class="s-type">AnyView</span>(<span class="s-type">EmptyView</span>())
        }

        <span class="s-keyword">return</span> <span class="s-type">AnyView</span>(<span class="s-type">VStack</span> {
            <span class="s-type">Text</span>(user.<span class="s-property">name</span>)
            ...
        })
    }
}</code></pre><p>The above works, but isn‚Äôt very elegant. After all, it doesn‚Äôt make much sense to create a <code>ProfileView</code> for a <code>nil</code> user. So let‚Äôs try another approach instead, for example by using <code>map</code> on our optional <code>User</code>, in order to conditionally convert it into a <code>ProfileView</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> loginManager: <span class="s-type">LoginManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            loginManager.<span class="s-property">loggedInUser</span>.<span class="s-call">map</span> { user <span class="s-keyword">in</span>
                <span class="s-type">ProfileView</span>(user: user)
            }
            ...
        }
    }
}</code></pre><p class="info">To learn more about the above way of mapping an optional value into a new type, check out the <a href="https://www.swiftbysundell.com/basics/optionals">Basics article about optionals</a>.</p><p>That‚Äôs much nicer, as we no longer have to manually construct an <code>EmptyView</code> in case our <code>User</code> value is missing ‚Äî and it also makes it possible for us to again have <code>ProfileView</code> accept a concrete <code>User</code>, rather than an optional. But perhaps we could take things even further?</p><p>The cool thing about SwiftUI‚Äôs <code>@ViewBuilder</code> function builder is that it isn‚Äôt a private implementation detail of SwiftUI itself, but rather a public attribute that we can annotate our own functions and closures with as well.</p><p>Using that attribute, we could construct an <code>Unwrap</code> view ‚Äî that‚Äôll accept an optional value, and a <code>@ViewBuilder</code> closure for transforming any non-<code>nil</code> value into a <code>View</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Unwrap&lt;Value, Content: <span class="s-type">View</span>&gt;: <span class="s-type">View</span> {
    <span class="s-keyword">private let</span> value: <span class="s-type">Value</span>?
    <span class="s-keyword">private let</span> contentProvider: (<span class="s-type">Value</span>) -&gt; <span class="s-type">Content</span>

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>?,
         <span class="s-keyword">@ViewBuilder</span> content: <span class="s-keyword">@escaping</span> (<span class="s-type">Value</span>) -&gt; <span class="s-type">Content</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
        <span class="s-keyword">self</span>.<span class="s-property">contentProvider</span> = content
    }

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        value.<span class="s-call">map</span>(contentProvider)
    }
}</code></pre><p>With the above in place, we can now not only make our optional-unwrapping UI code read nicer, but we can also make full use of SwiftUI‚Äôs DSL when constructing our optional views ‚Äî since we‚Äôre using the same <code>@ViewBuilder</code> functionality that SwiftUI itself uses. For example, we could now easily construct an entire optional view hierarchy like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> HomeView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> loginManager: <span class="s-type">LoginManager</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Unwrap</span>(loginManager.<span class="s-property">loggedInUser</span>) { user <span class="s-keyword">in</span>
                <span class="s-type">HStack</span> {
                    <span class="s-type">Text</span>(<span class="s-string">"Logged in as:"</span>)
                    <span class="s-type">ProfileView</span>(user: user)
                }
            }
            ...
        }
    }
}</code></pre><p>We could also do something similar for modifiers as well, but let‚Äôs save that for a future article, shall we? üòÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/configuring-swiftui-views</guid><title>Configuring SwiftUI views</title><description>This week, let‚Äôs take a look at a few different ways of configuring views when using SwiftUI, and the sort of pros and cons that each of those approaches gives us in terms of code structure and flexibility.</description><link>https://www.swiftbysundell.com/articles/configuring-swiftui-views</link><pubDate>Sun, 16 Feb 2020 21:35:00 +0100</pubDate><content:encoded><![CDATA[<p>One of the key ways that SwiftUI is different compared to Apple‚Äôs previous UI frameworks is how its views are created and configured. In fact, it could be argued that when using SwiftUI, we never actually <em>create</em> any views at all ‚Äî instead we simply <em>describe</em> what we want our UI to look like, and then the system takes care of the actual rendering.</p><p>This week, let‚Äôs take a look at a few different techniques for structuring those view descriptions, and the sort of pros and cons that each of those approaches gives us in terms of code structure and flexibility.</p><h2>Initializers, modifiers and inheritance</h2><p>Overall, there are three different ways to configure a SwiftUI view ‚Äî by passing arguments to its initializer, using modifiers, and through its surrounding environment. For example, here we‚Äôre configuring a <code>Text</code> view that acts as the <code>body</code> of a <code>TitleView</code> ‚Äî using both its initializer, and by applying <em>modifiers</em> to it in order to change its font and text color:</p><pre class="splash"><code><span class="s-keyword">struct</span> TitleView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Text</span>(title)
            .<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
            .<span class="s-call">italic</span>()
            .<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">blue</span>)
    }
}</code></pre><p class="info">The above way of chaining modifiers together, rather than mutating a single value, is a big part of what separates SwiftUI‚Äôs declarative programming style from how UIs are constructed when using imperative frameworks, such as UIKit or AppKit.</p><p>The above is an example of <em>direct configuration</em>, as we‚Äôre explicitly setting up and modifying our <code>Text</code> view by directly calling methods on it. However, SwiftUI also supports <em>indirect configuration</em>, as many different modifiers and properties are automatically propagated down through each given view hierarchy.</p><p>That sort of indirect, inherited configuration can be incredibly useful in situations when we want multiple sibling views to adopt the same sort of configuration or styling ‚Äî like in the following case, in which we configure both a <code>Text</code> and a <code>List</code> to display all of their text using a monospaced font, simply by assigning that font to their parent <code>VStack</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> ListView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> items: [<span class="s-type">Item</span>]
    <span class="s-keyword">@Binding var</span> selectedItem: <span class="s-type">Item</span>?

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Text</span>(title).<span class="s-call">bold</span>()
            <span class="s-type">List</span>(items, selection: $selectedItem) { item <span class="s-keyword">in</span>
                <span class="s-type">Text</span>(item.<span class="s-property">title</span>)
            }
        }.<span class="s-call">font</span>(.<span class="s-call">system</span>(.<span class="s-dotAccess">body</span>, design: .<span class="s-dotAccess">monospaced</span>))
    }
}</code></pre><p>The fact that entire SwiftUI view hierarchies can be configured through their parent is incredibly powerful, as it lets us apply shared styles and configurations without having to modify each view separately. Not only does that often lead to less code, but it also establishes a single source of truth for our shared configurations ‚Äî like fonts, colors, and so on ‚Äî without requiring us to introduce any sort of abstraction to make that happen.</p><p>Let‚Äôs take a look at another example, in which we change an entire navigation stack‚Äôs <code>accentColor</code> simply by assigning it to our root <code>NavigationView</code> ‚Äî which will cause that color to be applied to all child views, including those managed by the system, such as any navigation bar items that we‚Äôve defined:</p><pre class="splash"><code><span class="s-keyword">struct</span> ContactListView: <span class="s-type">View</span> {
    <span class="s-keyword">@ObservedObject var</span> contacts: <span class="s-type">ContactList</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">NavigationView</span> {
            <span class="s-type">List</span>(contacts) { contact <span class="s-keyword">in</span>
                ...
            }
            .<span class="s-call">navigationBarItems</span>(
                trailing: <span class="s-type">Button</span>(
                    action: { ... },
                    label: {
                        <span class="s-comment">// This image will be colored purple</span>
                        <span class="s-type">Image</span>(systemName: <span class="s-string">"person.badge.plus"</span>)
                    }
                )
            )
        }.<span class="s-call">accentColor</span>(.<span class="s-dotAccess">purple</span>)
    }
}</code></pre><p>However, sometimes we might want to apply a set of styles to a group of views without having to change their relationship to their parent view. For example, let‚Äôs say that we‚Äôre building a view for displaying an address within an app, which consists of a series of stacked <code>Text</code> views:</p><pre class="splash"><code><span class="s-keyword">struct</span> AddressView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> address: <span class="s-type">Address</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
            <span class="s-type">Text</span>(address.<span class="s-property">recipient</span>)
                .<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
            <span class="s-type">Text</span>(address.<span class="s-property">street</span>)
                .<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
                .<span class="s-call">padding</span>(<span class="s-number">3</span>)
                .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
            <span class="s-type">HStack</span> {
                <span class="s-type">Text</span>(address.<span class="s-property">postCode</span>)
                <span class="s-type">Text</span>(address.<span class="s-property">city</span>)
            }
            <span class="s-type">Text</span>(address.<span class="s-property">country</span>)
        }
    }
}</code></pre><p>Above we‚Äôre assigning the exact same styling to our first two labels, so let‚Äôs see if we can unify that code to avoid having to repeat it. In this case, we can‚Äôt apply our modifiers to our labels‚Äô parent view, since we only want to apply the given styles to a subset of its children.</p><p>Thankfully, SwiftUI also ships with a <code>Group</code> type, which lets us treat a set of views as a group ‚Äî without affecting their layout, drawing, or position within our overall view hierarchy. Using that type, we can group our two labels together, and then apply our set of modifiers to both of them at the same time:</p><pre class="splash"><code><span class="s-keyword">struct</span> AddressView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> address: <span class="s-type">Address</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span>(alignment: .<span class="s-dotAccess">leading</span>) {
            <span class="s-type">Group</span> {
                <span class="s-type">Text</span>(address.<span class="s-property">recipient</span>)
                <span class="s-type">Text</span>(address.<span class="s-property">street</span>)
            }
            .<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
            .<span class="s-call">padding</span>(<span class="s-number">3</span>)
            .<span class="s-call">background</span>(<span class="s-type">Color</span>.<span class="s-property">secondary</span>)
            ...
        }
    }
}</code></pre><p>The power of <code>Group</code> is that it applies its modifiers directly to its children, rather than to itself. Compare that to if we would‚Äôve grouped our labels using another <code>VStack</code> instead, which would‚Äôve caused the padding and background color to be applied to that stack, rather than to our labels individually.</p><h2>Views versus extensions</h2><p>As our SwiftUI-based views grow in complexity, we likely need to start using multiple ways of grouping and sharing our various configurations and styles, in order to keep our code easy to work with. So far, we‚Äôve mostly been dealing with styling through modifiers, but a major part of our UI configuration also comes down to how we structure our views themselves.</p><p>Let‚Äôs say that we‚Äôre working on a form that lets a user sign up for an account within an app. To make our form look a bit nicer, we‚Äôre prefixing each of our text fields with icons from Apple‚Äôs <a href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview">SF Symbols library</a> ‚Äî giving us an implementation that looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> SignUpForm: <span class="s-type">View</span> {
    ...
    <span class="s-keyword">@State private var</span> username = <span class="s-string">""</span>
    <span class="s-keyword">@State private var</span> email = <span class="s-string">""</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Form</span> {
            <span class="s-type">Text</span>(<span class="s-string">"Sign up"</span>).<span class="s-call">font</span>(.<span class="s-dotAccess">headline</span>)
            <span class="s-type">HStack</span> {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"person.circle.fill"</span>)
                <span class="s-type">TextField</span>(<span class="s-string">"Username"</span>, text: $username)
            }
            <span class="s-type">HStack</span> {
                <span class="s-type">Image</span>(systemName: <span class="s-string">"envelope.circle.fill"</span>)
                <span class="s-type">TextField</span>(<span class="s-string">"Email"</span>, text: $email)
            }
            <span class="s-type">Button</span>(
                action: { ... },
                label: { <span class="s-type">Text</span>(<span class="s-string">"Continue"</span>) }
            )
        }
    }
}</code></pre><p>Above we‚Äôre using the same <code>HStack</code> + <code>Image</code> + <code>TextField</code> combination twice, and while that isn‚Äôt necessarily a problem given that we‚Äôre configuring each of our two text fields quite differently ‚Äî let‚Äôs say that we also wanted to turn that combination into a stand-alone component that we could reuse in other places throughout our app.</p><p>An initial idea on how to do that might be to create a new <code>View</code> type which takes an <code>iconName</code> and <code>title</code> to display, as well as a <code>@Binding</code> reference to the <code>text</code> property that we wish to update whenever our component‚Äôs text field was edited ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> IconPrefixedTextField: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> iconName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">@Binding var</span> text: <span class="s-type">String</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(systemName: iconName)
            <span class="s-type">TextField</span>(title, text: $text)
        }
    }
}</code></pre><p>With the above in place, we can now go back to <code>SignUpForm</code> and replace our previously duplicated <code>HStack</code> configurations with instances of our new <code>IconPrefixedTextField</code> component:</p><pre class="splash"><code><span class="s-keyword">struct</span> SignUpForm: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Form</span> {
            ...
            <span class="s-type">IconPrefixedTextField</span>(
                iconName: <span class="s-string">"person.circle.fill"</span>,
                title: <span class="s-string">"Username"</span>,
                text: $username
            )
            <span class="s-type">IconPrefixedTextField</span>(
                iconName: <span class="s-string">"envelope.circle.fill"</span>,
                title: <span class="s-string">"Email"</span>,
                text: $email
            )
            ...
        }
    }
}</code></pre><p>However, while the above change will enable us to reuse our new <code>IconPrefixedTextField</code> type outside of <code>SignUpForm</code>, it‚Äôs questionable whether it actually ended up <em>improving</em> our original code. After all, we didn‚Äôt really make our sign up form‚Äôs implementation <em>simpler</em> ‚Äî in fact, our above call site arguably looks more complex than what it did before.</p><p>Instead, let‚Äôs take some inspiration from SwiftUI‚Äôs own API design, and see what things would look like if we implemented our text view configuration code as a <code>View</code> extension instead. That way, any view could be prefixed with an icon, simply by calling the following method:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">View</span> {
    <span class="s-keyword">func</span> prefixedWithIcon(named name: <span class="s-type">String</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">HStack</span> {
            <span class="s-type">Image</span>(systemName: name)
            <span class="s-keyword">self</span>
        }
    }
}</code></pre><p>With the above in place, we can now add any SF Symbols icon directly to SwiftUI‚Äôs native <code>TextField</code> views ‚Äî or to any other view ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> SignUpForm: <span class="s-type">View</span> {
    ...

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">Form</span> {
            ...
            <span class="s-type">TextField</span>(<span class="s-string">"Username"</span>, text: $username)
                .<span class="s-call">prefixedWithIcon</span>(named: <span class="s-string">"person.circle.fill"</span>)
            <span class="s-type">TextField</span>(<span class="s-string">"Email"</span>, text: $email)
                .<span class="s-call">prefixedWithIcon</span>(named: <span class="s-string">"envelope.circle.fill"</span>)
            ...
        }
    }
}</code></pre><p>Picking between building a new <code>View</code> implementation and an extension can sometimes be quite difficult, and there‚Äôs really no clear-cut right-or-wrong way of doing things here. However, when we find ourselves creating new <code>View</code> types that just pass properties along to other views, it‚Äôs probably worth asking ourselves whether that code would work better as an extension instead.</p><h2>Modifier types</h2><p>Apart from writing <code>View</code> extensions, SwiftUI also enables us to define custom view modifiers as types conforming to the <code>ViewModifier</code> protocol. Doing so enables us to write modifiers that have their own properties, state and lifecycle ‚Äî which can be used to extend SwiftUI with all sorts of new functionality.</p><p>For example, let‚Äôs say that we wanted to add inline validation to our sign up form from before, by turning each text field‚Äôs border green once the user entered a valid string. While that‚Äôs something that we could‚Äôve implemented within our <code>SignUpForm</code> view directly, let‚Äôs instead build that feature as a completely reusable <code>ViewModifier</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Validation&lt;Value&gt;: <span class="s-type">ViewModifier</span> {
    <span class="s-keyword">var</span> value: <span class="s-type">Value</span>
    <span class="s-keyword">var</span> validator: (<span class="s-type">Value</span>) -&gt; <span class="s-type">Bool</span>

    <span class="s-keyword">func</span> body(content: <span class="s-type">Content</span>) -&gt; <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-comment">// Here we use Group to perform type erasure, to give our
        // method a single return type, as applying the 'border'
        // modifier causes a different type to be returned:</span>
        <span class="s-type">Group</span> {
            <span class="s-keyword">if</span> <span class="s-call">validator</span>(value) {
                content.<span class="s-call">border</span>(<span class="s-type">Color</span>.<span class="s-property">green</span>)
            } <span class="s-keyword">else</span> {
                content
            }
        }
    }
}</code></pre><p>Looking at the above implementation, we can see that a <code>ViewModifier</code> looks very much like a view, in that it has a <code>body</code> that returns <code>some View</code>. The difference is that a modifier operates on an existing view (passed in as <code>Content</code>), rather than being completely stand-alone. The benefit is that we can now add our new validation functionality to any text field (or any view, really), just like when using a <code>View</code> extension, without requiring us build any form of wrapper type:</p><pre class="splash"><code><span class="s-type">TextField</span>(<span class="s-string">"Username"</span>, text: $username)
    .<span class="s-call">modifier</span>(<span class="s-type">Validation</span>(value: username) { name <span class="s-keyword">in</span>
        name.<span class="s-property">count</span> &gt; <span class="s-number">4</span>
    })
    .<span class="s-call">prefixedWithIcon</span>(named: <span class="s-string">"person.circle.fill"</span>)</code></pre><p>Just like when picking between an extension and a brand new <code>View</code> implementation, choosing when to implement a given view configuration as a <code>ViewModifier</code> is most likely going to be a matter of preference and style in many situations.</p><p>However, both the <code>ViewModifier</code> and <code>View</code> types have the advantage that they can contain their own set of state and properties, while extensions are much more lightweight. We‚Äôll take a much closer look at SwiftUI-based state and data management in upcoming articles.</p><h2>Conclusion</h2><p>Just like its predecessors, SwiftUI offers a number of ways for us to structure our UI code and the way we configure our various views. While many of our custom components are likely going to be implemented as stand-alone <code>View</code> types, building our own extensions and modifiers can enable us to share styles and configurations across a code base in a much more lightweight manner ‚Äî and can let us apply those configurations to more than just one type of view.</p><p>How have you been structuring your SwiftUI code so far? Have you used any of the techniques covered in this article already, or will you try them out? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://www.swiftbysundell.com/contact">email</a> or <a href="https://twitter.com/johnsundell">Twitter</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/optionals</guid><title>Basics: Optionals</title><description>Let‚Äôs explore how optional values work in Swift, including how they‚Äôre implemented under the hood, and what sort of techniques that we can use to handle them.</description><link>https://www.swiftbysundell.com/basics/optionals</link><pubDate>Tue, 11 Feb 2020 14:25:00 +0100</pubDate><content:encoded><![CDATA[<p>One key part of Swift‚Äôs overall design is how it requires us to explicitly handle values that might be <em>missing</em>, or <em>optional</em>. While that requirement often forces us to think more thoroughly about how we construct our objects and manage our state ‚Äî it also arguably leads to fewer unhandled runtime errors caused by missing data.</p><p>In Swift, a value is marked as optional by adding a question mark right after its type, which in turn requires us to <em>unwrap</em> that value before it can be used in any concrete way. For example, here we‚Äôre using an <code>if let</code> statement to unwrap an optional <code>User</code> value in order to determine whether a user has logged into our app:</p><pre class="splash"><code><span class="s-keyword">func</span> setupApp(forUser user: <span class="s-type">User</span>?) {
    <span class="s-keyword">if let</span> user = user {
        <span class="s-call">showHomeScreen</span>(for: user)
    } <span class="s-keyword">else</span> {
        <span class="s-call">showLoginScreen</span>()
    }
}</code></pre><p>While there are multiple ways to unwrap and handle optionals, another very common pattern is to use the <code>guard</code> statement to <em><a href="https://www.swiftbysundell.com/articles/early-returning-functions-in-swift">return early</a></em> in case an optional value is missing. Here‚Äôs how we might refactor the above function to use that pattern instead:</p><pre class="splash"><code><span class="s-keyword">func</span> setupApp(forUser user: <span class="s-type">User</span>?) {
    <span class="s-keyword">guard let</span> user = user <span class="s-keyword">else</span> {
        <span class="s-comment">// Guard statements require us to "exit" out of the
        // current scope, for example by returning:</span>
        <span class="s-keyword">return</span> <span class="s-call">showLoginScreen</span>()
    }

    <span class="s-call">showHomeScreen</span>(for: user)
}</code></pre><p>Essentially, optionals provide us with a built-in way to represent the <em>‚Äúlack of a value‚Äù</em> ‚Äî which make them an ideal choice in situations when we need to model some form of default or missing state.</p><p>For example, here we‚Äôve created a <code>Relationship</code> enum, which enables us to express the relationship between two users of our app. Currently, we represent the lack of any relationship using a <code>none</code> case within that enum, which also acts as our default value:</p><pre class="splash"><code><span class="s-keyword">enum</span> Relationship {
    <span class="s-keyword">case</span> none
    <span class="s-keyword">case</span> friend
    <span class="s-keyword">case</span> family
    <span class="s-keyword">case</span> coworker
}

<span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> relationship: <span class="s-type">Relationship</span> = .<span class="s-dotAccess">none</span>
    ...
}</code></pre><p>However, while the above code technically works, it would arguably be better to implement our <code>relationship</code> property as an optional instead. That way, we can use Swift‚Äôs built-in way to represent the lack of any relationship, which will both let us use mechanisms like <code>if let</code> and <code>guard</code> ‚Äî and also lets us simplify our enum by removing its <code>none</code> case:</p><pre class="splash"><code><span class="s-keyword">enum</span> Relationship {
    <span class="s-keyword">case</span> friend
    <span class="s-keyword">case</span> family
    <span class="s-keyword">case</span> coworker
}

<span class="s-keyword">struct</span> User {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> relationship: <span class="s-type">Relationship</span>? = <span class="s-keyword">nil</span>
    ...
}</code></pre><p>However, optionals can also become a source of ambiguity if we‚Äôre not careful. It‚Äôs always important to consider whether a given value is <em>actually optional</em> before implementing it as such ‚Äî since if a value is required in order for our code to function, we should ideally be able to guarantee that it‚Äôll always be there.</p><p>For example, let‚Äôs have a look at a view controller implementation which currently uses optionals to store its subviews ‚Äî a <code>headerView</code> and a <code>logOutButton</code> ‚Äî in order to <em>lazily create them</em> once the system calls <code>viewDidLoad()</code>, which is the recommended way of constructing view controller-based UIs:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private var</span> headerView: <span class="s-type">HeaderView</span>?
    <span class="s-keyword">private var</span> logOutButton: <span class="s-type">UIButton</span>?

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> headerView = <span class="s-type">HeaderView</span>()
        view.<span class="s-call">addSubview</span>(headerView)
        <span class="s-keyword">self</span>.<span class="s-property">headerView</span> = headerView

        <span class="s-keyword">let</span> logOutButton = <span class="s-type">UIButton</span>()
        view.<span class="s-call">addSubview</span>(logOutButton)
        <span class="s-keyword">self</span>.<span class="s-property">logOutButton</span> = logOutButton
        
        <span class="s-comment">// More view configuration</span>
        ...
    }
}</code></pre><p>The above is a very common pattern, but it does come with a quite substantial problem, in that we always have to keep unwrapping our subviews as optionals ‚Äî even though they are required parts of our view controller‚Äôs logic. For example, here we have to unwrap our <code>headerView</code> property in order to be able to assign various model values to its properties:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ProfileViewController</span> {
    <span class="s-keyword">func</span> userDidUpdate(<span class="s-keyword">_</span> user: <span class="s-type">User</span>) {
        <span class="s-keyword">guard let</span> headerView = headerView <span class="s-keyword">else</span> {
            <span class="s-comment">// This should never happen, but we still have
            // to maintain this code path.</span>
            <span class="s-keyword">return</span>
        }

        headerView.<span class="s-property">imageView</span>.<span class="s-property">image</span> = user.<span class="s-property">image</span>
        headerView.<span class="s-property">label</span>.<span class="s-property">text</span> = user.<span class="s-property">name</span>
    }
}</code></pre><p>What we‚Äôre essentially dealing with above, is <em><a href="https://www.swiftbysundell.com/articles/handling-non-optional-optionals-in-swift">non-optional optionals</a></em> ‚Äî values that might <em>technically</em> be optionals, but are in fact <strong>not optional</strong> when it comes to how we‚Äôve implemented our logic.</p><p>While removing non-optional optionals can sometimes be quite difficult, in the above case, there‚Äôs a quite straightforward way. Using Swift‚Äôs <code>lazy</code> keyword, we can delay the initialization of our view controller‚Äôs subviews until those properties are first accessed ‚Äî giving us the exact same behavior as we had before, but without any optionals ‚Äî leading to much simpler code:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private lazy var</span> headerView = <span class="s-type">HeaderView</span>()
    <span class="s-keyword">private lazy var</span> logOutButton = <span class="s-type">UIButton</span>()

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        view.<span class="s-call">addSubview</span>(headerView)
        view.<span class="s-call">addSubview</span>(logOutButton)
        
        <span class="s-comment">// More view configuration</span>
        ...
    }

    <span class="s-keyword">func</span> userDidUpdate(<span class="s-keyword">_</span> user: <span class="s-type">User</span>) {
        headerView.<span class="s-property">imageView</span>.<span class="s-property">image</span> = user.<span class="s-property">image</span>
        headerView.<span class="s-property">label</span>.<span class="s-property">text</span> = user.<span class="s-property">name</span>
    }
}</code></pre><p class="info">For more information about using lazy properties in Swift, <a href="https://www.swiftbysundell.com/articles/using-lazy-properties-in-swift">check out this article</a>.</p><p>An alternative way of dealing with non-optional optionals is to use force unwrapping (using <code>!</code>) to turn an optional value into a concrete one, without any checks. However, while force unwrapping might occasionally be warranted, it does always come with the risk of causing a crash in case its value ended up being missing ‚Äî so if we can find another solution, that‚Äôs most often preferable.</p><p>Next, let‚Äôs take a quick look under the hood of how optionals are actually implemented. The cool thing about Swift‚Äôs version of optionals is that they‚Äôre actually modeled using a standard enum, which looks like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> Optional&lt;Wrapped&gt;: <span class="s-type">ExpressibleByNilLiteral</span> {
    <span class="s-keyword">case</span> none
    <span class="s-keyword">case</span> some(<span class="s-type">Wrapped</span>)
}</code></pre><p>The above is just one of many examples of how Swift uses its <em>own type system</em> to implement many of its core language features ‚Äî which is not only a really interesting design, but in this case also enables us to treat optional values just like any other enum. For example, we can switch on them:</p><pre class="splash"><code><span class="s-keyword">func</span> icon(forRelationship relationship: <span class="s-type">Relationship</span>?) -&gt; <span class="s-type">Icon</span>? {
    <span class="s-comment">// Here we switch on the optional itself, rather than on
    // its underlying Relationship value:</span>
    <span class="s-keyword">switch</span> relationship {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">some</span>(<span class="s-keyword">let</span> relationship):
        <span class="s-comment">// Then, we switch on the wrapped value itself:</span>
        <span class="s-keyword">switch</span> relationship {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">friend</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">user</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">family</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">familyMember</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">coworker</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">work</span>
        }
    <span class="s-keyword">case</span> .<span class="s-dotAccess">none</span>:
        <span class="s-keyword">return nil</span>
    }
}</code></pre><p>The above might be interesting in terms of how Swift‚Äôs various features work together ‚Äî but the resulting code is arguably a bit hard to read, due to the many nested statements. Thankfully, Swift also enables us to switch on any optional directly ‚Äî just as if we were switching on its wrapped value. All we have to do is to include a <code>nil</code> case to handle the lack of a value:</p><pre class="splash"><code><span class="s-keyword">func</span> icon(forRelationship relationship: <span class="s-type">Relationship</span>?) -&gt; <span class="s-type">Icon</span>? {
    <span class="s-keyword">switch</span> relationship {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">friend</span>:
        <span class="s-keyword">return</span> .<span class="s-dotAccess">user</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">family</span>:
        <span class="s-keyword">return</span> .<span class="s-dotAccess">familyMember</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">coworker</span>:
        <span class="s-keyword">return</span> .<span class="s-dotAccess">work</span>
    <span class="s-keyword">case nil</span>:
        <span class="s-keyword">return nil</span>
    }
}</code></pre><p class="info">The above syntax works in Swift 5.1 and above. When using earlier versions, we have to append a question mark to each non-<code>nil</code> case ‚Äî like this: <code>case .friend?:</code>.</p><p>The fact that optionals are implemented using their own, stand-alone type, also means that they can have methods and properties of their own. For example, here we‚Äôre converting a <code>String</code> that represents a URL into a <code>URLRequest</code> instance ‚Äî which requires us to first optionally convert that string into a <code>URL</code> value, which we then pass into our new <code>URLRequest</code>:</p><pre class="splash"><code><span class="s-keyword">func</span> makeRequest(forURLString string: <span class="s-type">String</span>) -&gt; <span class="s-type">URLRequest</span>? {
    <span class="s-keyword">guard let</span> url = <span class="s-type">URL</span>(string: string) <span class="s-keyword">else</span> {
        <span class="s-keyword">return nil</span>
    }

    <span class="s-keyword">return</span> <span class="s-type">URLRequest</span>(url: url)
}</code></pre><p>The above code works, but if we wanted to, we could make it a lot more compact ‚Äî by instead calling <code>map</code> directly on our optional <code>URL</code>. Similar to how we can use <code>map</code> to <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap">transform a collection</a>, calling <code>map</code> on an optional lets us use a closure to transform any value that it‚Äôs wrapping ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">func</span> makeRequest(forURLString string: <span class="s-type">String</span>) -&gt; <span class="s-type">URLRequest</span>? {
    <span class="s-type">URL</span>(string: string).<span class="s-call">map</span> { <span class="s-type">URLRequest</span>(url: $0) }
}</code></pre><p>What‚Äôs really cool is that not only can we use methods and properties that come built into the <code>Optional</code> type, we can also define our own. For example, here‚Äôs how we could define two properties that enable us to check whether any collection is <code>nil</code> or empty:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Optional</span> <span class="s-keyword">where</span> <span class="s-type">Wrapped</span>: <span class="s-type">Collection</span> {
    <span class="s-keyword">var</span> isNilOrEmpty: <span class="s-type">Bool</span> {
        <span class="s-comment">// If the left-hand expression is nil, the right one
        // will be used, meaning that 'true' is our default:</span>
        <span class="s-keyword">self</span>?.<span class="s-property">isEmpty</span> ?? <span class="s-keyword">true</span>
    }

    <span class="s-keyword">var</span> nonEmpty: <span class="s-type">Wrapped</span>? {
        <span class="s-comment">// Either return this collection, or nil if it's empty:</span>
        isNilOrEmpty ? nil : <span class="s-keyword">self</span>
    }
}</code></pre><p>With the above in place, we can now easily handle any missing values, and empty ones ‚Äî all using a single <code>guard</code> statement:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">EditorViewController</span>: <span class="s-type">UITextFieldDelegate</span> {
    <span class="s-keyword">func</span> textFieldDidEndEditing(<span class="s-keyword">_</span> textField: <span class="s-type">UITextField</span>) {
        <span class="s-keyword">guard let</span> text = textField.<span class="s-property">text</span>.<span class="s-property">nonEmpty</span> <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span>
        }

        <span class="s-comment">// Handle non-empty text</span>
        ...
    }
}</code></pre><p class="info">To learn more about the above technique, check out <a href="https://www.swiftbysundell.com/articles/extending-optionals-in-swift">‚ÄúExtending optionals in Swift‚Äù</a>.</p><p>How we handle our optional, potentially missing values is arguably just as important as how we handle our concrete ones ‚Äî and by fully utilizing Swift‚Äôs <code>Optional</code> type and its various features, we can often end up with code that doesn‚Äôt only have a higher chance of being correct, but that‚Äôs also very concise and elegant as well.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/exploring-swift-5-2s-new-functional-features</guid><title>Exploring Swift 5.2‚Äôs new functional features</title><description>Let‚Äôs explore two of Swift 5.2‚Äôs new features, that both give the language some really interesting capabilities from a functional programming perspective.</description><link>https://www.swiftbysundell.com/articles/exploring-swift-5-2s-new-functional-features</link><pubDate>Sun, 9 Feb 2020 22:15:00 +0100</pubDate><content:encoded><![CDATA[<p>On the surface level, Swift 5.2 is definitely a minor release in terms of new language features, as much of the focus of this new release has been on improving the speed and stability of Swift‚Äôs underlying infrastructure ‚Äî such as how compiler errors are reported, and how build-level dependencies are resolved.</p><p>However, while Swift 5.2‚Äôs <em>total number</em> of new language features might be relatively small, it does include two new capabilities that could potentially have quite a big impact on Swift‚Äôs overall power as a <em>functional programming language</em>.</p><p>This week, let‚Äôs explore those features, and how we could potentially use them to embrace a few different paradigms that are very popular in the functional programming world ‚Äî in ways that might feel more consistent and familiar within an object-oriented Swift code base.</p><p>Before we begin, as Swift 5.2 is (at the time of writing) still in beta as part of Xcode 11.4, please note that this article is a very exploratory piece that represents my first impressions of these new language features. My opinions are likely to change as I gain more experience using the new features in production, and while I‚Äôll try to keep this article updated as that happens, I recommend using this article purely as inspiration to explore these new features yourself, rather than directly using the solutions presented as-is.</p><p>With that little disclaimer out of the way, let‚Äôs start exploring!</p><h2>Calling types as functions</h2><p>Even though Swift isn‚Äôt a strictly functional programming language, there‚Äôs no doubt that functions play a very central role in its overall design and usage. From how closures are used as asynchronous callbacks, to how collections make heavy use of classic functional patterns like <code>map</code> and <code>reduce</code> ‚Äî functions are everywhere.</p><p>What‚Äôs interesting about Swift 5.2 in this regard is that it starts to blur the lines between functions and types. Although we‚Äôve always been able to pass any given type‚Äôs instance methods as functions (since Swift supports <a href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift">first class functions</a>), we‚Äôre now able to <em>call certain types as if they were functions themselves</em>.</p><p>Let‚Äôs start by taking a look at an example using an excerpt of the <code>Cache</code> type that we built in <em><a href="https://www.swiftbysundell.com/articles/caching-in-swift">‚ÄùCaching in Swift‚Äù</a></em> ‚Äî which provides a more <em>‚ÄúSwift-friendly‚Äù</em> API on top of a wrapped <code>NSCache</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> Cache&lt;Key: <span class="s-type">Hashable</span>, Value&gt; {
    <span class="s-keyword">private let</span> wrapped = <span class="s-type">NSCache</span>&lt;<span class="s-type">WrappedKey</span>, <span class="s-type">Entry</span>&gt;()
    <span class="s-keyword">private let</span> dateProvider: () -&gt; <span class="s-type">Date</span>
    <span class="s-keyword">private let</span> entryLifetime: <span class="s-type">TimeInterval</span>
    
    ...

    <span class="s-keyword">func</span> insert(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>, forKey key: <span class="s-type">Key</span>) {
        ...
    }
}</code></pre><p>Let‚Äôs say that we wanted to add a convenience API to the above type ‚Äî to let us automatically use an inserted value‚Äôs <code>id</code> as its cache key, in case the current <code>Value</code> type conforms to the standard library‚Äôs <code>Identifiable</code> protocol. While we could simply name that new API <code>insert</code> as well, we‚Äôre going to give it a very particular name ‚Äî <code>callAsFunction</code>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Cache</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Identifiable</span>, <span class="s-type">Key</span> == <span class="s-type">Value</span>.<span class="s-type">ID</span> {
    <span class="s-keyword">func</span> callAsFunction(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) {
        <span class="s-call">insert</span>(value, forKey: value.<span class="s-property">id</span>)
    }
}</code></pre><p>That might seem like a strange naming convention, but by naming our new convenience method that way, we‚Äôve actually given our <code>Cache</code> type an interesting new capability ‚Äî it may now be called as if it was a function ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">let</span> document: <span class="s-type">Document</span> = ...
<span class="s-keyword">let</span> cache = <span class="s-type">Cache</span>&lt;<span class="s-type">Document</span>.<span class="s-type">ID</span>, <span class="s-type">Document</span>&gt;()

<span class="s-comment">// We can now call our 'cache' variable as if it was referencing a
// function or a closure:</span>
<span class="s-call">cache</span>(document)</code></pre><p>That‚Äôs arguably both really cool, and really strange. But the question is ‚Äî what might it be useful for? Let‚Äôs continue exploring by taking a look at a <code>DocumentRenderer</code> protocol, that defines a common interface for various types that are used to render <code>Document</code> instances within an app:</p><pre class="splash"><code><span class="s-keyword">protocol</span> DocumentRenderer {
    <span class="s-keyword">func</span> render(<span class="s-keyword">_</span> document: <span class="s-type">Document</span>,
                in context: <span class="s-type">DocumentRenderingContext</span>,
                enableAnnotations: <span class="s-type">Bool</span>)
}</code></pre><p>Similar to how we previously added a function-based convenience API to our <code>Cache</code> type, let‚Äôs do the same thing here ‚Äî only this time, we‚Äôll extend the above protocol to enable any conforming type to be called as a function with a set of default arguments:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">DocumentRenderer</span> {
    <span class="s-keyword">func</span> callAsFunction(<span class="s-keyword">_</span> document: <span class="s-type">Document</span>) {
        <span class="s-call">render</span>(document,
            in: .<span class="s-call">makeDefaultContext</span>(),
            enableAnnotations: <span class="s-keyword">false</span>
        )
    }
}</code></pre><p>Each of the above two changes might not seem that impressive in isolation, but if we put them together, we can start to see the appeal of providing function-based convenience APIs for some of our more complex types. For example, here we‚Äôve built a <code>DocumentViewController</code> ‚Äî which uses both our <code>Cache</code> type, and a Core Animation-based implementation of our <code>DocumentRenderer</code> protocol ‚Äî both of which can now simply be called as functions when a document was loaded:</p><pre class="splash"><code><span class="s-keyword">class</span> DocumentViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> cache: <span class="s-type">Cache</span>&lt;<span class="s-type">Document</span>.<span class="s-type">ID</span>, <span class="s-type">Document</span>&gt;
    <span class="s-keyword">private let</span> render: <span class="s-type">CoreAnimationDocumentRenderer</span>
    
    ...

    <span class="s-keyword">private func</span> documentDidLoad(<span class="s-keyword">_</span> document: <span class="s-type">Document</span>) {
        <span class="s-call">cache</span>(document)
        <span class="s-call">render</span>(document)
    }
}</code></pre><p>That‚Äôs quite cool, especially if we‚Äôre aiming for a more <a href="https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift">lightweight API design</a>, or if we‚Äôre building some form of <a href="https://www.swiftbysundell.com/articles/building-dsls-in-swift">domain-specific language</a>. While it‚Äôs always been possible to achieve a similar result by passing instance methods <a href="https://www.swiftbysundell.com/clips/1">as if they were closures</a> ‚Äî by enabling our types to be called directly, we both avoid having to manually pass those methods, and we‚Äôre able to retain any external parameter labels that our APIs might be using.</p><p>For example, let‚Äôs say that we also wanted to make a <code>PriceCalculator</code> become a callable type. To maintain the semantics of our original API, we‚Äôll keep the <code>for</code> external parameter label, even when declaring our <code>callAsFunction</code> implementation ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">func</span> callAsFunction(for product: <span class="s-type">Product</span>) -&gt; <span class="s-type">Int</span> {
        <span class="s-call">calculatePrice</span>(for: product)
    }
}</code></pre><p>Here‚Äôs how the above approach compares to if we were to store a reference to our type‚Äôs <code>calculatePrice</code> method instead ‚Äî note how the first piece of code discards our parameter label, while the second retains it:</p><pre class="splash"><code><span class="s-comment">// Using a method reference:</span>
<span class="s-keyword">let</span> calculatePrice = <span class="s-type">PriceCalculator</span>().<span class="s-property">calculatePrice</span>
...
<span class="s-call">calculatePrice</span>(product)

<span class="s-comment">// Calling our type directly:</span>
<span class="s-keyword">let</span> calculatePrice = <span class="s-type">PriceCalculator</span>()
...
<span class="s-call">calculatePrice</span>(for: product)</code></pre><p>Enabling types to be called as if they were functions is a very intriguing concept, but perhaps even more interesting is that it also enables us to go the opposite direction ‚Äî and transform functions into proper types.</p><h2>Functional programming in an object-oriented way</h2><p>While there‚Äôs a tremendous amount of power in many functional programming concepts, applying those concepts and patterns when using heavily object-oriented frameworks (like most of Apple‚Äôs are) can often be quite challenging. Let‚Äôs see if Swift 5.2‚Äôs new callable types feature that can help us change that.</p><p>Since we can now make any type callable, we could also enable any function to be converted into a type, while still enabling that function to be called as it normally would. To make that happen, let‚Äôs define a type called <code>Function</code>, which looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Function&lt;Input, Output&gt; {
    <span class="s-keyword">let</span> raw: (<span class="s-type">Input</span>) -&gt; <span class="s-type">Output</span>

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> raw: <span class="s-keyword">@escaping</span> (<span class="s-type">Input</span>) -&gt; <span class="s-type">Output</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">raw</span> = raw
    }

    <span class="s-keyword">func</span> callAsFunction(<span class="s-keyword">_</span> input: <span class="s-type">Input</span>) -&gt; <span class="s-type">Output</span> {
        <span class="s-call">raw</span>(input)
    }
}</code></pre><p class="info">Just like the callable types that we defined earlier, <code>Function</code> instances can be called directly, making them act the same way as their underlying functions in most cases.</p><p>To enable functions that don‚Äôt accept any input to still be called without having to manually specify <code>Void</code> as an argument, let‚Äôs also define the following extension for <code>Function</code> values which have <code>Void</code> as their <code>Input</code> type:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Function</span> <span class="s-keyword">where</span> <span class="s-type">Input</span> == <span class="s-type">Void</span> {
    <span class="s-keyword">func</span> callAsFunction() -&gt; <span class="s-type">Output</span> {
        <span class="s-call">raw</span>(<span class="s-type">Void</span>())
    }
}</code></pre><p>The cool thing about the above wrapper type is that it enables us to adopt really powerful functional programming concepts in much more object-oriented ways. Let‚Äôs take a look at two such concepts ‚Äî <em>partial application</em> and <em>piping</em> (which we also used in <em><a href="https://www.swiftbysundell.com/articles/functional-networking-in-swift">‚ÄúFunctional networking in Swift‚Äù</a></em>). The former lets us combine a function with a value to produce a new function that doesn‚Äôt require any input, while the latter enables us to chain two functions together ‚Äî and could now be implemented like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Function</span> {
    <span class="s-keyword">func</span> combined(with value: <span class="s-type">Input</span>) -&gt; <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, <span class="s-type">Output</span>&gt; {
        <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, <span class="s-type">Output</span>&gt; { <span class="s-keyword">self</span>.<span class="s-call">raw</span>(value) }
    }
    
    <span class="s-keyword">func</span> chained&lt;T&gt;(to next: <span class="s-keyword">@escaping</span> (<span class="s-type">Output</span>) -&gt; <span class="s-type">T</span>) -&gt; <span class="s-type">Function</span>&lt;<span class="s-type">Input</span>, <span class="s-type">T</span>&gt; {
        <span class="s-type">Function</span>&lt;<span class="s-type">Input</span>, <span class="s-type">T</span>&gt; { <span class="s-call">next</span>(<span class="s-keyword">self</span>.<span class="s-call">raw</span>($0)) }
    }
}</code></pre><p class="info">Note how we named the above two functions <code>combined</code> and <code>chained</code> in order to make them feel more <em>‚Äúat home‚Äù</em> in Swift, rather than using the names typically found in more strictly functional programming languages.</p><p>What the above setup enables us to do is to use techniques like <a href="https://www.swiftbysundell.com/articles/simple-swift-dependency-injection-with-functions">function-based dependency injection</a> in a way that still feels very object-oriented. For example, here we‚Äôve built a view controller for editing notes ‚Äî which accepts two functions, one for loading the current version of the note that it‚Äôs editing, and one for submitting an update to our app‚Äôs central data store:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteEditorViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> provideNote: <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, <span class="s-type">Note</span>&gt;
    <span class="s-keyword">private let</span> updateNote: <span class="s-type">Function</span>&lt;<span class="s-type">Note</span>, <span class="s-type">Void</span>&gt;

    <span class="s-keyword">init</span>(provideNote: <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, <span class="s-type">Note</span>&gt;,
         updateNote: <span class="s-type">Function</span>&lt;<span class="s-type">Note</span>, <span class="s-type">Void</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">provideNote</span> = provideNote
        <span class="s-keyword">self</span>.<span class="s-property">updateNote</span> = updateNote
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }
    
    ...

    <span class="s-keyword">private func</span> editorTextDidChange(to text: <span class="s-type">String</span>) {
        <span class="s-keyword">var</span> note = <span class="s-call">provideNote</span>()
        note.<span class="s-property">text</span> = text
        <span class="s-call">updateNote</span>(note)
    }
}</code></pre><p>The beauty of the above approach is that it lets us build our UI in a way that‚Äôs completely decoupled from the concrete types that we use to drive our model and data logic. For example, the functions that our above view controller actually uses are in this case methods on a <code>NoteManager</code> type, that looks like this:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManager {
    ...

    <span class="s-keyword">func</span> loadNote(withID id: <span class="s-type">Note</span>.<span class="s-type">ID</span>) -&gt; <span class="s-type">Note</span> {
        ...
    }
    
    <span class="s-keyword">func</span> updateNote(<span class="s-keyword">_</span> note: <span class="s-type">Note</span>) {
        ...
    }
}</code></pre><p>Then, when we‚Äôre creating an instance of our view controller, we‚Äôre using our <code>Function</code> type to convert the above two methods into functions that our UI code can directly call ‚Äî without having to be aware of any of the underlying types or details:</p><pre class="splash"><code><span class="s-keyword">func</span> makeEditorViewController(
    forNoteID noteID: <span class="s-type">Note</span>.<span class="s-type">ID</span>
) -&gt; <span class="s-type">UIViewController</span> {
    <span class="s-keyword">let</span> provider = <span class="s-type">Function</span>(noteManager.<span class="s-property">loadNote</span>).<span class="s-call">combined</span>(with: noteID)
    <span class="s-keyword">let</span> updater = <span class="s-type">Function</span>(noteManager.<span class="s-property">updateNote</span>)

    <span class="s-keyword">return</span> <span class="s-type">NoteEditorViewController</span>(
        provideNote: provider,
        updateNote: updater
    )
}</code></pre><p>Not only does the above approach give us a greater separation of concerns, it also makes testing a breeze, as we no longer have to mock any protocols or fight with singleton-based global state ‚Äî we can simply inject any sort of behavior that we wish to test against by <a href="https://www.swiftbysundell.com/articles/mock-free-unit-tests-in-swift/%23functional-behavior">passing in test-specific functions</a>.</p><h2>Passing key paths as functions</h2><p>Another really interesting new feature introduced in Swift 5.2 is that <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a> can now be passed as functions. That comes very much in handy in situations when we‚Äôre using a closure simply to extract a piece of data from a property ‚Äî as we can now pass that property‚Äôs key path directly:</p><pre class="splash"><code><span class="s-keyword">let</span> notes: [<span class="s-type">Note</span>] = ...

<span class="s-comment">// Before:</span>
<span class="s-keyword">let</span> titles = notes.<span class="s-call">map</span> { $0.<span class="s-property">title</span> }

<span class="s-comment">// After:</span>
<span class="s-keyword">let</span> titles = notes.<span class="s-call">map</span>(\.<span class="s-property">title</span>)</code></pre><p>Combining that capability with our <code>Function</code> type from before, we can now easily construct a chain of functions that lets us load a given value, and then extract a property from it. Here we‚Äôre doing just that to create a function that lets us easily look up what tags that are associated with a given note ID:</p><pre class="splash"><code><span class="s-keyword">func</span> tagLoader(forNoteID noteID: <span class="s-type">Note</span>.<span class="s-type">ID</span>) -&gt; <span class="s-type">Function</span>&lt;<span class="s-type">Void</span>, [<span class="s-type">Tag</span>]&gt; {
    <span class="s-type">Function</span>(noteManager.<span class="s-property">loadNote</span>)
        .<span class="s-call">combined</span>(with: noteID)
        .<span class="s-call">chained</span>(to: \.<span class="s-property">tags</span>)
}</code></pre><p>Of course, the above examples barely scratch the surface of what could be possible when we start to mix functional programming patterns with object-oriented APIs ‚Äî so it‚Äôs definitely a topic that we‚Äôll return to in future articles.</p><h2>Conclusion</h2><p>Swift 5.2 and Xcode 11.4 are both quite substantial releases ‚Äî with a new diagnostics engine for compiler errors, lots of new testing and debugging features, and <a href="https://developer.apple.com/documentation/xcode_release_notes/xcode_11_4_beta_release_notes">much more</a>. But Swift 5.2 is also an interesting release from a syntax perspective, as it continues to broaden the ways that Swift can be used to adopt functional programming concepts, and how it starts to blur the lines between types and functions.</p><p>I‚Äôll of course continue to explore these features over the coming weeks and months, and will report my findings in future articles, <a href="https://www.swiftbysundell.com/podcast">podcast episodes</a> and <a href="https://www.swiftbysundell.com/videos">videos</a>.</p><p>What do you think? What are your first impressions of these new features, and do you have any concrete use cases in which they might become useful? Let me know ‚Äî along with your questions, comments or feedback ‚Äî either via <a href="https://www.swiftbysundell.com/contact">email</a> or <a href="https://twitter.com/johnsundell">Twitter</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/passing-key-paths-as-functions</guid><title>Tip: Passing key paths as functions</title><description></description><link>https://www.swiftbysundell.com/tips/passing-key-paths-as-functions</link><pubDate>Thu, 6 Feb 2020 17:25:00 +0100</pubDate><content:encoded><![CDATA[<p><strong>New in Swift 5.2:</strong> Key path literals can now be passed as functions. This might be a small change in the grand scheme of things, but it really makes closures in which we‚Äôre simply accessing a property read so much nicer ‚Äî since we can now pass that property‚Äôs key path directly:</p><pre class="splash"><code><span class="s-keyword">struct</span> Movie {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> isFavorite: <span class="s-type">Bool</span>
    ...
}

<span class="s-keyword">let</span> movies: [<span class="s-type">Movie</span>] = <span class="s-call">loadMovies</span>()

<span class="s-comment">// Equivalent to movies.map { $0.name }</span>
<span class="s-keyword">let</span> movieNames = movies.<span class="s-call">map</span>(\.<span class="s-property">name</span>)

<span class="s-comment">// Equivalent to movies.filter { $0.isFavorite }</span>
<span class="s-keyword">let</span> favoriteMovies = movies.<span class="s-call">filter</span>(\.<span class="s-property">isFavorite</span>)</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/picking-between-for-and-for-each</guid><title>Tip: Picking between a for loop and forEach</title><description></description><link>https://www.swiftbysundell.com/tips/picking-between-for-and-for-each</link><pubDate>Tue, 4 Feb 2020 17:40:00 +0100</pubDate><content:encoded><![CDATA[<p>When iterating over a collection, such an <code>Array</code> or a <code>Set</code>, it may at first seem like a matter of preference and style whether to use a classic <code>for</code> loop, or the closure-based <code>forEach</code> method. While it‚Äôs definitely true that those two mechanisms are highly similar, they do differ in a few distinct ways.</p><p>One of those differences is that a <code>for</code> loop‚Äôs iteration is performed directly within our code‚Äôs control flow, which gives us much more precise control over those iterations. For example, we can choose to skip to the next element at any point using the <code>continue</code> keyword, or to break the iteration completely using <code>break</code>:</p><pre class="splash"><code><span class="s-keyword">func</span> recentArticles(among articles: [<span class="s-type">Article</span>]) -&gt; [<span class="s-type">Article</span>] {
    <span class="s-keyword">var</span> results = [<span class="s-type">Article</span>]()
    
    <span class="s-keyword">for</span> article <span class="s-keyword">in</span> articles {
        <span class="s-keyword">guard</span> !article.<span class="s-property">isDraft</span> <span class="s-keyword">else</span> {
            <span class="s-comment">// Immediately skip to the next element.</span>
            <span class="s-keyword">continue</span>
        }
    
        results.<span class="s-call">append</span>(article)
        
        <span class="s-keyword">guard</span> results.<span class="s-property">count</span> &lt; <span class="s-number">5</span> <span class="s-keyword">else</span> {
            <span class="s-comment">// Break the iteration. In this case we could've also
            // returned here directly.</span>
            <span class="s-keyword">break</span>
        }
    }
    
    <span class="s-keyword">return</span> results
}</code></pre><p>When a <code>for</code> loop‚Äôs iteration starts with a <code>guard</code> (or <code>if</code>) statement that‚Äôs used for filtering (like above), we can also chose to implement that logic using <code>where</code>-based <a href="https://www.swiftbysundell.com/articles/pattern-matching-in-swift/%23iterative-patterns">pattern matching</a> instead ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">for</span> article <span class="s-keyword">in</span> articles <span class="s-keyword">where</span> !article.<span class="s-property">isDraft</span> {
    results.<span class="s-call">append</span>(article)
    
    <span class="s-keyword">guard</span> results.<span class="s-property">count</span> &lt; <span class="s-number">5</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">break</span>
    }
}</code></pre><p>The above kind of control flow-related features are a big part of what makes <code>for</code> loops so powerful, but if we don‚Äôt need that level of control, using a call to <code>forEach</code> might give us slightly simpler-looking code. For example, here we‚Äôre adding a new view for each of an array‚Äôs elements, which can be done really elegantly using <code>forEach</code>:</p><pre class="splash"><code><span class="s-keyword">func</span> addArticleViews(for articles: [<span class="s-type">Article</span>]) {
    articles.<span class="s-call">forEach</span> { article <span class="s-keyword">in
        let</span> articleView = <span class="s-type">ArticleView</span>()
        
        <span class="s-comment">// Seting up our new view using the closure's article.</span>
        ...
        
        view.<span class="s-call">addSubview</span>(articleView)
    }
}</code></pre><p>However, it would perhaps be even more elegant to use Swift‚Äôs <em><a href="https://www.swiftbysundell.com/clips/1">first class functions</a></em> capabilities ‚Äî by refactoring the above method to only accept a single <code>Article</code>, and then directly injecting that method into a call to <code>forEach</code>, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ArticleGroupViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> articles: [<span class="s-type">Article</span>]
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        ...
        articles.<span class="s-call">forEach</span>(addArticleView)
    }

    <span class="s-keyword">private func</span> addArticleView(for article: <span class="s-type">Article</span>) {
        <span class="s-keyword">let</span> articleView = <span class="s-type">ArticleView</span>()
        ...
        view.<span class="s-call">addSubview</span>(articleView)
    }
}</code></pre><p>To sum up: Using a <code>for</code> loop gives us a much greater degree of control over an iteration, while using <code>forEach</code> enables us to take advantage of the power of closures and first class functions, even though we won‚Äôt be able to stop an iteration once it was started (apart from throwing an error, that is).</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/slicing-swift-collections</guid><title>Slicing Swift collections</title><description>Let‚Äôs take a look at how we can utilize Swift‚Äôs various collection slicing APIs, and how doing so can help us boost the performance of various algorithms and functionality.</description><link>https://www.swiftbysundell.com/articles/slicing-swift-collections</link><pubDate>Sun, 2 Feb 2020 18:00:00 +0100</pubDate><content:encoded><![CDATA[<p>One of Swift‚Äôs goals is to be a truly general-purpose programming language ‚Äî that gracefully scales from high-level tasks, like building UIs and scripting, to low-level systems programming. That‚Äôs quite an ambitious goal, and arguably one that‚Äôs yet to be fully achieved, but there are a number of aspects of Swift‚Äôs design that does give it very scalable characteristics.</p><p>One such aspect is how the standard library takes great care to make working with its built-in collections as efficient as possible ‚Äî by minimizing the number of circumstances in which their elements need to be copied, mutated and moved.</p><p>However, like with most optimizations, fully utilizing those behaviors does also require us to write our code in specific ways ‚Äî especially when accessing slices or subsets of a given collection. That‚Äôs exactly what we‚Äôll take a look at this week.</p><h2>A slice of a binary pie</h2><p>In Swift, a <em>slice</em> is a special kind of collection that doesn‚Äôt actually store any elements of its own, but rather acts as a proxy (or <em>view</em>) to enable us access and work with a subset of another collection as a separate instance.</p><p>As a very simple example, let‚Äôs say that we have an array containing ten numbers, and that we wish to extract the first five numbers in order to work with them separately. That can be done using <code>Range</code>-based <a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift">subscripting</a>, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> numbers = [<span class="s-number">1</span>, <span class="s-number">2</span>, <span class="s-number">3</span>, <span class="s-number">4</span>, <span class="s-number">5</span>, <span class="s-number">6</span>, <span class="s-number">7</span>, <span class="s-number">8</span>, <span class="s-number">9</span>, <span class="s-number">10</span>]
<span class="s-keyword">let</span> firstFive = numbers[..&lt;<span class="s-number">5</span>]</code></pre><p>At first glance, it might seem like <code>firstFive</code> would have the same type as <code>numbers</code>, which is <code>Array&lt;Int&gt;</code>, but it actually doesn‚Äôt. In fact, what we‚Äôve done above is to create a slice, in this case of type <code>ArraySlice&lt;Int&gt;</code>.</p><p>Rather than copying the first five elements into a new <code>Array</code> instance, the standard library instead simply provided us with a view into that range of elements ‚Äî which has significant performance benefits, especially when working with larger collections.</p><p>By not performing any copying or additional memory allocation for a collection‚Äôs elements, a slice can be created in constant (<code>O(1)</code>) time. Not only does that make creating a single slice faster, it also makes further slicing just as fast as if we performed it on the original collection ‚Äî giving us a lot of freedom when it comes to how we use and compose Swift‚Äôs various slicing APIs in practice.</p><h2>Prefixes and suffixes</h2><p>Let‚Äôs start by taking a look at how we can use slicing to extract <em>prefixes</em> and <em>suffixes</em> from a collection. As an example, let‚Äôs say that we‚Äôre working on a todo app, which uses the following model to represent one of its todo lists:</p><pre class="splash"><code><span class="s-keyword">struct</span> TodoList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> items = [<span class="s-type">Item</span>]()
    ...
}</code></pre><p>Now let‚Äôs say that we‚Äôre building a feature that lets our users quickly view the top three items within any given list ‚Äî for example within a <em>‚ÄúToday Extension‚Äù</em> widget on iOS or macOS. To make that happen, we could use the same subscripting API as we used when slicing our above array of numbers, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TodoList</span> {
    <span class="s-keyword">var</span> topItems: <span class="s-type">ArraySlice</span>&lt;<span class="s-type">Item</span>&gt; {
        items[..&lt;<span class="s-number">3</span>]
    }
}</code></pre><p>However, while the above looks very elegant from a syntax point of view, it‚Äôs a quite dangerous implementation in this situation. Since we can‚Äôt know how many items that each <code>TodoList</code> will actually contain, our app might end up crashing when accessing the above property ‚Äî since just like when retrieving a single element from an array, range-based subscripting also causes a crash if used with out-of-bounds indexes.</p><p>While we <em>could</em> of course add our own bounds-checking to our implementation, we don‚Äôt have to ‚Äî since <code>Array</code> (and all other <code>Collection</code> implementations) has a <code>prefix</code> method that does just that:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TodoList</span> {
    <span class="s-keyword">var</span> topItems: <span class="s-type">ArraySlice</span>&lt;<span class="s-type">Item</span>&gt; {
        items.<span class="s-call">prefix</span>(<span class="s-number">3</span>)
    }
}</code></pre><p>Now our new API will work as expected, even if a <code>TodoList</code> contains less than 3 items, and our implementation still has <code>O(1)</code> <a href="https://www.swiftbysundell.com/basics/time-complexity">time complexity</a> ‚Äî which means that we can comfortably let it remain a computed property without the risk of causing <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift/%23accidental-bottlenecks">accidental bottlenecks</a>. Fantastic!</p><p>However, one thing that we have to keep in mind when working with slices is that they truly are a separate types compared to their original collections. That means that we can‚Äôt pass an <code>ArraySlice</code> instance to any API that accepts a standard <code>Array</code>, and vice versa ‚Äî without first performing an explicit conversion. That may at first seem like an unnecessary inconvenience, but it‚Äôs actually really important ‚Äî as it gives us complete control over when a slice should be separated (and its elements copied) from its original collection.</p><p>Let‚Äôs take a look at an example of doing just that, in which we‚Äôre using another <em>‚Äúflavor‚Äù</em> of the standard library‚Äôs <code>prefix</code> API (along with its <code>suffix</code> counterpart) to split a shipment of packages up into two separate shipments based on indexes. Since we don‚Äôt want our <code>Shipment</code> model to contain an <code>ArraySlice</code>, but rather a proper array of packages, we have to convert each of our two slices back into <code>Array&lt;Package&gt;</code> values ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Shipment {
    <span class="s-keyword">var</span> destination: <span class="s-type">Address</span>
    <span class="s-keyword">var</span> packages = [<span class="s-type">Package</span>]()
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">Shipment</span> {
    <span class="s-keyword">func</span> split() -&gt; (first: <span class="s-type">Shipment</span>, second: <span class="s-type">Shipment</span>) {
        <span class="s-keyword">guard</span> packages.<span class="s-property">count</span> &gt; <span class="s-number">1</span> <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> (<span class="s-keyword">self</span>, <span class="s-type">Shipment</span>(destination: destination))
        }

        <span class="s-keyword">let</span> splitIndex = packages.<span class="s-property">count</span> / <span class="s-number">2</span>

        <span class="s-keyword">return</span> (
            <span class="s-type">Shipment</span>(
                destination: destination,
                packages: <span class="s-type">Array</span>(packages.<span class="s-call">prefix</span>(upTo: splitIndex))
            ),
            <span class="s-type">Shipment</span>(
                destination: destination,
                packages: <span class="s-type">Array</span>(packages.<span class="s-call">suffix</span>(from: splitIndex))
            )
        )
    }
}</code></pre><p class="info">The above calls to <code>prefix</code> and <code>suffix</code> are equivalent to the range-based subscripts <code>packages[..&lt;splitIndex]</code> and <code>packages[splitIndex...]</code>, so which one we‚Äôll use is simply a matter of taste in this situation.</p><p>So far, we‚Äôve been computing our prefixes and suffixes based on element counts and indexes, but we can also use completely custom logic when doing so as well. For example, here we‚Äôre calling <code>prefix</code> with a custom closure to determine which of a game‚Äôs top players that have scored more than 100,000 points:</p><pre class="splash"><code><span class="s-keyword">let</span> qualifiedPlayers = topPlayers.<span class="s-call">prefix</span> { $0.<span class="s-property">score</span> &gt; <span class="s-number">100_000</span> }</code></pre><p><em>The above implementation assumes that the <code>topPlayers</code> array is in order according to each player‚Äôs score.</em></p><h2>Dropping elements</h2><p>An important aspect of both <code>prefix</code> and <code>suffix</code> is that neither of those APIs affect the original collection that they‚Äôre being called on, and instead return new instances for working with those subsets of elements. The same is also true for the <code>drop</code> family of APIs, with the only difference that they <em>subtract</em> a given prefix or suffix from a collection, rather than extracting it.</p><p>As an example, let‚Äôs say that we wanted to remove any numbers that appear at the beginning of a string, for example to prepare a string to be used as some form of normalized identifier. To do that, we could ask the string in question to drop all elements while the current element is a number ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">StringProtocol</span> {
    <span class="s-keyword">func</span> trimmingLeadingNumbers() -&gt; <span class="s-type">SubSequence</span> {
        <span class="s-call">drop</span>(while: { $0.<span class="s-property">isNumber</span> })
    }
}</code></pre><p class="info">Note how we extend <code>StringProtocol</code> above, and not <code>String</code> directly. That‚Äôs to enable our new API to be used on both standard strings, as well as the <code>Substring</code> type, which represents as slice of a <code>String</code>. To learn more about that, check out <a href="https://www.swiftbysundell.com/basics/strings">the Basics article about strings</a>.</p><p>As mentioned earlier, one of the major benefits of Swift‚Äôs slice-based collection APIs is that they can be composed without causing any unnecessary copying. That‚Äôs really beneficial in situations like the one below, in which we‚Äôre composing our above <code>trimmingLeadingNumbers</code> method with a call to <code>filter</code> in order to normalize a <code>username</code> value:</p><pre class="splash"><code><span class="s-keyword">func</span> normalizeUsername(<span class="s-keyword">_</span> username: <span class="s-type">String</span>) -&gt; <span class="s-type">String</span> {
    username.<span class="s-call">trimmingLeadingNumbers</span>().<span class="s-call">filter</span> {
        $0.<span class="s-property">isLetter</span> || $0.<span class="s-property">isNumber</span>
    }
}</code></pre><p>Using the above approach, we can construct increasingly complex value transformations simply by chaining a series of operations together ‚Äî all in a highly performant manner. Really cool.</p><p>Along those same lines, let‚Äôs take a look at how we could combine another <code>drop</code> variant ‚Äî <code>dropFirst</code> ‚Äî with <code>prefix</code> to easily add pagination support to any <code>BidirectionalCollection</code> (which includes types like <code>Array</code>, <code>Range</code>, and so on). By first calling <code>dropFirst</code> to remove all elements prior to where the current page begins, and then using <code>prefix</code> to extract a slice of the same size as our page size, we can implement our pagination extension like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">BidirectionalCollection</span> {
    <span class="s-keyword">func</span> page(withIndex pageIndex: <span class="s-type">Int</span>, size: <span class="s-type">Int</span>) -&gt; <span class="s-type">SubSequence</span> {
        <span class="s-call">dropFirst</span>(pageIndex * size).<span class="s-call">prefix</span>(size)
    }
}</code></pre><p>Going back to our <code>TodoList</code> type from before, we can then wrap the above API in a slightly more high-level abstraction, giving us a really nice pagination method that can be used to display any list of todo items in a page-by-page manner:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TodoList</span> {
    <span class="s-keyword">func</span> page(at index: <span class="s-type">Int</span>) -&gt; <span class="s-type">ArraySlice</span>&lt;<span class="s-type">Item</span>&gt; {
        items.<span class="s-call">page</span>(withIndex: index, size: <span class="s-number">25</span>)
    }
}</code></pre><p>At first, it might seem like a strange decision to return an <code>ArraySlice</code> from the above API, instead of converting the result into a proper <code>Array</code>. However, by doing so we‚Äôre following the same conventions as the standard library does ‚Äî enabling the call site to decide how and when to convert each slice, which in turn enables us to perform additional chaining without performance penalties.</p><h2>Splitting things up</h2><p>Finally, let‚Äôs take a look at a third variant of collection slicing ‚Äî <em>splitting</em>, which is a technique that‚Äôs incredibly commonly used when working with strings. Swift offers two main ways of splitting strings ‚Äî the <code>String</code> type‚Äôs own <code>split</code> method, as well as Foundation‚Äôs <code>components(separatedBy:)</code> API (which was inherited from Objective-C‚Äôs <code>NSString</code>):</p><pre class="splash"><code><span class="s-keyword">let</span> lines = text.<span class="s-call">components</span>(separatedBy: <span class="s-string">"\n"</span>)
<span class="s-keyword">let</span> lines = text.<span class="s-call">split</span>(separator: <span class="s-string">"\n"</span>)</code></pre><p>While the above two calls may seem like they‚Äôre doing the exact same thing, they‚Äôre actually quite different when we start looking at the details. For starters, the first variant accepts a <code>String</code> to use as a separator, while the second accepts a single <code>Character</code>. The first also returns an array of strings, compared to the second, which returns an array of <code>Substring</code> values ‚Äî which gives the second variant much better performance characteristics in scenarios that don‚Äôt require any copying.</p><p>Another important difference is that <code>split</code> gives us the option to limit the amount of splits that‚Äôll occur, which can help us boost performance in situations when we want to extract only a limited number of substrings from a much larger string. For example, here we‚Äôre extracting the first five lines from a large body of text, by combining <code>split</code> with <code>dropLast()</code> (in order to remove the last component, which represents the remainder of the text):</p><pre class="splash"><code><span class="s-keyword">let</span> firstLines = text.<span class="s-call">split</span>(
    separator: <span class="s-string">"\n"</span>,
    maxSplits: <span class="s-number">5</span>,
    omittingEmptySubsequences: <span class="s-keyword">true</span>
).<span class="s-call">dropLast</span>()</code></pre><p>What‚Äôs really cool about <code>split</code> is that it‚Äôs not just a <code>String</code> API ‚Äî just like <code>prefix</code>, <code>suffix</code> and the various <code>drop</code> methods we‚Äôve taken a look at so far, it can be used with any collection. For example, here‚Äôs how we could use it to split an array of analytics events up into sessions, based on when the app moved to and from the background:</p><pre class="splash"><code><span class="s-keyword">enum</span> Event: <span class="s-type">Equatable</span> {
    <span class="s-keyword">case</span> appEnteredForeground
    <span class="s-keyword">case</span> appEnteredBackground
    <span class="s-keyword">case</span> impression(contentID: <span class="s-type">ContentID</span>)
    <span class="s-keyword">case</span> interaction(contentID: <span class="s-type">ContentID</span>)
    ...
}

<span class="s-keyword">extension</span> <span class="s-type">Array</span> <span class="s-keyword">where</span> <span class="s-type">Element</span> == <span class="s-type">Event</span> {
    <span class="s-keyword">func</span> sessions() -&gt; [<span class="s-type">ArraySlice</span>&lt;<span class="s-type">Event</span>&gt;] {
        <span class="s-call">split</span>(omittingEmptySubsequences: <span class="s-keyword">true</span>) {
            $0 == .<span class="s-dotAccess">appEnteredForeground</span> ||
            $0 == .<span class="s-dotAccess">appEnteredBackground</span>
        }
    }
}</code></pre><p>The above is another example of when the Swift standard library‚Äôs protocol-oriented design really shines, as it gives us access to many different algorithms and pieces of functionality in a way that‚Äôs not directly tied to any concrete types. Not only can the APIs we‚Äôve taken a look at in this article be used with any built-in collection, they can also be used with <a href="https://www.swiftbysundell.com/articles/creating-custom-collections-in-swift/">custom ones</a> as well.</p><h2>Conclusion</h2><p>Swift‚Äôs focus on <em>‚Äúalgorithmic correctness‚Äù</em> is something that, at times, may seem like an over-optimization ‚Äî especially when dealing with smaller amounts of data typically found in simpler client/server-based iOS apps. However, this design does give Swift a lot more versatility, and can also often guide us to adopt better practices when it comes to how we handle our data.</p><p>By limiting the amount of implicit copying and memory allocation that occurs when working with collections, we ultimately gain more control over our core data structures ‚Äî which in turn can help us boost the overall performance of the apps that we build, even though it might require a few conversions here and there.</p><p>What do you think? Do you use collection slices when writing Swift code, or do you mostly consider them an implementation detail of the standard library? Let me know ‚Äî along with your questions, comments or feedback ‚Äî either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics</guid><title>Swift‚Äôs closure capturing mechanics</title><description>This week, let‚Äôs take a look at the various ways that Swift closures can capture the objects and values that they depend on, and how we can control those mechanics.</description><link>https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics</link><pubDate>Sun, 26 Jan 2020 19:00:00 +0100</pubDate><content:encoded><![CDATA[<p>Closures are an increasingly important part of Swift, both in terms of the overall direction of the language itself, and when it comes to the ways that both Apple and third party developers design libraries and APIs using it. However, closures also come with a certain set of complexities and behaviors that at first can be quite difficult to fully grasp ‚Äî especially when it comes to how they capture values and objects from their surrounding context in order to perform their work.</p><p>While we already took a look at various ways to capture objects within closures in 2017‚Äôs <em><a href="https://www.swiftbysundell.com/articles/capturing-objects-in-swift-closures">‚ÄúCapturing objects in Swift closures‚Äù</a></em>, this week‚Äôs, let‚Äôs explore the concept of capturing more broadly ‚Äî by taking a closer look at some of the opportunities and challenges that comes with writing capturing closures in general.</p><h2>Implicit capturing</h2><p>Whenever we‚Äôre defining an <em>escaping</em> closure ‚Äî that is, a closure that either gets stored in a property, or captured by another escaping closure ‚Äî it‚Äôll implicitly capture any objects, values and functions that are referenced within it. Since such closures may be executed at a later time, they need to maintain strong references to all of their dependencies in order to prevent them from being deallocated in the meantime.</p><p>For example, here we‚Äôre using <em><a href="https://www.swiftbysundell.com/basics/grand-central-dispatch">Grand Central Dispatch</a></em> to delay the presentation of a <code>UIAlertController</code> by three seconds, which requires the closure passed into the call to <code>asyncAfter</code> to capture the <code>presenter</code> view controller instance:</p><pre class="splash"><code><span class="s-keyword">func</span> presentDelayedConfirmation(in presenter: <span class="s-type">UIViewController</span>) {
    <span class="s-keyword">let</span> queue = <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>

    queue.<span class="s-call">asyncAfter</span>(deadline: .<span class="s-call">now</span>() + <span class="s-number">3</span>) {
        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"..."</span>,
            message: <span class="s-string">"..."</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )

        <span class="s-comment">// By simply refering to 'presenter' here, our closure
        // will automatically capture that instance, and retain
        // it until the closure itself gets released from memory:</span>
        presenter.<span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>While the above behavior is really convenient, it can also become the source of some really tricky bugs and memory-related issues if we‚Äôre not careful.</p><p>For example, since we‚Äôre delaying the execution of the above code by a few seconds, it‚Äôs possible for our <code>presenter</code> view controller to have been removed from our app‚Äôs view hierarchy by the time the closure actually gets run ‚Äî and while that wouldn‚Äôt be a catastrophe in this case, it would arguably be better for us to only present our confirmation if the view controller is still being retained by another object (presumably its parent view controller or window).</p><h2>Using capture lists</h2><p>This is where <em>capture lists</em> come in, which enable us to customize how a given closure captures any of the objects or values that it refers to. Using a capture list, we can instruct our above closure to capture the <code>presenter</code> view controller <em>weakly</em>, rather than <em>strongly</em> (which is the default). That way, the view controller will get deallocated if not referenced by any other part of our code base ‚Äî resulting in memory getting freed up quicker, and no unnecessary operations being performed:</p><pre class="splash"><code><span class="s-keyword">func</span> presentDelayedConfirmation(in presenter: <span class="s-type">UIViewController</span>) {
    <span class="s-keyword">let</span> queue = <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>

    <span class="s-comment">// A capture list is defined using a set of square brackets
    // directly following a closure's opening curly bracket:</span>
    queue.<span class="s-call">asyncAfter</span>(deadline: .<span class="s-call">now</span>() + <span class="s-number">3</span>) { [<span class="s-keyword">weak</span> presenter] <span class="s-keyword">in</span>
        <span class="s-comment">// Here we verify that our presenter is still in memory,
        // otherwise we can return early:</span>
        <span class="s-keyword">guard let</span> presenter = presenter <span class="s-keyword">else</span> { <span class="s-keyword">return</span> }

        <span class="s-keyword">let</span> alert = <span class="s-type">UIAlertController</span>(
            title: <span class="s-string">"..."</span>,
            message: <span class="s-string">"..."</span>,
            preferredStyle: .<span class="s-dotAccess">alert</span>
        )

        presenter.<span class="s-call">present</span>(alert, animated: <span class="s-keyword">true</span>)
    }
}</code></pre><p>Capture lists are perhaps even more useful when we need to reference <code>self</code>, especially when doing so would cause a <em>retain cycle</em>, which is when two objects or closures refer to each other ‚Äî preventing both of them from ever getting deallocated (since they can‚Äôt reach a reference count of zero).</p><p>Here‚Äôs an example of such a situation, in which we‚Äôre using a capture list to avoid referencing <code>self</code> strongly within a closure that will also be retained by <code>self</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> UserModelController {
    <span class="s-keyword">let</span> storage: <span class="s-type">UserStorage</span>
    <span class="s-keyword">private var</span> user: <span class="s-type">User</span> { <span class="s-keyword">didSet</span> { <span class="s-call">userDidChange</span>() } }

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, storage: <span class="s-type">UserStorage</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">storage</span> = storage
        <span class="s-keyword">self</span>.<span class="s-property">user</span> = user

        storage.<span class="s-call">addObserver</span>(forID: user.<span class="s-property">id</span>) { [<span class="s-keyword">weak self</span>] user <span class="s-keyword">in
            self</span>?.<span class="s-property">user</span> = user
        }
    }
}</code></pre><p class="info">Alternatively, we could‚Äôve converted the above <code>user</code> property into a function using its key path, like we did in <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/%23converting-to-functions">‚ÄúThe power of key paths in Swift‚Äù</a> ‚Äî since all that we‚Äôre doing inside of our observation closure is updating that property‚Äôs value.</p><p>The reason the above closure would end up causing a retain cycle if we didn‚Äôt capture <code>self</code> weakly is because <code>UserStorage</code> will retain that closure, and <code>self</code> already retains that object through its <code>storage</code> property.</p><h2>Weak references are not always the answer</h2><p>While the above two code samples might make it seem like always capturing <code>self</code> weakly is the way to go, that‚Äôs definitely not the case. Like with other kinds of memory management, we‚Äôll have to carefully consider how <code>self</code> will be used within each situation, and for how long we expect each capturing closure to remain in memory.</p><p>For example, if we‚Äôre dealing with really short-lived closures, such as ones passed to the <code>UIView.animate</code> API (which are just executed to perform interpolation for an animation, and then released), capturing <code>self</code> is really not a problem, and will most likely lead to code that‚Äôs easier to read:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ProductViewController</span> {
    <span class="s-keyword">func</span> expandImageView() {
        <span class="s-type">UIView</span>.<span class="s-call">animate</span>(withDuration: <span class="s-number">0.3</span>) {
            <span class="s-keyword">self</span>.<span class="s-property">imageView</span>.<span class="s-property">frame</span> = <span class="s-keyword">self</span>.<span class="s-property">view</span>.<span class="s-property">bounds</span>
            <span class="s-keyword">self</span>.<span class="s-call">showImageCloseButton</span>()
        }
    }
}</code></pre><p>Note how we always need to explicitly refer to <code>self</code> when accessing both instance methods and properties within an escaping closure. That‚Äôs a good thing, as it requires us to make an explicit decision to capture <code>self</code>, given the consequences that doing so might have.</p><p>There are also many kinds of situations in which we <em>might want</em> to retain <code>self</code> even for longer ‚Äî for example if the current object is required in order to perform a closure‚Äôs work, like in this case:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">NetworkingController</span> {
    <span class="s-keyword">func</span> makeImageUploadingTask(for image: <span class="s-type">Image</span>) -&gt; <span class="s-type">Task</span> {
        <span class="s-type">Task</span> { handler <span class="s-keyword">in
            let</span> request = <span class="s-type">Request</span>(
                endpoint: .<span class="s-dotAccess">imageUpload</span>,
                payload: image
            )

            <span class="s-comment">// The current NetworkingController is required here,
            // so for as long the returned task is retained,
            // we'll also retain its underlying controller:</span>
            <span class="s-keyword">self</span>.<span class="s-call">perform</span>(request, then: handler)
        }
    }
}</code></pre><p class="info">The above code won‚Äôt cause any retain cycles, since <code>NetworkingController</code> doesn‚Äôt retain the tasks that it creates. For more sophisticated ways of modeling and working with tasks in Swift, check out <a href="https://www.swiftbysundell.com/articles/task-based-concurrency-in-swift">‚ÄúTask-based concurrency in Swift‚Äù</a>.</p><p>We can also capture each of a closure‚Äôs dependencies directly, rather than referencing <code>self</code> ‚Äî again using a capture list. For example, here we‚Äôre capturing an image loader‚Äôs <code>cache</code> property in order to be able to use it once an image was successfully downloaded:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    <span class="s-keyword">private let</span> cache = <span class="s-type">Cache</span>&lt;<span class="s-type">URL</span>, <span class="s-type">Image</span>&gt;()

    <span class="s-keyword">func</span> loadImage(
        from url: <span class="s-type">URL</span>,
        then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Image</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>
    ) {
        <span class="s-comment">// Here we capture our image loader's cache without
        // capturing 'self', and without having to deal with
        // any optionals or weak references:</span>
        <span class="s-call">request</span>(url) { [cache] result <span class="s-keyword">in
            do</span> {
                <span class="s-keyword">let</span> image = <span class="s-keyword">try</span> result.<span class="s-call">decodedAsImage</span>()
                cache.<span class="s-call">insert</span>(image, forKey: url)
                <span class="s-call">handler</span>(.<span class="s-call">success</span>(image))
            } <span class="s-keyword">catch</span> {
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>The above technique works really well when we only need access to a few of our properties, rather than to <code>self</code> as a whole ‚Äî as long as those properties either contain reference types (class instances), or immutable value types.</p><h2>Capturing values</h2><p>Value types can sometimes be a bit more complex to deal with when it comes to closure capturing, since they‚Äôre passed to external scopes <a href="https://www.swiftbysundell.com/basics/value-and-reference-types">as copies, rather than as references</a>. Although that‚Äôs exactly what makes Swift‚Äôs value types so powerful, it can have somewhat unexpected consequences in situations like the one below ‚Äî in which we‚Äôre capturing a <code>sender</code> and <code>message</code> property when assigning a <code>handler</code> closure to a button:</p><pre class="splash"><code><span class="s-keyword">class</span> MessageComposerViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> sender: <span class="s-type">MessageSender</span>
    <span class="s-keyword">private var</span> message = <span class="s-type">Message</span>()
    <span class="s-keyword">private lazy var</span> sendButton = <span class="s-type">ActionButton</span>()
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        ...

        sendButton.<span class="s-property">handler</span> = { [sender, message] <span class="s-keyword">in</span>
            sender.<span class="s-call">send</span>(message)
        }
    }
}</code></pre><p>At first glance, the above code may seem perfectly fine. However, the <code>Message</code> type that we‚Äôre using above is implemented as a struct, which gives it <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">value semantics</a> ‚Äî meaning that we‚Äôre just capturing its <em>current value</em> when adding it to our capture list. So even though that value might change during our view controller‚Äôs lifecycle, once our <code>sendButton</code> is tapped, we‚Äôll still send our original value ‚Äî which isn‚Äôt great.</p><p>One way to solve the above problem, while still avoiding any additional <code>guard</code> statements, would be to only capture <code>self</code> to be able to access its <code>message</code> ‚Äî and then map that value directly to our sender‚Äôs <code>send</code> method, like this:</p><pre class="splash"><code>sendButton.<span class="s-property">handler</span> = { [<span class="s-keyword">weak self</span>, sender] <span class="s-keyword">in
    let</span> message = <span class="s-keyword">self</span>?.<span class="s-property">message</span>
    message.<span class="s-call">map</span>(sender.<span class="s-property">send</span>)
}</code></pre><p>However, the above is really only a problem when dealing with mutable values. If we instead only have constants, like in the following example, then we can add those properties to any closure‚Äôs capture list without any problems (as their values won‚Äôt change):</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> productManager: <span class="s-type">ProductManager</span>
    <span class="s-keyword">private let</span> product: <span class="s-type">Product</span>

    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        ...

        buyButton.<span class="s-property">handler</span> = { [productManager, product] <span class="s-keyword">in</span>
            productManager.<span class="s-call">startCheckout</span>(for: product)
        }
    }
}</code></pre><p class="info">In situations like the one above, we could also create a new function by combining our value (<code>product</code> in this case) with the method that it‚Äôll be passed into. Check out <a href="https://www.swiftbysundell.com/clips/1">the first episode of Swift Clips</a> for an example of doing just that.</p><p>Finally, let‚Äôs take a look at how values are captured when it comes to <em>local variables</em>. Contrary to how value-based properties are captured, local variables still maintain their connection to their original declaration when captured by a closure <em>within the same scope</em> ‚Äî which can be incredibly useful in order to keep track of various kinds of state.</p><p>For example, let‚Äôs say that we wanted to extend Swift‚Äôs <code>Collection</code> protocol with an API to enable us to iterate over any collection using a buffer consisting of the current element, as well as the next one. That could be done by combining the standard library‚Äôs <code>AnySequence</code> and <code>AnyIterator</code> types with locally captured values ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Collection</span> {
    <span class="s-keyword">typealias</span> Buffer = (current: <span class="s-type">Element</span>, next: <span class="s-type">Element</span>?)

    <span class="s-keyword">var</span> buffered: <span class="s-type">AnySequence</span>&lt;<span class="s-type">Buffer</span>&gt; {
        <span class="s-type">AnySequence</span> { () -&gt; <span class="s-type">AnyIterator</span>&lt;<span class="s-type">Buffer</span>&gt; <span class="s-keyword">in</span>
            <span class="s-comment">// We define our state as local variables:</span>
            <span class="s-keyword">var</span> iterator = <span class="s-keyword">self</span>.<span class="s-call">makeIterator</span>()
            <span class="s-keyword">var</span> next: <span class="s-type">Element</span>?

            <span class="s-keyword">return</span> <span class="s-type">AnyIterator</span> { () -&gt; <span class="s-type">Buffer</span>? <span class="s-keyword">in</span>
                <span class="s-comment">// We can then use our state to make decisions by
                // capturing them within our iterator's closure:</span>
                <span class="s-keyword">guard let</span> current = next ?? iterator.<span class="s-call">next</span>() <span class="s-keyword">else</span> {
                    <span class="s-keyword">return nil</span>
                }

                next = iterator.<span class="s-call">next</span>()
                <span class="s-keyword">return</span> (current, next)
            }
        }
    }
}</code></pre><p class="info">For more information about the above way of creating custom sequences, check out <a href="https://www.swiftbysundell.com/articles/wrapping-sequences-in-swift">‚ÄúWrapping sequences in Swift‚Äù</a>.</p><p>So values <em>copied</em> when captured using a capture list, while they‚Äôre <em>not copied</em> when referenced directly ‚Äî for example when accessed as properties, or when a local variable is captured within the same scope as it was defined in.</p><h2>Unowned references</h2><p>One final option when it comes to closure capturing is to use <code>unowned</code> references. These are, just like <code>weak</code> references, specified using capture lists ‚Äî and can also only be applied to reference types. Using <code>unowned</code> gives us essentially the same result as when using force-unwrapped optionals, in that it lets us treat a weak reference as if it was non-optional, but will result in a crash if we try to access it after it was deallocated.</p><p>Going back to our <code>UserModelController</code> example from before, here‚Äôs what it‚Äôd look like if we were to use <code>unowned</code> instead of <code>weak</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> UserModelController {
    ...

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, storage: <span class="s-type">UserStorage</span>) {
        ...

        storage.<span class="s-call">addObserver</span>(forID: user.<span class="s-property">id</span>) { [<span class="s-keyword">unowned self</span>] user <span class="s-keyword">in
            self</span>.<span class="s-property">user</span> = user
        }
    }
}</code></pre><p>While using <code>unowned</code> lets us get rid of optionals, and might occasionally be really convenient, the fact that it causes crashes for deallocated references makes it quite dangerous to use unless we‚Äôre absolutely certain that a given closure won‚Äôt accidentally be triggered after one of its dependencies has been deallocated.</p><p>One advantage of such crashes, however, is that they let us identify code paths that ideally should never have been entered. For example, if our above observation closure ends up getting triggered after <code>self</code> was deallocated, that probably means that we‚Äôre not unregistering our observations properly, which would be great to know.</p><p>However, rather than using <code>unowned</code>, we could (in this case) achieve the exact same thing using an <code>assert</code> ‚Äî and while doing so will result in a bit more code, it‚Äôll also give us a much more actionable error message in case of a failure, and we wouldn‚Äôt be causing any crashes in production:</p><pre class="splash"><code><span class="s-keyword">class</span> UserModelController {
    ...

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, storage: <span class="s-type">UserStorage</span>) {
        ...

        storage.<span class="s-call">addObserver</span>(forID: user.<span class="s-property">id</span>) { [<span class="s-keyword">weak self</span>] user <span class="s-keyword">in</span>
            <span class="s-call">assert</span>(<span class="s-keyword">self</span> != <span class="s-keyword">nil</span>, <span class="s-string">"""
            It seems like UserModelController didn't unregister \
            itself as a storage observer before being deallocated
            """</span>)

            <span class="s-keyword">self</span>?.<span class="s-property">user</span> = user
        }
    }
}</code></pre><p class="info">To learn more about <code>assert</code>, along with other ways of propagating various errors ‚Äî check out <a href="https://www.swiftbysundell.com/articles/picking-the-right-way-of-failing-in-swift">‚ÄúPicking the right way of failing in Swift‚Äù</a>.</p><h2>Conclusion</h2><p>Although Swift‚Äôs <em><a href="https://www.swiftbysundell.com/basics/memory-management">Automatic Reference Counting</a></em> memory management model doesn‚Äôt require us to manually allocate and deallocate memory, it still requires us to decide exactly how we want our various objects and values to be referenced.</p><p>While it‚Äôs common to hear over-simplified rules like <em>‚ÄúAlways use <code>weak</code> references within closures‚Äù</em>, writing well-performing and predictable apps and systems often requires a bit more nuanced thinking than that. Like with most things within the world of software development, the best approach tends to be to throughly learn the underlying mechanics and behaviors, and then choose how to apply them within each given situation.</p><p>Hopefully this article has provided a few insights into those mechanics and behaviors when it comes to closure capturing, and if you have any questions, comments or feedback ‚Äî just let me know, either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/result-type-convenience-apis</guid><title>Tip: Result‚Äôs convenience APIs</title><description></description><link>https://www.swiftbysundell.com/tips/result-type-convenience-apis</link><pubDate>Fri, 24 Jan 2020 17:30:00 +0100</pubDate><content:encoded><![CDATA[<p>The Swift standard library‚Äôs <code>Result</code> type might just be a simple enum with cases for modeling an operation‚Äôs <code>success</code> or <code>failure</code>, but it also comes with several really useful convenience APIs built-in.</p><p>For example, it has a closure-based initializer, which we can use to easily convert any expression that <code>throws</code> into a <code>Result</code> value:</p><pre class="splash"><code><span class="s-keyword">let</span> data: <span class="s-type">Data</span> = ...
<span class="s-keyword">let</span> decoder = <span class="s-type">JSONDecoder</span>()

<span class="s-comment">// This will create a Result&lt;Model, Error&gt; instance, which will contain
// 'success' if its expression succeeded, and 'failure' if it ended
// up throwing an error:</span>
<span class="s-keyword">let</span> result = <span class="s-type">Result</span> {
    <span class="s-keyword">try</span> decoder.<span class="s-call">decode</span>(<span class="s-type">Model</span>.<span class="s-keyword">self</span>, from: data)
}

<span class="s-comment">// The above API is really useful when we want to return a Result
// value from an asynchronous operation, for example by calling
// a completion handler:</span>
<span class="s-call">completionHandler</span>(result)</code></pre><p>Above we‚Äôre converting a raw <code>Data</code> value into a decoded <code>Result</code>, but we can also do the opposite ‚Äî and extract a <code>Data</code> value from a <code>Result</code> instance, which we‚Äôll then decode:</p><pre class="splash"><code><span class="s-keyword">func</span> decode(<span class="s-keyword">_</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt;) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Model</span> {
    <span class="s-comment">// Using Result's 'get' method, we can either extract its
    // underlying value, or throw any error that it contains:</span>
    <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> result.<span class="s-call">get</span>()
    <span class="s-keyword">let</span> decoder = <span class="s-type">JSONDecoder</span>()
    <span class="s-keyword">return try</span> decoder.<span class="s-call">decode</span>(<span class="s-type">Model</span>.<span class="s-keyword">self</span>, from: data)
}</code></pre><p>Finally, <code>Result</code> also ships with a series of really useful mapping functions, for example <code>map</code> ‚Äî which enables us to convert any result‚Äôs value into a new type, without having to do any error handling as part of such an operation:</p><pre class="splash"><code><span class="s-keyword">let</span> dataResult: <span class="s-type">Result</span>&lt;<span class="s-type">Data</span>, <span class="s-type">Error</span>&gt; = ...

<span class="s-keyword">let</span> stringResult = dataResult.<span class="s-call">map</span> {
    <span class="s-type">String</span>(decoding: $0, as: <span class="s-type">UTF8</span>.<span class="s-keyword">self</span>)
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/property-wrappers-in-swift</guid><title>Property wrappers in Swift</title><description>This week, let‚Äôs take a look at how Swift‚Äôs property wrappers work, and explore a few examples of situations in which they could be really useful.</description><link>https://www.swiftbysundell.com/articles/property-wrappers-in-swift</link><pubDate>Sun, 19 Jan 2020 22:20:00 +0100</pubDate><content:encoded><![CDATA[<p>When dealing with properties that represent some form of state, it‚Äôs very common to have some kind of associated logic that gets triggered every time that a value is modified. For example, we might validate each new value according to a set of rules, we might transform our assigned values in some way, or we might be notifying a set of observers whenever a value was changed.</p><p>In those kinds of situations, Swift 5.1‚Äôs <em>property wrappers</em> feature can be incredibly useful, as it enables us to attach such behaviors and logic directly to our properties themselves ‚Äî which often opens up new opportunities for code reuse and generalization. This week, let‚Äôs take a look at how property wrappers work, and explore a few examples of situations in which they could be used in practice.</p><h2>Transparently wrapping a value</h2><p>Like the name implies, a property wrapper is essentially a type that <em>wraps</em> a given value in order to attach additional logic to it ‚Äî and can be implemented using either a struct or a class by annotating it with the <code>@propertyWrapper</code> attribute. Besides that, the only real requirement is that each property wrapper type should contain a stored property called <code>wrappedValue</code>, which tells Swift which underlying value that‚Äôs being wrapped.</p><p>For example, let‚Äôs say that we wanted to create a property wrapper that automatically capitalizes all <code>String</code> values that were assigned to it. That might be implemented like this:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper struct</span> Capitalized {
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">String</span> {
        <span class="s-keyword">didSet</span> { wrappedValue = wrappedValue.<span class="s-property">capitalized</span> }
    }

    <span class="s-keyword">init</span>(wrappedValue: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">wrappedValue</span> = wrappedValue.<span class="s-property">capitalized</span>
    }
}</code></pre><p class="info">Note how we need to explicitly capitalize any string that was passed into our initializer, since <a href="https://www.swiftbysundell.com/articles/property-observers-in-swift">property observers</a> are only triggered after a value or object was fully initialized.</p><p>To apply our new property wrapper to any of our <code>String</code> properties, we simply have to annotate it with <code>@Capitalized</code> ‚Äî and Swift will automatically match that annotation to our above type. Here‚Äôs how we might do that to ensure that a <code>User</code> type‚Äôs <code>firstName</code> and <code>lastName</code> properties are always capitalized:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">@Capitalized var</span> firstName: <span class="s-type">String</span>
    <span class="s-keyword">@Capitalized var</span> lastName: <span class="s-type">String</span>
}</code></pre><p>The cool thing about property wrappers is that they act completely transparently, which means that we can still work with our above two properties as if they were normal strings ‚Äî both when initializing our <code>User</code> type, and when modifying its property values:</p><pre class="splash"><code><span class="s-comment">// John Appleseed</span>
<span class="s-keyword">var</span> user = <span class="s-type">User</span>(firstName: <span class="s-string">"john"</span>, lastName: <span class="s-string">"appleseed"</span>)

<span class="s-comment">// John Sundell</span>
user.<span class="s-property">lastName</span> = <span class="s-string">"sundell"</span></code></pre><p>Similarly, as long as a property wrapper defines an <code>init(wrappedValue:)</code> initializer (like our <code>Capitalized</code> type does) ‚Äî then we can even natively assign default values to our wrapped properties, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Document {
    <span class="s-keyword">@Capitalized var</span> name = <span class="s-string">"Untitled document"</span>
}</code></pre><p>So property wrappers enable us to transparently wrap and modify any stored property ‚Äî using a combination of an <code>@propertyWrapper</code>-marked type, and annotations matching the name of that type. But that‚Äôs just the beginning.</p><h2>A property‚Äôs properties</h2><p>Property wrappers can also have properties of their own, which enables further customization, and even makes it possible to inject dependencies into our wrapper types.</p><p>As an example, let‚Äôs say that we‚Äôre working on a messaging app that uses Foundation‚Äôs <code>UserDefaults</code> API to store various user settings and other pieces of lightweight data on disk. Doing so typically involves writing some form of mapping code for synchronizing each value with its underlying <code>UserDefaults</code> storage ‚Äî which often needs to be replicated for each piece of data that we‚Äôre looking to store.</p><p>However, by implementing that sort of logic within a generic property wrapper, we could make it easily reusable ‚Äî as doing so would let us simply attach our wrapper to any property that we‚Äôd like to be backed by <code>UserDefaults</code>. Here‚Äôs what such a wrapper might look like:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper struct</span> UserDefaultsBacked&lt;Value&gt; {
    <span class="s-keyword">let</span> key: <span class="s-type">String</span>
    <span class="s-keyword">var</span> storage: <span class="s-type">UserDefaults</span> = .<span class="s-dotAccess">standard</span>

    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span>? {
        <span class="s-keyword">get</span> { storage.<span class="s-call">value</span>(forKey: key) <span class="s-keyword">as</span>? <span class="s-type">Value</span> }
        <span class="s-keyword">set</span> { storage.<span class="s-call">setValue</span>(newValue, forKey: key) }
    }
}</code></pre><p>Just like any other struct, our above <code>UserDefaultsBacked</code> type will automatically get a <a href="https://www.swiftbysundell.com/tips/improved-memberwise-initializers-in-swift-5-1">memberwise initializer</a> with default arguments for all properties that have a default value ‚Äî which means that we‚Äôll be able to initialize instances of it by simply specifying which <code>UserDefaults</code> key that we want each property to be backed by:</p><pre class="splash"><code><span class="s-keyword">struct</span> SettingsViewModel {
    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"mark-as-read"</span>)
    <span class="s-keyword">var</span> autoMarkMessagesAsRead: <span class="s-type">Bool</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"search-page-size"</span>)
    <span class="s-keyword">var</span> numberOfSearchResultsPerPage: <span class="s-type">Int</span>
}</code></pre><p class="info">The compiler will automatically infer which type to specialize our generic <code>UserDefaultsBacked</code> wrapper with, based on the type of the property that it‚Äôs wrapping.</p><p>The above setup makes our new property wrapper easy to use whenever we want a property to be backed by <code>UserDefaults.standard</code>, but since we parameterized that dependency, we could also choose to use a custom instance if we‚Äôd like ‚Äî for example to facilitate testing, or to be able to share values between multiple apps within the same app group:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UserDefaults</span> {
    <span class="s-keyword">static var</span> shared: <span class="s-type">UserDefaults</span> {
        <span class="s-keyword">let</span> combined = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>
        combined.<span class="s-call">addSuite</span>(named: <span class="s-string">"group.johnsundell.app"</span>)
        <span class="s-keyword">return</span> combined
    }
}

<span class="s-keyword">struct</span> SettingsViewModel {
    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"mark-as-read"</span>, defaults: .<span class="s-dotAccess">shared</span>)
    <span class="s-keyword">var</span> autoMarkMessagesAsRead: <span class="s-type">Bool</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"search-page-size"</span>, defaults: .<span class="s-dotAccess">shared</span>)
    <span class="s-keyword">var</span> numberOfSearchResultsPerPage: <span class="s-type">Int</span>
}</code></pre><p class="info">For more information about using <code>UserDefaults</code> to share data between multiple apps, check out <a href="https://www.swiftbysundell.com/articles/the-power-of-userdefaults-in-swift">‚ÄúThe power of UserDefaults in Swift‚Äù</a>.</p><p>However, our above implementation has a quite significant flaw. Even though both of our above two properties are declared as non-optional, their actual values will still be optionals, since our <code>UserDefaultsBacked</code> type specifies <code>Value?</code> as its <code>wrappedValue</code> property‚Äôs type.</p><p>Thankfully, that flaw can be quite easily fixed. All we have to do is to add a <code>defaultValue</code> property to our wrapper, which we‚Äôll then use whenever our underlying <code>UserDefaults</code> storage didn‚Äôt contain a value for our property‚Äôs key:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper struct</span> UserDefaultsBacked&lt;Value&gt; {
    <span class="s-keyword">let</span> key: <span class="s-type">String</span>
    <span class="s-keyword">let</span> defaultValue: <span class="s-type">Value</span>
    <span class="s-keyword">var</span> storage: <span class="s-type">UserDefaults</span> = .<span class="s-dotAccess">standard</span>

    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span> {
        <span class="s-keyword">get</span> {
            <span class="s-keyword">let</span> value = storage.<span class="s-call">value</span>(forKey: key) <span class="s-keyword">as</span>? <span class="s-type">Value</span>
            <span class="s-keyword">return</span> value ?? defaultValue
        }
        <span class="s-keyword">set</span> {
            storage.<span class="s-call">setValue</span>(newValue, forKey: key)
        }
    }
}</code></pre><p>With the above in place, we‚Äôre now able to turn both of our properties into non-optionals, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> SettingsViewModel {
    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"mark-as-read"</span>, defaultValue: <span class="s-keyword">true</span>)
    <span class="s-keyword">var</span> autoMarkMessagesAsRead: <span class="s-type">Bool</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"search-page-size"</span>, defaultValue: <span class="s-number">20</span>)
    <span class="s-keyword">var</span> numberOfSearchResultsPerPage: <span class="s-type">Int</span>
}</code></pre><p>That‚Äôs really nice. However, some of our <code>UserDefaults</code> values are likely to <em>actually be optionals</em>, and it would be unfortunate if we had to constantly specify <code>nil</code> as the default value for those properties ‚Äî as that‚Äôs not something that we have to do when <em>not</em> using property wrappers.</p><p>To address that, let‚Äôs also add a convenience API to our wrapper for whenever its <code>Value</code> type conforms to <code>ExpressibleByNilLiteral</code> (which <code>Optional</code> does) ‚Äî in which we‚Äôll automatically insert <code>nil</code> as the default value:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UserDefaultsBacked</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">ExpressibleByNilLiteral</span> {
    <span class="s-keyword">init</span>(key: <span class="s-type">String</span>, storage: <span class="s-type">UserDefaults</span> = .<span class="s-dotAccess">standard</span>) {
        <span class="s-keyword">self</span>.<span class="s-keyword">init</span>(key: key, defaultValue: <span class="s-keyword">nil</span>, storage: storage)
    }
}</code></pre><p>With the above change in place, we can now freely use our <code>UserDefaultsBacked</code> wrapper with both optional and non-optional values with ease:</p><pre class="splash"><code><span class="s-keyword">struct</span> SettingsViewModel {
    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"mark-as-read"</span>, defaultValue: <span class="s-keyword">true</span>)
    <span class="s-keyword">var</span> autoMarkMessagesAsRead: <span class="s-type">Bool</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"search-page-size"</span>, defaultValue: <span class="s-number">20</span>)
    <span class="s-keyword">var</span> numberOfSearchResultsPerPage: <span class="s-type">Int</span>

    <span class="s-keyword">@UserDefaultsBacked</span>(key: <span class="s-string">"signature"</span>)
    <span class="s-keyword">var</span> messageSignature: <span class="s-type">String</span>?
}</code></pre><p>However, there is one more thing that we‚Äôll need to take into account, since we‚Äôll now be able to assign <code>nil</code> to a <code>UserDefaultsBacked</code> property. To avoid crashes in such situations, we‚Äôll have to update our property wrapper to first check if any assigned value is <code>nil</code> before proceeding to store it within the current <code>UserDefaults</code> instance, like this:</p><pre class="splash"><code><span class="s-comment">// Since our property wrapper's Value type isn't optional, but
// can still contain nil values, we'll have to introduce this
// protocol to enable us to cast any assigned value into a type
// that we can compare against nil:</span>
<span class="s-keyword">private protocol</span> AnyOptional {
    <span class="s-keyword">var</span> isNil: <span class="s-type">Bool</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">extension</span> <span class="s-type">Optional</span>: <span class="s-type">AnyOptional</span> {
    <span class="s-keyword">var</span> isNil: <span class="s-type">Bool</span> { <span class="s-keyword">self</span> == <span class="s-keyword">nil</span> }
}

<span class="s-keyword">@propertyWrapper struct</span> UserDefaultsBacked&lt;Value&gt; {
    ...

    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span> {
        <span class="s-keyword">get</span> { ... }
        <span class="s-keyword">set</span> {
            <span class="s-keyword">if let</span> optional = newValue <span class="s-keyword">as</span>? <span class="s-type">AnyOptional</span>, optional.<span class="s-property">isNil</span> {
                storage.<span class="s-call">removeObject</span>(forKey: key)
            } <span class="s-keyword">else</span> {
                storage.<span class="s-call">setValue</span>(newValue, forKey: key)
            }
        }
    }
}</code></pre><p>The fact that property wrappers are implemented as actual types gives us a lot of power ‚Äî as we can give them properties, initializers, and even extensions ‚Äî which in turn enables us to both make our call sites really neat and clean, and to make full use of Swift‚Äôs robust type system.</p><h2>Decoding and overriding</h2><p>Although most property wrappers are likely going to be implemented as structs in order to <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">utilize value semantics</a>, sometimes we might want to opt for <a href="https://www.swiftbysundell.com/basics/value-and-reference-types">reference semantics</a> by using a class instead.</p><p>For example, let‚Äôs say that we‚Äôre working on a project that uses <a href="https://www.swiftbysundell.com/articles/feature-flags-in-swift">feature flags</a> to enable testing and gradual rollouts of new features and experiments, and that we want to build a property wrapper that‚Äôll let us specify such flags in different ways. Since we‚Äôll want to share those values across our code base, we‚Äôll implement that wrapper as a class:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper final class</span> Flag&lt;Value&gt; {
    <span class="s-keyword">let</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> wrappedValue: <span class="s-type">Value</span>

    <span class="s-keyword">fileprivate init</span>(name: <span class="s-type">String</span>, defaultValue: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">name</span> = name
        <span class="s-keyword">self</span>.<span class="s-property">wrappedValue</span> = defaultValue
    }
}</code></pre><p>With our new wrapper type in place, we can now start defining our flags as properties within an encapsulating <code>FeatureFlags</code> type ‚Äî which‚Äôll act as a single source of truth for all of our app‚Äôs feature flags:</p><pre class="splash"><code><span class="s-keyword">struct</span> FeatureFlags {
    <span class="s-keyword">@Flag</span>(name: <span class="s-string">"feature-search"</span>, defaultValue: <span class="s-keyword">false</span>)
    <span class="s-keyword">var</span> isSearchEnabled: <span class="s-type">Bool</span>

    <span class="s-keyword">@Flag</span>(name: <span class="s-string">"experiment-note-limit"</span>, defaultValue: <span class="s-number">999</span>)
    <span class="s-keyword">var</span> maximumNumberOfNotes: <span class="s-type">Int</span>
}</code></pre><p>At this point, the above <code>Flag</code> property wrapper might seem a bit redundant, given that it doesn‚Äôt actually do anything other than store its <code>wrappedValue</code> ‚Äî but that‚Äôs about to change.</p><p>A very common way to use feature flags is to download their values over the network, for example every time that the app launches, or according to a certain time interval. However, even when using <a href="https://www.swiftbysundell.com/basics/codable">Codable</a>, there‚Äôs typically a fair amount of boilerplate involved in making that happen ‚Äî given that we‚Äôll most likely want to fall back to our app‚Äôs default values for flags that may not have been added to our backend yet (or those that have been removed after a test or rollout was completed).</p><p>So let‚Äôs use our <code>Flag</code> property wrapper to implement that form of decoding. Since we want to use each flag‚Äôs <code>name</code> as its coding key, the first thing we‚Äôll do is to define a new <code>CodingKey</code> type that‚Äôll let us do just that:</p><pre class="splash"><code><span class="s-keyword">private struct</span> FlagCodingKey: <span class="s-type">CodingKey</span> {
    <span class="s-keyword">var</span> stringValue: <span class="s-type">String</span>
    <span class="s-keyword">var</span> intValue: <span class="s-type">Int</span>?

    <span class="s-keyword">init</span>(name: <span class="s-type">String</span>) {
        stringValue = name
    }
    
    <span class="s-comment">// These initializers are required by the CodingKey protocol:</span>

    <span class="s-keyword">init</span>?(stringValue: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">stringValue</span> = stringValue
    }

    <span class="s-keyword">init</span>?(intValue: <span class="s-type">Int</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">intValue</span> = intValue
        <span class="s-keyword">self</span>.<span class="s-property">stringValue</span> = <span class="s-type">String</span>(intValue)
    }
}</code></pre><p>Next, we‚Äôre going to need a way to reference each of our flags without knowing their generic type ‚Äî but rather than resorting to <a href="https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift">full type erasure</a>, we‚Äôre going to add a protocol called <code>DecodableFlag</code>, which‚Äôll enable each flag to decode its own value according to its <code>Value</code> type:</p><pre class="splash"><code><span class="s-keyword">private protocol</span> DecodableFlag {
    <span class="s-keyword">typealias</span> Container = <span class="s-type">KeyedDecodingContainer</span>&lt;<span class="s-type">FlagCodingKey</span>&gt;
    <span class="s-keyword">func</span> decodeValue(from container: <span class="s-type">Container</span>) <span class="s-keyword">throws</span>
}</code></pre><p>Besides enabling our server to fully control our app‚Äôs feature flags, it would also be really useful to be able to add local overrides for individual flags as well. That way we could specify exactly which values to use when writing <a href="https://www.swiftbysundell.com/articles/getting-started-with-xcode-ui-testing-in-swift">UI tests</a>, and easily enable a new feature while working on it. So let‚Äôs also add that capability to our <code>Flag</code> wrapper, which we‚Äôll do by once again using <code>UserDefaults</code> (which has the somewhat hidden feature of being able to <a href="https://www.swiftbysundell.com/tips/parsing-command-line-arguments-using-userdefaults">parse command line arguments</a>), giving us a decoding implementation that looks like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Flag</span>: <span class="s-type">DecodableFlag</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">fileprivate func</span> decodeValue(from container: <span class="s-type">Container</span>) <span class="s-keyword">throws</span> {
        <span class="s-comment">// This enables us to pass an override using a command line
        // argument matching the flag's name:</span>
        <span class="s-keyword">if let</span> value = <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>.<span class="s-call">value</span>(forKey: name) {
            <span class="s-keyword">if let</span> matchingValue = value <span class="s-keyword">as</span>? <span class="s-type">Value</span> {
                wrappedValue = matchingValue
                <span class="s-keyword">return</span>
            }
        }

        <span class="s-keyword">let</span> key = <span class="s-type">FlagCodingKey</span>(name: name)

        <span class="s-comment">// We only want to attempt to decode a value if it's present,
        // to enable our app to fall back to its default value
        // in case the flag is missing from our backend data:</span>
        <span class="s-keyword">if let</span> value = <span class="s-keyword">try</span> container.<span class="s-call">decodeIfPresent</span>(<span class="s-type">Value</span>.<span class="s-keyword">self</span>, forKey: key) {
            wrappedValue = value
        }
    }
}</code></pre><p class="info">For more information about using command line arguments to implement debugging utilities, check out <a href="https://www.swiftbysundell.com/articles/launch-arguments-in-swift">‚ÄúLaunch arguments in Swift‚Äù</a>.</p><p>Finally, let‚Äôs complete our decoding implementation by making <code>FeatureFlags</code> conform to <code>Decodable</code>. Here we‚Äôll use <a href="https://www.swiftbysundell.com/articles/reflection-in-swift">reflection</a> to dynamically iterate over each of our flag properties, and we‚Äôll then ask each flag to attempt to decode its value using the current decoding container, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">FeatureFlags</span>: <span class="s-type">Decodable</span> {
    <span class="s-keyword">init</span>(from decoder: <span class="s-type">Decoder</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> container = <span class="s-keyword">try</span> decoder.<span class="s-call">container</span>(keyedBy: <span class="s-type">FlagCodingKey</span>.<span class="s-keyword">self</span>)

        <span class="s-keyword">for</span> child <span class="s-keyword">in</span> <span class="s-type">Mirror</span>(reflecting: <span class="s-keyword">self</span>).<span class="s-property">children</span> {
            <span class="s-keyword">guard let</span> flag = child.<span class="s-property">value</span> <span class="s-keyword">as</span>? <span class="s-type">DecodableFlag</span> <span class="s-keyword">else</span> {
                <span class="s-keyword">continue</span>
            }

            <span class="s-keyword">try</span> flag.<span class="s-call">decodeValue</span>(from: container)
        }
    }
}</code></pre><p>While we did have to implement a bit of underlying infrastructure, we now have a very flexible feature flag system in place ‚Äî with the ability to specify flag values both server- and client side, support for overriding flags via command line arguments, and for new flags to be defined simply by adding a <code>@Flag</code>-annotated property to our <code>FeatureFlags</code> type.</p><h2>Projected values</h2><p>As we‚Äôve explored so far in this article, one of the major benefits of property wrappers is that they enable us to add logic and behaviors to properties in a way that doesn‚Äôt impact our call sites at all ‚Äî as values are read and written the exact same way regardless of whether a property is wrapped or not.</p><p>However, sometimes we might actually want to access a property wrapper itself, rather than the value that it‚Äôs wrapping. That‚Äôs especially common when building UIs using Apple‚Äôs new <a href="https://www.swiftbysundell.com/basics/swiftui">SwiftUI</a> framework, which makes <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/%23property-wrappers">heavy use of property wrappers</a> to implement its various data binding APIs.</p><p>For example, here we‚Äôre building a <code>QuantityView</code> that enables some form of quantity to be specified using a <code>Stepper</code> view. In order to bind that piece of state to our view, we‚Äôve annotated it with <code>@State</code>, and we‚Äôre then giving our stepper direct access to that wrapped state (rather than just its current <code>Int</code> value) by passing it prefixed with <code>$</code> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> QuantityView: <span class="s-type">View</span> {
    ...
    <span class="s-keyword">@State private var</span> quantity = <span class="s-number">1</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-comment">// Passing a wrapped property prefixd with "$" passes
        // the property wrapper itself, rather than its value:</span>
        <span class="s-type">Stepper</span>(<span class="s-string">"Quantity:</span> \(quantity)<span class="s-string">"</span>,
            value: $quantity,
            in: <span class="s-number">1</span>...<span class="s-number">99</span>
        )
    }
}</code></pre><p>The above feature might seem like something that was tailor-made for SwiftUI, but it‚Äôs actually a capability that can be added to any property wrapper, for example our <code>Flag</code> type from before. That <em>‚Äúdollar-prefixed‚Äù</em> version of our above property is known as its wrapper‚Äôs <em>projected value</em>, and is implemented by adding a <code>projectedValue</code> property to any wrapper type:</p><pre class="splash"><code><span class="s-keyword">@propertyWrapper final class</span> Flag&lt;Value&gt; {
    <span class="s-keyword">var</span> projectedValue: <span class="s-type">Flag</span> { <span class="s-keyword">self</span> }
    ...
}</code></pre><p>Just like that, any <code>Flag</code>-annotated property can now also be passed as a projected value ‚Äî that is, as a reference to its wrapper itself. Again, that‚Äôs not something that‚Äôs coupled with SwiftUI, in fact we could adopt the same sort of pattern when using UIKit as well ‚Äî for example by having a <code>UIViewController</code> accept an instance of <code>Flag</code> when initialized.</p><p>Here‚Äôs an example of how we might do just that to implement a view controller that‚Äôll let us toggle a given <code>Bool</code>-based feature flag on or off when using a debug build of our app:</p><pre class="splash"><code><span class="s-keyword">class</span> FlagToggleViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> flag: <span class="s-type">Flag</span>&lt;<span class="s-type">Bool</span>&gt;
    <span class="s-keyword">private lazy var</span> label = <span class="s-type">UILabel</span>()
    <span class="s-keyword">private lazy var</span> toggle = <span class="s-type">UISwitch</span>()

    <span class="s-keyword">init</span>(flag: <span class="s-type">Flag</span>&lt;<span class="s-type">Bool</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">flag</span> = flag
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        label.<span class="s-property">text</span> = flag.<span class="s-property">name</span>
        toggle.<span class="s-property">isOn</span> = flag.<span class="s-property">wrappedValue</span>

        toggle.<span class="s-call">addTarget</span>(<span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(toggleFlag),
            for: .<span class="s-dotAccess">valueChanged</span>
        )
        
        ...
    }

    <span class="s-keyword">@objc private func</span> toggleFlag() {
        flag.<span class="s-property">wrappedValue</span> = toggle.<span class="s-property">isOn</span>
    }
}</code></pre><p>To initialize the above view controller, we‚Äôll use the same <code>$</code>-prefix-based syntax as when passing an <code>@State</code> reference when using SwiftUI:</p><pre class="splash"><code><span class="s-keyword">let</span> flags: <span class="s-type">FeatureFlags</span> = ...

<span class="s-keyword">let</span> searchToggleVC = <span class="s-type">FlagToggleViewController</span>(
    flag: flags.<span class="s-property">$isSearchEnabled</span>
)</code></pre><p>We‚Äôll definitely explore the above use of property wrappers more in upcoming articles ‚Äî as it could enable us to make our code more declarative, to implement property-based observation APIs, to perform quite sophisticated data binding, and much more.</p><h2>Conclusion</h2><p>Property wrappers is definitely one of the most exciting new features in Swift 5.1 ‚Äî as it opens up a lot of doors for code reuse and customizability, and enables powerful new ways to implement property-level functionality. Even outside of declarative frameworks like SwiftUI, there‚Äôs a ton of potential use cases for property wrappers, many of which won‚Äôt require us to make any big changes to our overall code ‚Äî as property wrappers mostly operate completely transparently.</p><p>However, that transparency can be both an advantage and a liability. On one hand, it enables us to access and assign wrapped properties the exact same way as unwrapped ones ‚Äî but on the other hand, the risk is that we‚Äôll end up hiding too much functionality behind what might be a quite non-obvious abstraction.</p><p>What do you think? Have you started adopting property wrappers, or do you have a use case that you think they‚Äôd be a great fit for? Let me know ‚Äî along with your comments, questions and feedback ‚Äî either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/test-assertions-in-swift</guid><title>Test assertions in Swift</title><description>This week, let‚Äôs take a look at various ways that we can assert that our code produces the right outcomes within our unit tests, including how we can create our own assertion functions.</description><link>https://www.swiftbysundell.com/articles/test-assertions-in-swift</link><pubDate>Sun, 12 Jan 2020 22:00:00 +0100</pubDate><content:encoded><![CDATA[<p>Most <a href="https://www.swiftbysundell.com/basics/unit-testing">unit tests</a> written using Apple‚Äôs built-in <code>XCTest</code> framework tend to follow a pattern made up of three steps: first, we set up the values and objects that we wish to test, we then perform a set of actions that trigger the functionality that we‚Äôre looking to verify, and finally we <em>assert</em> that the correct outcome was produced.</p><p>That may seem like a very simple structure, at least on the surface level, but just like when building any other kind of software, there‚Äôs a nearly infinite number of ways that we can approach each of those three steps when writing tests.</p><p>This week, let‚Äôs take a closer look at the last of those steps ‚Äî asserting that our code produces the right outcome ‚Äî by both exploring the <code>XCTAssert</code> family of functions that <code>XCTest</code> ships with, and also how we can construct our very own test assertions as well.</p><h2>Picking the right assertion</h2><p>A test assertion‚Äôs main role is to compare a certain result against a control value, and to fail the current test if those two values don‚Äôt match. The assertions that ship as part of the built-in <code>XCTest</code> framework all have the prefix <code>XCTAssert</code>, the most basic of which simply compares any boolean value against <code>true</code>:</p><pre class="splash"><code><span class="s-comment">// Without a custom message:</span>
<span class="s-call">XCTAssert</span>(aBoolValue)

<span class="s-comment">// With a custom message that will be displayed in case of a failure:</span>
<span class="s-call">XCTAssert</span>(aBoolValue, <span class="s-string">"An unexpected result was encountered"</span>)</code></pre><p>However, when it comes to most standard forms of verification, we rarely have to call <code>XCTAssert</code> directly ‚Äî instead, there are a number of more specific versions of that function that we can use for different kinds of values.</p><p>For example, let‚Äôs say that we want to verify that a <code>ContentCollection</code> type correctly returns the right <code>Item</code> when queried using a specific item ID. To perform our assertion in this case, we‚Äôll use <code>XCTAssertEqual</code>, which lets us verify that the returned item is equal to the one we were expecting ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ContentCollectionTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testQueryingItemByID() {
        <span class="s-keyword">var</span> collection = <span class="s-type">ContentCollection</span>()

        <span class="s-keyword">let</span> item = <span class="s-type">Item</span>(id: <span class="s-string">"an-item"</span>, title: <span class="s-string">"A title"</span>)
        collection.<span class="s-call">add</span>(item)

        <span class="s-keyword">let</span> retrievedItem = collection.<span class="s-call">item</span>(withID: <span class="s-string">"an-item"</span>)
        <span class="s-call">XCTAssertEqual</span>(retrievedItem, item)
    }
}</code></pre><p>While <code>XCTAssertEqual</code> is great in situations when we want to verify our code‚Äôs outcome against a very specific value, sometimes we might need keep our verification slightly less granular. For example, below we‚Äôre verifying that a <code>Cache</code> assigns an expiration date to an item when inserted ‚Äî and we‚Äôre not really interested in verifying the <em>exact date</em> (since that‚Äôs an implementation detail of our cache itself), but rather just that <em>any date</em> was assigned, which can be done using <code>XCTAssertNil</code> and <code>XCTAssertNotNil</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> CacheTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testExpirationDateAssignedToInsertedItem() {
        <span class="s-keyword">let</span> cache = <span class="s-type">Cache</span>()
        <span class="s-keyword">let</span> item = <span class="s-type">Item</span>(id: <span class="s-string">"an-item"</span>, title: <span class="s-string">"A title"</span>)

        <span class="s-comment">// It's often a good idea to verify that our initial state
        // is correct as well, especially when dealing with code
        // that includes some form of persistence:</span>
        <span class="s-call">XCTAssertNil</span>(cache.<span class="s-call">expirationDate</span>(for: item))

        cache.<span class="s-call">insert</span>(item)
        <span class="s-call">XCTAssertNotNil</span>(cache.<span class="s-call">expirationDate</span>(for: item))
    }
}</code></pre><p>When picking which assertion function to use within each situation, it‚Äôs arguably just as important to consider how each potential option will behave <em>when failing</em> as it is to match it against the type of input that we‚Äôll be passing into it.</p><p>As an example, let‚Äôs say that we wanted to verify that a <code>NoteManager</code> class successfully removed all of its notes when asked to do so. We‚Äôll do that by verifying that our manager‚Äôs <code>allNotes</code> array is empty ‚Äî which might make <code>XCTAssertTrue</code> seem like a perfect fit, as we can simply pass <code>allNotes.isEmpty</code> into it:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManagerTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testRemovingMultipleNotes() {
        <span class="s-keyword">let</span> manager = <span class="s-type">NoteManager</span>()

        <span class="s-keyword">let</span> notes = (<span class="s-number">0</span>..&lt;<span class="s-number">3</span>).<span class="s-call">map</span> { <span class="s-type">Note</span>(id: <span class="s-string">"</span>\($0)<span class="s-string">"</span>) }
        notes.<span class="s-call">forEach</span>(manager.<span class="s-property">add</span>)
        <span class="s-call">XCTAssertEqual</span>(manager.<span class="s-property">allNotes</span>.<span class="s-property">count</span>, <span class="s-number">3</span>)

        manager.<span class="s-call">remove</span>(notes)
        <span class="s-call">XCTAssertTrue</span>(manager.<span class="s-property">allNotes</span>.<span class="s-property">isEmpty</span>)
    }
}</code></pre><p>While the above will definitely work, the error message that we‚Äôll get in case of a failure will simply be <em>‚ÄúXCTAssertTrue failed‚Äù</em>, which doesn‚Äôt give us much of an indication as to what actually went wrong. If we instead could see the exact <code>Note</code> values that incorrectly remained within our <code>NoteManager</code> after our <code>remove()</code> call, that‚Äôd most likely make it much easier to debug such a failure.</p><p>To make that happen, let‚Äôs instead use <code>XCTAssertEqual</code> again, and simply compare our <code>allNotes</code> array with an empty one ‚Äî which will show us exactly which notes that weren‚Äôt removed in case of a failure, since <code>XCTAssertEqual</code> always includes both of the values that it compared in any error message that it‚Äôll generate:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManagerTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testRemovingMultipleNotes() {
        ...
        manager.<span class="s-call">remove</span>(notes)
        <span class="s-call">XCTAssertEqual</span>(manager.<span class="s-property">allNotes</span>, [])
    }
}</code></pre><p>It‚Äôs of course quite difficult to predict what sort of information that we <em>might</em> want to get access to in order to debug future failures before they‚Äôve even happened ‚Äî but in general, the richer debugging information that we can provide our future selves when writing tests, the easier those tests tend to be to maintain and work with in the long run.</p><h2>Custom assertion functions</h2><p>While the default suite of <code>XCTAssert</code> functions definitely cover the most common use cases, there are situations in which we might want to extend that suite with a more specialized, custom assertion function that we‚Äôve written ourselves.</p><p>An example of such a situation might be if our tests require us to verify slightly larger collections of data. Let‚Äôs say that our <code>NoteManager</code> from before also includes a pagination feature, which divides all added notes up into groups containing 25 elements each. To test that feature, we‚Äôre adding 50 notes to our manager, and we‚Äôre then asserting that each page contains the right subset of those added notes ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManagerTests: <span class="s-type">XCTestCase</span> {
    ...
    
    <span class="s-keyword">func</span> testPagination() {
        <span class="s-keyword">let</span> manager = <span class="s-type">NoteManager</span>()

        <span class="s-keyword">let</span> notes = (<span class="s-number">0</span>..&lt;<span class="s-number">50</span>).<span class="s-call">map</span> { <span class="s-type">Note</span>(id: <span class="s-string">"</span>\($0)<span class="s-string">"</span>) }
        notes.<span class="s-call">forEach</span>(manager.<span class="s-property">add</span>)
        <span class="s-call">XCTAssertEqual</span>(manager.<span class="s-property">allNotes</span>.<span class="s-property">count</span>, <span class="s-number">50</span>)

        <span class="s-call">XCTAssertEqual</span>(
            manager.<span class="s-call">notesOnPage</span>(<span class="s-number">0</span>),
            <span class="s-type">Array</span>(notes[..&lt;<span class="s-number">25</span>])
        )

        <span class="s-call">XCTAssertEqual</span>(
            manager.<span class="s-call">notesOnPage</span>(<span class="s-number">1</span>),
            <span class="s-type">Array</span>(notes[<span class="s-number">25</span>...])
        )

        <span class="s-call">XCTAssertEqual</span>(manager.<span class="s-call">notesOnPage</span>(<span class="s-number">2</span>), [])
    }
}</code></pre><p>Again, the above works perfectly fine as long as our test keeps succeeding, but if we‚Äôll ever end up with a failure ‚Äî say a single note that was misplaced ‚Äî debugging that failure among an array of 25 or 50 values might become quite frustrating.</p><p>Wouldn‚Äôt it be great if we instead could see <em>exactly which element</em> that caused the failure, including any missing or unexpected new elements? Let‚Äôs see if we can make that happen by using Swift 5.1‚Äôs new <em><a href="https://www.swiftbysundell.com/articles/5-small-but-significant-improvements-in-swift-5-1/%23ordered-collection-diffing">ordered collection diffing</a></em> feature. That feature will only work on iOS 13, macOS Catalina, and the other operating systems that Apple released in 2019, but that might not be an issue for our unit testing suite ‚Äî even if we still ship our app itself with support for older system versions.</p><p>The ordered collection diffing API produces a <code>CollectionDifference</code> instance, which in turn is a collection containing <code>Change</code> values, that represent the changes between the two collections that are being compared. So let‚Äôs start by extending <code>CollectionDifference</code> with a method for converting a given change into a human-readable error message:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">CollectionDifference</span> {
    <span class="s-keyword">func</span> testDescription(for change: <span class="s-type">Change</span>) -&gt; <span class="s-type">String</span>? {
        <span class="s-keyword">switch</span> change {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">insert</span>(<span class="s-keyword">let</span> index, <span class="s-keyword">let</span> element, <span class="s-keyword">let</span> association):
            <span class="s-keyword">if let</span> oldIndex = association {
                <span class="s-keyword">return</span> <span class="s-string">"""
                Element moved from index</span> \(oldIndex) <span class="s-string">to</span> \(index)<span class="s-string">:</span> \(element)
                <span class="s-string">"""</span>
            } <span class="s-keyword">else</span> {
                <span class="s-keyword">return</span> <span class="s-string">"Additional element at index</span> \(index)<span class="s-string">:</span> \(element)<span class="s-string">"</span>
            }
        <span class="s-keyword">case</span> .<span class="s-dotAccess">remove</span>(<span class="s-keyword">let</span> index, <span class="s-keyword">let</span> element, <span class="s-keyword">let</span> association):
            <span class="s-comment">// If a removal has an association, it means that
            // it's part of a move, which we're handling above.</span>
            <span class="s-keyword">guard</span> association == <span class="s-keyword">nil else</span> {
                <span class="s-keyword">return nil</span>
            }

            <span class="s-keyword">return</span> <span class="s-string">"Missing element at index</span> \(index)<span class="s-string">:</span> \(element)<span class="s-string">"</span>
        }
    }
}</code></pre><p>Using the above, we can again extend <code>CollectionDifference</code> with another method that lets us convert its entire set of changes into one unified error message ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">CollectionDifference</span> {
    <span class="s-keyword">func</span> asTestErrorMessage() -&gt; <span class="s-type">String</span> {
        <span class="s-keyword">let</span> descriptions = <span class="s-call">compactMap</span>(testDescription)

        <span class="s-keyword">guard</span> !descriptions.<span class="s-property">isEmpty</span> <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> <span class="s-string">""</span>
        }

        <span class="s-keyword">return</span> <span class="s-string">"- "</span> + descriptions.<span class="s-call">joined</span>(separator: <span class="s-string">"\n- "</span>)
    }
}</code></pre><p class="info">Above we‚Äôre making use of the fact that Swift supports <a href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift">first class functions</a>, which enables us to pass our <code>testDescription(for:)</code> method as if it was a closure.</p><p>Finally, let‚Äôs write our new, custom assertion function ‚Äî which we‚Äôll simply call <code>assertEqual</code> (we shouldn‚Äôt use the <code>XCT</code> prefix since we‚Äôre defining this new function outside of the <code>XCTest</code> framework itself). Since the ordered collection diffing API is only compatible with collections that conform to <code>BidirectionalCollection</code>, we‚Äôll make that a requirement for our new function, while also requiring that all elements conform to <code>Hashable</code>.</p><p>Within our function, we‚Äôll then use the standard library‚Äôs <code>difference(from:)</code> API to produce a <code>CollectionDifference</code> instance, which we‚Äôll convert into an error message using the method we defined above. If that message isn‚Äôt empty, we cause our test to fail by passing that message along to <code>XCTAssert</code>:</p><pre class="splash"><code><span class="s-keyword">func</span> assertEqual&lt;T: <span class="s-type">BidirectionalCollection</span>&gt;(
    <span class="s-keyword">_</span> first: <span class="s-type">T</span>,
    <span class="s-keyword">_</span> second: <span class="s-type">T</span>,
    file: <span class="s-type">StaticString</span> = <span class="s-keyword">#file</span>,
    line: <span class="s-type">UInt</span> = <span class="s-keyword">#line</span>
) <span class="s-keyword">where</span> <span class="s-type">T</span>.<span class="s-type">Element</span>: <span class="s-type">Hashable</span> {
    <span class="s-keyword">let</span> diff = second.<span class="s-call">difference</span>(from: first).<span class="s-call">inferringMoves</span>()
    <span class="s-keyword">let</span> message = diff.<span class="s-call">asTestErrorMessage</span>()

    <span class="s-call">XCTAssert</span>(message.<span class="s-property">isEmpty</span>, <span class="s-string">"""
    The two collections are not equal. Differences:</span>
    \(message<span class="s-string">)
    """</span>, file: file, line: line)
}</code></pre><p class="info">Note how we capture the <code>file</code> and <code>line</code> of the code location that our custom assertion function was called from, and we then pass that data along to <code>XCTAssert</code>. That way, Xcode will display any failures that our function will generate at the correct location, inline within our code.</p><p>With the above in place, all we now need to do is to replace our previous test implementation‚Äôs calls to <code>XCTAssertEqual</code> with <code>assertEqual</code>, and we‚Äôll get much more granular (and actionable) error messages if we ever start encountering a failure:</p><pre class="splash"><code><span class="s-keyword">class</span> NoteManagerTests: <span class="s-type">XCTestCase</span> {
    ...
    
    <span class="s-keyword">func</span> testPagination() {
        ...
        
        <span class="s-call">assertEqual</span>(
            manager.<span class="s-call">notesOnPage</span>(<span class="s-number">0</span>),
            <span class="s-type">Array</span>(notes[..&lt;<span class="s-number">25</span>])
        )

        <span class="s-call">assertEqual</span>(
            manager.<span class="s-call">notesOnPage</span>(<span class="s-number">1</span>),
            <span class="s-type">Array</span>(notes[<span class="s-number">25</span>...])
        )

        <span class="s-call">assertEqual</span>(manager.<span class="s-call">notesOnPage</span>(<span class="s-number">2</span>), [])
    }
}</code></pre><p>What‚Äôs really cool is that not only can the above function be used to verify the contents of ordered data structures like <code>Array</code>, but because we used the <code>BidirectionalCollection</code> protocol as its constraint, it can also be used with other collections as well ‚Äî such as ranges, index sets, and strings.</p><p>However, when it comes to strings in particular, we‚Äôll end up with a character-by-character comparison, which might be <em>a bit too granular</em> ‚Äî so we might want to split each string that we‚Äôre verifying up a bit, for example into words, so that it‚Äôll be easier to identify what the actual differences were:</p><pre class="splash"><code><span class="s-keyword">let</span> string = ...
<span class="s-keyword">let</span> expectedString = ...

<span class="s-call">assertEqual</span>(
    string.<span class="s-call">split</span>(separator: <span class="s-string">" "</span>),
    expectedString.<span class="s-call">split</span>(separator: <span class="s-string">" "</span>)
)</code></pre><p>The above is yet another another example of the power of writing <a href="https://www.swiftbysundell.com/articles/writing-reusable-swift-extensions">reusable extensions</a> that are not bound to a concrete type, but rather to a standard library protocol ‚Äî as it lets us get much more milage out of each utility that we write.</p><h2>Conclusion</h2><p>Picking the right set of assertion functions for each test that we write can have a big impact on both the clarity and semantics of our testing code, and also on the kind of information that we‚Äôll get access to if a test starts failing.</p><p>While the standard suite of assertions that the <code>XCTest</code> framework ships with are most likely going to be enough to cover the needs of most code bases, also being able to create our own assertion functions when needed is incredibly powerful ‚Äî and can help us build up our own <em>‚Äúlibrary‚Äù</em> of testing utilities, that in turn can make it easier and easier to write new tests.</p><p>What do you think? How do you tend to perform the assertions within your unit tests, and have you ever written a custom assertion function? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://www.swiftbysundell.com/contact">email</a> or <a href="https://twitter.com/johnsundell">Twitter</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/access-control</guid><title>Basics: Access Control</title><description>An overview of Swift‚Äôs five different levels of access control, how they work, and when each of them might be useful in practice.</description><link>https://www.swiftbysundell.com/basics/access-control</link><pubDate>Sat, 11 Jan 2020 16:30:00 +0100</pubDate><content:encoded><![CDATA[<p>The concept of <em>access control</em> enables us to restrict how types, functions and other declarations can be accessed by other code. Swift offers five different levels of access control, and making full use of them can be crucial in order to write programs that have clearly separated concerns and a robust structure.</p><p>When we define any new type, property, or function in Swift, it‚Äôll have the <code>internal</code> access level by default. That means that it‚Äôll be visible to all other code that lives within the same <em>module</em> ‚Äî such as an app, a system extension, a framework, or a Swift package.</p><p>As an example, let‚Äôs say that we‚Äôre building a shopping app, and that we‚Äôve defined a class called <code>PriceCalculator</code> that lets us calculate the total price for an array of products:</p><pre class="splash"><code><span class="s-keyword">class</span> PriceCalculator {
    <span class="s-keyword">func</span> calculatePrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        <span class="s-comment">// The reduce function enables us to reduce a collection,
        // in this case an array of products, into a single value:</span>
        products.<span class="s-call">reduce</span>(into: <span class="s-number">0</span>) { totalPrice, product <span class="s-keyword">in</span>
            totalPrice += product.<span class="s-property">price</span>
        }
    }
}</code></pre><p>As we‚Äôre currently not specifying any explicit access level, our <code>PriceCalculator</code> class (and its <code>calculatePrice</code> method) will be accessible from anywhere within our app. However, if we‚Äôre looking to share our new class with other modules (we might, for instance, implement it within a framework that we share between our main app and an extension, or a companion Apple Watch app), then we‚Äôll need to make it <code>public</code> in order for it to be visible within those external contexts:</p><pre class="splash"><code><span class="s-keyword">public class</span> PriceCalculator {
    <span class="s-keyword">public func</span> calculatePrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        products.<span class="s-call">reduce</span>(into: <span class="s-number">0</span>) { totalPrice, product <span class="s-keyword">in</span>
            totalPrice += product.<span class="s-property">price</span>
        }
    }
}</code></pre><p>However, the above change is not quite enough. While we‚Äôre now able to find our class outside of the module that it‚Äôs defined in, we can‚Äôt create any instances of it ‚Äî since its (implicit) initializer is, just like any other code, <code>internal</code> by default. To fix that, let‚Äôs define a <code>public</code> initializer, which we‚Äôll leave empty since there‚Äôs no actual work to be done within it:</p><pre class="splash"><code><span class="s-keyword">public class</span> PriceCalculator {
    <span class="s-keyword">public init</span>() {}
    ...
}</code></pre><p>We‚Äôre now able to find, initialize, and call our <code>PriceCalculator</code> both inside and outside of its module ‚Äî fantastic. But let‚Äôs now say that we‚Äôre also looking to <em>subclass it</em> in order to modify it, or to add new functionality to it. While that‚Äôs currently possible within its own module, it‚Äôs again something that‚Äôs prevented outside of it.</p><p>To change that, we‚Äôll have to use Swift‚Äôs currently most open level of access control, which is appropriately named <code>open</code>:</p><pre class="splash"><code><span class="s-keyword">open class</span> PriceCalculator {
    ...
}</code></pre><p>With the above change in place, we can now create custom subclasses of <code>PriceCalculator</code> anywhere ‚Äî which can have new initializers, new properties, and new methods. Here‚Äôs how we might use that to implement a <code>DiscountedPriceCalculator</code>, which lets us apply a given <code>discount</code> to all price calculations:</p><pre class="splash"><code><span class="s-keyword">class</span> DiscountedPriceCalculator: <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">let</span> discount: <span class="s-type">Int</span>

    <span class="s-keyword">init</span>(discount: <span class="s-type">Int</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">discount</span> = discount
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>()
    }

    <span class="s-keyword">func</span> calculateDiscountedPrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        <span class="s-keyword">let</span> price = <span class="s-call">calculatePrice</span>(for: products)
        <span class="s-keyword">return</span> price - discount
    }
}</code></pre><p>Above we‚Äôre defining a brand new price calculation method, but it would arguably be much more appropriate to override and modify the existing <code>calculatePrice</code> method that we inherited from our base class instead. That way, there would be no confusion around which method to call, and we could keep our two classes consistent.</p><p>To be able to do that, we again have to mark the original declaration ‚Äî this time our <code>calculatePrice</code> method declaration ‚Äî as <code>open</code>:</p><pre class="splash"><code><span class="s-keyword">open class</span> PriceCalculator {
    <span class="s-keyword">public init</span>() {}

    <span class="s-keyword">open func</span> calculatePrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        ...
    }
}</code></pre><p>With the above in place, we can now freely override <code>calculatePrice</code>, rather than having to create a separate method:</p><pre class="splash"><code><span class="s-keyword">class</span> DiscountedPriceCalculator: <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">let</span> discount: <span class="s-type">Int</span>

    <span class="s-keyword">init</span>(discount: <span class="s-type">Int</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">discount</span> = discount
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>()
    }

    <span class="s-keyword">override func</span> calculatePrice(for products: [<span class="s-type">Product</span>]) -&gt; <span class="s-type">Int</span> {
        <span class="s-keyword">let</span> price = <span class="s-keyword">super</span>.<span class="s-call">calculatePrice</span>(for: products)
        <span class="s-keyword">return</span> price - discount
    }
}</code></pre><p>So that‚Äôs <code>internal</code>, <code>public</code> and <code>open</code> ‚Äî which are used to gradually <em>open a declaration up</em> for public use and modification. But we can of course also go the other way, and hide parts of our code from being discovered and used. At first, it may seem questionable what the value is in doing that, but it can really help us make our API much more narrow and focused ‚Äî which in turn can make it easier to understand, test, and use.</p><p>So let‚Äôs now go all the way to the other side of the access level spectrum, and take a look at the most restrictive level ‚Äî <code>private</code>. Any type, property or method that‚Äôs marked as <code>private</code> will only be visible <em>within its own type</em> (which also includes extensions on that type defined within the same file).</p><p>Anything that should be considered a <em>private implementation detail</em> of a given type should arguably be marked as <code>private</code>. For example, our price calculator‚Äôs <code>discount</code> property from before was really only meant to be used within its own class ‚Äî so let‚Äôs go ahead and make that property private:</p><pre class="splash"><code><span class="s-keyword">class</span> DiscountedPriceCalculator: <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">private let</span> discount: <span class="s-type">Int</span>
    ...
}</code></pre><p>Our previous implementation will continue to work exactly the same way as before, since <code>discount</code> will remain entirely visible within our <code>DiscountedPriceCalculator</code> class. However, if we wanted to slightly extend that visibility to also include <em>other types</em> defined within the same file, we‚Äôd have to use <code>fileprivate</code> ‚Äî which does exactly what it sounds like, it keeps a declaration private <em>within the file that it‚Äôs defined in</em>:</p><pre class="splash"><code><span class="s-keyword">class</span> DiscountedPriceCalculator: <span class="s-type">PriceCalculator</span> {
    <span class="s-keyword">fileprivate let</span> discount: <span class="s-type">Int</span>
    ...
}</code></pre><p>With the above change in place, we can now access our <code>discount</code> property from related code defined in the same file ‚Äî such as this extension on <code>UIAlertController</code> which lets us easily show a price description for an array of products within an alert:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIAlertController</span> {
    <span class="s-keyword">func</span> showPriceDescription(
        for products: [<span class="s-type">Product</span>],
        calculator: <span class="s-type">DiscountedPriceCalculator</span>
    ) {
        <span class="s-keyword">let</span> price = calculator.<span class="s-call">calculatePrice</span>(for: products)

        <span class="s-comment">// We can now access 'discount' even outside of the type
        // that it's declared in, thanks to 'fileprivate':</span>
        message = <span class="s-string">"""
        Your</span> \(products.<span class="s-property">count</span>) <span class="s-string">product(s) will cost</span> \(price)<span class="s-string">.
        Including a discount of</span> \(calculator.<span class="s-property">discount</span>)<span class="s-string">.
        """</span>
    }
}</code></pre><p class="info">When it comes to free functions, types and extensions, <code>private</code> and <code>fileprivate</code> act exactly the same. They‚Äôre only different when applied to declarations that are defined <strong>within a type</strong>.</p><p>So, to sum up, these are the five levels of access control that Swift currently offers:</p><ul><li><code>private</code> keeps a property or function private within its enclosing type, including any extensions on that type that are defined within the same file. When applied to a top-level type, function or extension, it acts the same way as <code>fileprivate</code>.</li><li><code>fileprivate</code> makes a declaration visible within the entire file that it‚Äôs defined in, while hiding it from all other code.</li><li><code>internal</code> is the default access level, and makes a declaration visible within the whole module that it‚Äôs defined in.</li><li><code>public</code> reveals a function, type, extension or property outside of its module.</li><li><code>open</code> enables a class to be subclassed, and a function or property to be overridden, outside of its module.</li></ul><p>In general, it‚Äôs often best to start out with the most restrictive level of access that a given declaration can practically have, and then open things up later if needed. That way we‚Äôre limiting the avenues for interaction between our various types and functions, which may at first seem like a bad thing, but is often truly essential in order to build maintainable and well-structured systems.</p><p>Thanks for reading! üöÄ</p><p><em>(Note that this article didn‚Äôt go into mutation-specific access modifiers, such as <code>private(set)</code>. Those will be covered by another Basics article in the future.)</em></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-self-to-refer-to-enclosing-types</guid><title>Tip: Using Self to refer to enclosing types</title><description></description><link>https://www.swiftbysundell.com/tips/using-self-to-refer-to-enclosing-types</link><pubDate>Wed, 8 Jan 2020 20:45:00 +0100</pubDate><content:encoded><![CDATA[<p>Swift includes a number of features that can help us make our code more concise and easier to read, such as its type inference capabilities, <a href="https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift">type aliases</a>, and the way that types can be referred to within their own declarations and extensions.</p><p>For example, let‚Äôs say that we wanted to extend a generic type, such as the <code>PublishingStep&lt;Site&gt;</code> type from <a href="https://github.com/JohnSundell/publish">Publish</a>, with a new <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory method</a>. When declaring our method, we <em>could</em> of course type out <code>PublishingStep&lt;Site&gt;</code> every time that we want to refer to the extended type itself, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">PublishingStep</span> {
    <span class="s-keyword">static func</span> group(
        <span class="s-keyword">_</span> steps: [<span class="s-type">PublishingStep</span>&lt;<span class="s-type">Site</span>&gt;]
    ) -&gt; <span class="s-type">PublishingStep</span>&lt;<span class="s-type">Site</span>&gt; {
        <span class="s-type">PublishingStep</span>&lt;<span class="s-type">Site</span>&gt;(...)
    }
}</code></pre><p>However, that‚Äôs quite verbose, and not in the way that makes our code easier to read or understand ‚Äî quite the opposite. Thankfully, when extending a generic type, we don‚Äôt have to type out its complete signature, all we need is the name of the type itself ‚Äî and the compiler will infer the rest:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">PublishingStep</span> {
    <span class="s-keyword">static func</span> group(
        <span class="s-keyword">_</span> steps: [<span class="s-type">PublishingStep</span>]
    ) -&gt; <span class="s-type">PublishingStep</span> {
       <span class="s-type">PublishingStep</span>(...)
    }
}</code></pre><p>That‚Äôs definitely better, and functionally the same as our initial implementation ‚Äî but as of Swift 5.1, we can go one step further. Thanks to the improvements made to the <code>Self</code> alias, we can now use that to refer to any method or property‚Äôs enclosing type in a really compact manner, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">PublishingStep</span> {
    <span class="s-keyword">static func</span> group(<span class="s-keyword">_</span> steps: [<span class="s-type">Self</span>]) -&gt; <span class="s-type">Self</span> {
       <span class="s-type">Self</span>(...)
    }
}</code></pre><p class="info">Note how <code>Self</code> can even be used when creating a new instance of our type.</p><p>While compact code isn‚Äôt always better code, in this case, using <code>Self</code> has definitely made our code easier to read ‚Äî without sacrificing any of its functionality or meaning. It‚Äôs a great tool to keep in mind when working with types that have longer names, or complex generic types.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/writing-reusable-swift-extensions</guid><title>Writing reusable Swift extensions</title><description>A look at what goes into writing type- and protocol extensions that can be reused between different use cases and projects, and what sort of principles that can be good to keep in mind when doing that.</description><link>https://www.swiftbysundell.com/articles/writing-reusable-swift-extensions</link><pubDate>Sun, 5 Jan 2020 20:50:00 +0100</pubDate><content:encoded><![CDATA[<p>Arguably one of Swift‚Äôs most interesting and powerful features is how it lets us extend any type or protocol with new functionality. Not only does that let us tweak the language and its standard library to fit each projects‚Äô needs, it also opens up many different opportunities for writing extensions that could be reused across multiple use cases and projects.</p><p>This week, let‚Äôs take a look at a few examples of doing just that, as well as a set of principles that can be good to keep in mind when generalizing an extension to be usable in a much wider context.</p><h2>Generalizing through abstractions</h2><p>When writing code on a day-to-day basis, it‚Äôs very common for each new feature and piece of functionality to start its life as a very domain-specific implementation. There‚Äôs nothing wrong with that, in fact, it helps us avoid <em>‚Äúpremature generalization‚Äù</em> and often lets us iterate much faster by initially focusing on just a single use case.</p><p>For example, let‚Äôs say that we‚Äôre working on a text editor for writing articles ‚Äî and that in order to improve our app‚Äôs performance in certain scenarios, we‚Äôve written the following function to enable us to easily cache a given article to disk:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Article</span> {
    <span class="s-keyword">func</span> cacheOnDisk() <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> folderURLs = <span class="s-type">FileManager</span>.<span class="s-property">default</span>.<span class="s-call">urls</span>(
            for: .<span class="s-dotAccess">cachesDirectory</span>,
            in: .<span class="s-dotAccess">userDomainMask</span>
        )

        <span class="s-keyword">let</span> fileName = <span class="s-string">"Article-</span>\(id)<span class="s-string">.cache"</span>
        <span class="s-keyword">let</span> fileURL = folderURLs[<span class="s-number">0</span>].<span class="s-call">appendingPathComponent</span>(fileName)
        <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> <span class="s-type">JSONEncoder</span>().<span class="s-call">encode</span>(<span class="s-keyword">self</span>)
        <span class="s-keyword">try</span> data.<span class="s-call">write</span>(to: fileURL)
    }
}</code></pre><p class="info">The above caching implementation is just an example, for a much more thorough look at building various forms of caching systems in Swift, check out <a href="https://www.swiftbysundell.com/articles/caching-in-swift">‚ÄúCaching in Swift‚Äù</a>.</p><p>Extending specific types with the above kind of utilities can be a great way to both reduce code duplication, and to make it easier to perform common tasks across a code base. However, a concrete type extension can also sometimes be a bit of a missed opportunity to make our code less decoupled and more flexible. In this particular case, chances are very high that we‚Äôll not only want to cache <code>Article</code> instances, but also other kinds of models as well ‚Äî which our current implementation won‚Äôt let us do.</p><p>When looking to generalize a specific extension, it may first seem like the work that‚Äôs being done is indeed strongly tied to the concrete type that‚Äôs being extended. For example, our above caching function uses our <code>Article</code> type‚Äôs name, and its <code>id</code> property, to form each <code>fileName</code>. However, conceptually, there‚Äôs really nothing about those two pieces of data that‚Äôs specific to articles ‚Äî every type has a name, and any type can have an <code>id</code> property, so we should be able to make that extension reusable.</p><p>Let‚Äôs start by reviewing what our caching function‚Äôs requirements <em>actually are</em>:</p><ul><li>In order to be able to encode each value into a JSON representation, we need any type that‚Äôs going to be used with our function to conform to the standard library‚Äôs <code>Encodable</code> protocol.</li><li>We also need each compatible type to have an <code>id</code> property, to be able to compute a unique <code>fileName</code> for each value that‚Äôs being cached.</li></ul><p>To model those two requirements in a way that‚Äôs not directly tied to any concrete type, we‚Äôll use <code>Encodable</code> as the new base target for our extension, and we‚Äôll then add a <a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4">generic type constraint</a> to specify that our caching method may only be called on types that also conform to <code>Identifiable</code> ‚Äî another standard library protocol, which gives us the <code>id</code> property that we need:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Encodable</span> <span class="s-keyword">where</span> <span class="s-type">Self</span>: <span class="s-type">Identifiable</span> {
    <span class="s-comment">// We also take this opportunity to parameterize our JSON
    // encoder, to enable the users of our new API to pass in
    // a custom encoder, and to make our method's dependencies
    // more clear:</span>
    <span class="s-keyword">func</span> cacheOnDisk(using encoder: <span class="s-type">JSONEncoder</span> = .<span class="s-keyword">init</span>()) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> folderURLs = <span class="s-type">FileManager</span>.<span class="s-property">default</span>.<span class="s-call">urls</span>(
            for: .<span class="s-dotAccess">cachesDirectory</span>,
            in: .<span class="s-dotAccess">userDomainMask</span>
        )

        <span class="s-comment">// Rather than hard-coding a specific type's name here,
        // we instead dynamically resolve a description of the
        // type that our method is currently being called on:</span>
        <span class="s-keyword">let</span> typeName = <span class="s-type">String</span>(describing: <span class="s-type">Self</span>.<span class="s-keyword">self</span>)
        <span class="s-keyword">let</span> fileName = <span class="s-string">"</span>\(typeName)<span class="s-string">-</span>\(id)<span class="s-string">.cache"</span>
        <span class="s-keyword">let</span> fileURL = folderURLs[<span class="s-number">0</span>].<span class="s-call">appendingPathComponent</span>(fileName)
        <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> encoder.<span class="s-call">encode</span>(<span class="s-keyword">self</span>)
        <span class="s-keyword">try</span> data.<span class="s-call">write</span>(to: fileURL)
    }
}</code></pre><p>Just like that, we‚Äôve converted our caching method from a very <code>Article</code>-specific implantation into a completely reusable one ‚Äî and since our new extension only depends on protocols and abstractions defined by Swift‚Äôs standard library, we could also now share it between code bases that need the same sort of functionality.</p><h2>Finding the right protocol</h2><p>Let‚Äôs take a look at another example, in which we‚Äôve again written an <code>Article</code>-specific extension, this time on the standard library‚Äôs <a href="https://www.swiftbysundell.com/articles/the-power-of-result-types-in-swift"><code>Result</code> type</a> ‚Äî to enable a result instance carrying an array of <code>Article</code> values to be easily combined with another instance of the same type:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Result</span> <span class="s-keyword">where</span> <span class="s-type">Success</span> == [<span class="s-type">Article</span>] {
    <span class="s-keyword">func</span> combine(with other: <span class="s-type">Self</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">try</span> .<span class="s-call">success</span>(<span class="s-call">get</span>() + other.<span class="s-call">get</span>())
    }
}</code></pre><p>Just like our caching method from before, there‚Äôs really nothing about the above <code>combine</code> method that requires it to know about <code>Article</code> as a concrete type. In this case, all we need is to be able to combine two underlying collections of values into one ‚Äî which is something that can be done with any type that conforms to <code>RangeReplaceableCollection</code>.</p><p>So let‚Äôs again replace our concrete type requirement with a much more generic constraint, and this time we don‚Äôt even need to change our actual implementation at all:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Result</span> <span class="s-keyword">where</span> <span class="s-type">Success</span>: <span class="s-type">RangeReplaceableCollection</span> {
    <span class="s-keyword">func</span> combine(with other: <span class="s-type">Self</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">try</span> .<span class="s-call">success</span>(<span class="s-call">get</span>() + other.<span class="s-call">get</span>())
    }
}</code></pre><p>What both of the above two examples demonstrate is that it‚Äôs often possible to generalize a utility extension into something that‚Äôs much more general-purpose ‚Äî by picking one of the standard library‚Äôs many built-in abstractions as our extension‚Äôs target, rather than using one of our own, concrete types. By doing so, we not only make it possible to reuse our functionality among our own types, but we could potentially also share it between projects ‚Äî and even <a href="https://www.swiftbysundell.com/articles/open-sourcing-swift-code">open source it</a>.</p><h2>Avoiding conflicts and type pollution</h2><p>So far, the extensions that we‚Äôve defined have all contained the actual functionality that we wanted to add, but that‚Äôs not always the case. For example, sometimes the entire purpose of an extension is to retrofit an existing type with a protocol conformance, or to make it compatible with a custom system or API.</p><p>Let‚Äôs take a look at such a scenario, in which we‚Äôre building a general-purpose storage framework that‚Äôll enable various projects to save and load different values using a <code>Container</code> type. To be able to write a given piece of data into one of those containers, we‚Äôve defined a <code>DataConvertible</code> protocol that we‚Äôve then made several system types conform to ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> DataConvertible {
    <span class="s-keyword">var</span> data: <span class="s-type">Data</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">extension</span> <span class="s-type">Data</span>: <span class="s-type">DataConvertible</span> {
    <span class="s-keyword">public var</span> data: <span class="s-type">Data</span> { <span class="s-keyword">self</span> }
}

<span class="s-keyword">extension</span> <span class="s-type">String</span>: <span class="s-type">DataConvertible</span> {
    <span class="s-keyword">public var</span> data: <span class="s-type">Data</span> { <span class="s-type">Data</span>(utf8) }
}

<span class="s-keyword">extension</span> <span class="s-type">UIImage</span>: <span class="s-type">DataConvertible</span> {
    <span class="s-keyword">public var</span> data: <span class="s-type">Data</span> { <span class="s-call">pngData</span>()! }
}

<span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> value: <span class="s-type">DataConvertible</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> data = value.<span class="s-property">data</span>
        ...
    }
}</code></pre><p>The above approach might work reasonably well within a single code base, but if our intention is for this functionality to be shared among multiple projects, it‚Äôll most likely end up becoming quite problematic.</p><p>Since we‚Äôve defined our property requirement simply as <code>data</code>, chances are high that it‚Äôll end up colliding with other property definitions that have the same name. That‚Äôs also true for our protocol itself, which has the very generic name <code>DataConvertible</code> ‚Äî which could become ambiguous in a larger context. While type names can always be disambiguated using <code>ModuleName.TypeName</code>, property names cannot.</p><p>One potential solution to this problem would be to remove our protocol (and its associated extensions) altogether, and instead add a number of type-specific overloads to our <code>Container</code> type, like this:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> data: <span class="s-type">Data</span>) <span class="s-keyword">throws</span> {
        ...
    }

    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">try</span> <span class="s-call">write</span>(<span class="s-type">Data</span>(string.<span class="s-property">utf8</span>))
    }

    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> image: <span class="s-type">UIImage</span>) <span class="s-keyword">throws</span> {
        <span class="s-keyword">guard let</span> data = image.<span class="s-call">pngData</span>() <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">Error</span>.<span class="s-property">failedToConvertImageToPNGData</span>
        }

        <span class="s-keyword">try</span> <span class="s-call">write</span>(data)
    }
}</code></pre><p>While the above approach works great as long as the number of types that we‚Äôre supporting remains fairly low, things can start to get tricky in case we ever want to add more configuration options and parameters to our container API.</p><p>For example, let‚Äôs say that we wanted to enable our API users to specify what level of persistence to use when writing a given value, or to associate a set of tags with it. Just those two minor additions would already make our implementation a lot more complicated, and cause a fair amount of code duplication ‚Äî as we‚Äôd need to add both of those parameters (and their default values) to every single overload:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> data: <span class="s-type">Data</span>,
                      persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
                      tags: [<span class="s-type">Tag</span>] = []) <span class="s-keyword">throws</span> {
        ...
    }

    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> string: <span class="s-type">String</span>,
                      persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
                      tags: [<span class="s-type">Tag</span>] = []) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> data = <span class="s-type">Data</span>(string.<span class="s-property">utf8</span>)

        <span class="s-keyword">try</span> <span class="s-call">write</span>(data,
            persistence: persistence,
            tags: tags
        )
    }

    <span class="s-keyword">public func</span> write(<span class="s-keyword">_</span> image: <span class="s-type">UIImage</span>,
                      persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
                      tags: [<span class="s-type">Tag</span>] = []) <span class="s-keyword">throws</span> {
        <span class="s-keyword">guard let</span> data = image.<span class="s-call">pngData</span>() <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">Error</span>.<span class="s-property">failedToConvertImageToPNGData</span>
        }

        <span class="s-keyword">try</span> <span class="s-call">write</span>(data,
            persistence: persistence,
            tags: tags
        )
    }
}</code></pre><p>As it turns out that internalizing all possible argument combinations within our <code>Container</code> type isn‚Äôt necessarily great either ‚Äî let‚Äôs go back and explore the protocol-oriented route a bit further.</p><p>Since our main problem before was that our protocol and its requirement were named in a way that could potentially cause conflicts ‚Äî let‚Äôs instead use a slightly more verbose naming convention, which explicitly includes the word <em>‚ÄúContainer‚Äù</em>. Let‚Äôs also make our protocol requirement a throwing function, which lets us avoid any force unwrapping when converting a <code>UIImage</code> into <code>Data</code>:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> ContainerDataConvertible {
    <span class="s-keyword">func</span> asContainerData() <span class="s-keyword">throws</span> -&gt; <span class="s-type">Data</span>
}

<span class="s-keyword">extension</span> <span class="s-type">Data</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public func</span> asContainerData() -&gt; <span class="s-type">Data</span> {
        <span class="s-keyword">self</span>
    }
}

<span class="s-keyword">extension</span> <span class="s-type">String</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public func</span> asContainerData() -&gt; <span class="s-type">Data</span> {
        <span class="s-type">Data</span>(utf8)
    }
}

<span class="s-keyword">extension</span> <span class="s-type">UIImage</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public func</span> asContainerData() <span class="s-keyword">throws</span> -&gt; <span class="s-type">Data</span> {
        <span class="s-keyword">guard let</span> data = <span class="s-call">pngData</span>() <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">Container</span>.<span class="s-type">Error</span>.<span class="s-property">failedToConvertImageToPNGData</span>
        }

        <span class="s-keyword">return</span> data
    }
}</code></pre><p class="info">Note that not just because a protocol function is marked as <code>throws</code> doesn‚Äôt mean that all <a href="https://www.swiftbysundell.com/tips/implementing-throwing-protocol-functions-as-non-throwing/">implementations of it need to throw</a>.</p><p>With the above change in place, chances are now much lower that our extension will end up causing problems when mixed with other code bases, and we‚Äôre back to <code>Container</code> having just a single <code>write</code> method that can handle any <code>ContainerDataConvertible</code>-conforming type:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write(
        <span class="s-keyword">_</span> value: <span class="s-type">ContainerDataConvertible</span>,
        persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
        tags: [<span class="s-type">Tag</span>] = []
    ) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> value.<span class="s-call">asContainerData</span>()
        ...
    }
}</code></pre><p>That‚Äôs already much better, but perhaps we could go one step further in terms of making our system extensions as unobtrusive as possible. Up until now, we‚Äôve been adding instance properties and methods to the types that are being retrofitted, which makes those additions quite visible and likely to show up as autocompletion results (even though they‚Äôre more or less intended to be implementation details of <code>Container</code>).</p><p>To address that, let‚Äôs instead define our protocol requirement as a <em>static</em> function ‚Äî and implement it on the actual types themselves, rather than adding it to all instances of them:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> ContainerDataConvertible {
    <span class="s-keyword">static func</span> makeContainerData(for value: <span class="s-type">Self</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Data</span>
}

<span class="s-keyword">extension</span> <span class="s-type">Data</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public static func</span> makeContainerData(for value: <span class="s-type">Data</span>) -&gt; <span class="s-type">Data</span> {
        value
    }
}

<span class="s-keyword">extension</span> <span class="s-type">String</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public static func</span> makeContainerData(for value: <span class="s-type">String</span>) -&gt; <span class="s-type">Data</span> {
        <span class="s-type">Data</span>(value.<span class="s-property">utf8</span>)
    }
}

<span class="s-keyword">extension</span> <span class="s-type">UIImage</span>: <span class="s-type">ContainerDataConvertible</span> {
    <span class="s-keyword">public static func</span> makeContainerData(for value: <span class="s-type">UIImage</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Data</span> {
        <span class="s-keyword">guard let</span> data = value.<span class="s-call">pngData</span>() <span class="s-keyword">else</span> {
            <span class="s-keyword">throw</span> <span class="s-type">Container</span>.<span class="s-type">Error</span>.<span class="s-property">failedToConvertImageToPNGData</span>
        }

        <span class="s-keyword">return</span> data
    }
}</code></pre><p>The above implementation still lets us maintain just a single <code>write</code> function, all without having to add any additional complexity to the instances of our compatible types ‚Äî since we‚Äôll now simply call <code>makeContainerData</code> directly on each value‚Äôs type, like this:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Container {
    <span class="s-keyword">public func</span> write&lt;T: <span class="s-type">ContainerDataConvertible</span>&gt;(
        <span class="s-keyword">_</span> value: <span class="s-type">T</span>,
        persistence: <span class="s-type">Persistence</span> = .<span class="s-dotAccess">permanent</span>,
        tags: [<span class="s-type">Tag</span>] = []
    ) <span class="s-keyword">throws</span> {
        <span class="s-keyword">let</span> data = <span class="s-keyword">try</span> <span class="s-type">T</span>.<span class="s-call">makeContainerData</span>(for: value)
        ...
    }
}</code></pre><p>Especially when it comes to making a number of system types compatible with a custom API or framework, adding the required complexity in a static context can be a great way to better encapsulate all of those implementation details, and can let us avoid <em>‚Äúpolluting‚Äù</em> the instances of those types.</p><h2>Conclusion</h2><p>A big part of enabling a given extension to be reused often comes down to picking the right level of abstraction for it, and the more we can rely on the standard library to act as a common denominator for all compatible types, the more portable our extensions are likely to become.</p><p>However, sometimes we do need to introduce our own custom protocols when sharing extensions between projects, and there‚Äôs nothing wrong with that ‚Äî as long as we make sure that we‚Äôre doing everything that we can to avoid adding additional cruft or potential sources of conflict to any system types that we‚Äôre making conform to those protocols.</p><p>What do you think? How do you currently use extensions in your projects, and do you tend to share any of your extensions between projects? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/the-decade-of-swift</guid><title>The Decade of Swift</title><description>For the 150th weekly article on this site, and the last one before the end of the decade, let‚Äôs look back at how Swift has fundamentally changed the way apps for Apple‚Äôs platforms are built, and where things might be going from here.</description><link>https://www.swiftbysundell.com/articles/the-decade-of-swift</link><pubDate>Sun, 29 Dec 2019 21:40:00 +0100</pubDate><content:encoded><![CDATA[<p>Even before it started, WWDC 2014 was a very special event for me, personally. Not only was it the first (and at the time of writing, the only) time that I was lucky enough to be able to attend the conference in person, it was also my very first encounter with the wider Apple developer community ‚Äî which had a profound impact on me in terms of how I‚Äôd come to view my work, and myself as a member of that community.</p><p>But this is not a story about me. Instead, it‚Äôs the story of how approximately one hour and forty-five minutes into the WWDC 2014 keynote, the world of iOS and Mac development fundamentally changed ‚Äî when Craig Federighi announced that <em>‚ÄùWe have a new programming language‚Äù</em>. This is weekly article number 150 ‚Äî looking back at what, for me and many others, has been <em>The Decade of Swift</em>.</p><h2>Type safety and expressiveness</h2><p>If you open up your macOS terminal app of choice and type <code>man swift</code> to bring up the manual entry for the Swift compiler, it‚Äôs described as a <em>‚Äúsafe, fast, and expressive general-purpose programming language‚Äù</em>.</p><p>While the idea of type safety and utilizing the compiler to more strictly verify the code that it‚Äôs processing isn‚Äôt something that‚Äôs unique to Swift, the combination of a very robust type system and a highly expressive syntax is one of the key aspects that instantly made Swift feel so refreshing to me and many others.</p><p>A core part of building any kind of software ‚Äî whether it‚Äôs an app, a framework, or a compiler for a programming language ‚Äî is constantly trying to find the right balance between various trade-offs. The question we have to keep asking ourselves again and again is: what potential downsides or obstacles are we willing to accept in order to achieve our goals, and how can we best utilize the strengths of our chosen approach?</p><p>What‚Äôs interesting about Swift‚Äôs strict, static type system is that it‚Äôs arguably both a trade-off and an asset at the same time. A strength in that it encourages us to write code that‚Äôs less prone to runtime errors, but also a potential weakness in that it requires us to spend more time designing our code up-front, which ‚Äî at least initially ‚Äî can have a negative impact on productivity and speed of iteration.</p><p>That‚Äôs why Swift‚Äôs expressive and very lightweight syntax (especially when compared to its predecessor, Objective-C), played such an important role since the very beginning, and why it‚Äôs increasingly becoming a very defining factor of the language as a whole. Take <a href="https://www.swiftbysundell.com/basics/enums">enums</a> for example. Not only do they let us model and handle finite sets of values using dedicated, strongly verified types ‚Äî they also make the available values much more discoverable, and enable us to write highly expressive <em>dot syntax</em>-based call sites:</p><pre class="splash"><code><span class="s-keyword">let</span> favorites = <span class="s-call">articles</span>(in: .<span class="s-dotAccess">favorites</span>)</code></pre><p>From the very first 1.0 release, to the great standard library API redesign of Swift 3, to the introduction of <a href="https://www.swiftbysundell.com/basics/codable/"><code>Codable</code></a> and <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a> in Swift 4, to how conformances to protocols like <code>Equatable</code> and <code>Hashable</code> can now be auto-synthesized as of Swift 4.1, to Swift 5.1‚Äôs <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">new DSL-focused features</a> ‚Äî every new release of Swift, so far, has improved and tweaked the language to enable new kinds of expressions and patterns to be constructed.</p><h2>New patterns and conventions</h2><p>That constant flow of new features and patterns has also resulted in a ton of new ideas, both from Apple and third party developers. While the rapid speed of iteration that we‚Äôve seen over Swift‚Äôs first five and a half years might‚Äôve occasionally been problematic ‚Äî especially in the early days, when several APIs and language features were drastically changed from one version to the next ‚Äî it‚Äôs also been a great source of inspiration and excitement for the community as a whole.</p><p>In many ways, a new programming language means a new beginning, and an opportunity for current patterns and conventions to be rethought and changed to leverage the new language‚Äôs features and strengths. While Swift was initially strongly based on Objective-C‚Äôs existing conventions, it didn‚Äôt take long for new best practices to start to form, and for the community to start developing a sense of what makes code <em>‚Äúswifty‚Äù</em>.</p><p>A big part of that is the increased use of Swift‚Äôs powerful type system to drive logic and to validate values. While Objective-C code tends to rely heavily on runtime validation using more free-form values, Swift-native patterns often focus on stronger types and relationships that can be enforced by the compiler. For example, let‚Äôs say that we wanted to write a function for sorting an array based on an element property ‚Äî in the early days of Swift, we might‚Äôve written something like this:</p><pre class="splash"><code><span class="s-comment">// We extend NSArray, rather than Swift's native Array type, to
// be able to leverage dynamic Objective-C features like Selectors:</span>
<span class="s-keyword">extension</span> <span class="s-type">NSArray</span> {
    <span class="s-comment">// Since we're calling an Objective-C API under the hood, we
    // can't retain type safety, and are forced to return [Any]:</span>
    <span class="s-keyword">func</span> sortedArrayBasedOn(key: <span class="s-type">String</span>) -&gt; [<span class="s-type">Any</span>] {
        <span class="s-keyword">return</span> <span class="s-call">sortedArray</span>(using: <span class="s-type">Selector</span>(key))
    }
}</code></pre><p>While being able to call into existing Objective-C APIs from Swift, and vice versa, was (and in many code bases, still is) incredibly important ‚Äî it quickly became quite clear that Swift needed its own set of conventions and API design styles, which resulted in the <a href="https://swift.org/documentation/api-design-guidelines">official API design guidelines</a>.</p><p>Using some of those modern Swift conventions and guidelines, here‚Äôs how we might refactor the above implementation ‚Äî to use Swift‚Äôs native <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths feature</a> rather than relying on dynamic strings, and to retain full type safety thanks to Swift‚Äôs powerful <a href="https://www.swiftbysundell.com/basics/generics">generics capabilities</a>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Array</span> {
    <span class="s-keyword">func</span> sorted&lt;T: <span class="s-type">Comparable</span>&gt;(
        by keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Element</span>, <span class="s-type">T</span>&gt;
    ) -&gt; <span class="s-type">Self</span> {
        <span class="s-call">sorted</span> { $0[keyPath: keyPath] &lt; $1[keyPath: keyPath] }
    }
}</code></pre><p>Using the above, we can now sort any array in a way that‚Äôs both fully type-safe, and highly expressive:</p><pre class="splash"><code><span class="s-keyword">let</span> mostPopular = articles.<span class="s-call">sorted</span>(by: \.<span class="s-property">numberOfViews</span>)</code></pre><p>Changes like the one above may initially seem minor in the grand scheme of things, but step by step there‚Äôs no doubt that Swift has fundamentally changed how most Apple-platform apps are built ‚Äî in that it has required us to rethink and restructure the way we write code, especially if we previously relied heavily on the very dynamic nature of Objective-C.</p><p>That trend is likely to grow even stronger, especially as Apple has now started to roll out Swift-only frameworks that uses the above type of modern conventions, such as Combine and SwiftUI ‚Äî both of which favor more minimalistic API designs and make heavy use of Swift‚Äôs type system, to the point where SwiftUI uses the type system itself to determine when to re-render a given view.</p><h2>A major cultural shift</h2><p>However, perhaps the biggest impact that Swift has had on the Apple developer community isn‚Äôt so much a technical one ‚Äî but rather a cultural one. While there was definitely a strong community surrounding Apple‚Äôs developer tools long before Swift, there‚Äôs no denying that the introduction of Swift drastically transformed and shifted that community‚Äôs focus.</p><p>Think about it, how often were the iOS and Mac developer communities referred to as <em>‚ÄúThe Objective-C community‚Äù</em>? Before Swift it seemed like the programming language being used was more of an implementation detail ‚Äî while frameworks like Cocoa, and the platforms themselves, were what defined the community and what brought people together. Compare that to now, at the end of 2019, when that same community has in many ways and circles been practically renamed to <em>‚ÄúThe Swift community‚Äù</em>.</p><p>However, what‚Äôs perhaps even more interesting than how the third party developer community has changed, is how Apple has changed their approach to how their Swift-based developer tools are built and evolved. After all, there was never an <em>‚ÄúObjective-C Evolution‚Äù</em> process that let anyone pitch ideas and changes to the language and its standard library. There was never a dedicated Objective-C forum on which both first- and third party tools could be discussed with Apple engineers.</p><p>The way Swift is (for the most part) designed and developed in the open is a huge shift compared to the very isolated and secretive ways in which Apple typically works ‚Äî and that shift has likely played a major part in making the community feel so attached to, and excited about, Swift as a language.</p><h2>What might the future have in store?</h2><p>Looking back at the 12 Swift updates that have been released since version 1.0, it‚Äôs quite clear that language-level ergonomics and user-facing features have been a major focus. The syntax has been streamlined and fine-tuned, the standard library has been made much more capable, generics are now a lot more powerful, and major sources of boilerplate have been eliminated. That in addition to achieving ABI and module stability, and much more.</p><p>However, going forward, I expect that focus to slightly change more towards the overall stability and speed of the Swift compiler itself. There‚Äôs no doubt that there‚Äôs a ton of potential improvements to be made within this area, which wouldn‚Äôt just make the process of writing and running Swift code much more enjoyable, but also continue to unlock new use cases for Swift ‚Äî for example to build just-in-time compiled plugins, for scripting, and to expand how Swift can be used for server-side development.</p><p>While Swift will most likely always be slower to compile compared to languages that perform far fewer compile-time checks and inference, more stable and capable tooling would definitely be welcome ‚Äî and we‚Äôve already seen tools like the <a href="https://github.com/apple/swift-llbuild"><code>llbuild</code></a> build system drastically improve compile times and the overall developer experience. A trend which I hope, and think, will continue.</p><p>A new <a href="https://swift.org/blog/new-diagnostic-arch-overview">diagnostics engine</a> is already being developed for Swift 5.2, which aims to improve the type checker and the warnings and error messages that the Swift compiler generates when an expression failed to compile ‚Äî which should be particularly useful when writing code that makes heavy use of generics, such as when building views using SwiftUI.</p><p>Besides improved tooling, I‚Äôm also really looking forward to the day when Swift includes some form of language-level support for asynchronous programming. While frameworks like <a href="https://www.swiftbysundell.com/basics/grand-central-dispatch">Grand Central Dispatch</a> and Combine are incredibly powerful, being able to express asynchronous operations using native language features (such as <code>async/await</code>, or any of the other approaches outlined by Chris Lattner in his <a href="https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782"><em>‚ÄúSwift Concurrency Manifesto‚Äù</em></a>) would most likely result in much simpler and more expressive asynchronous code.</p><h2>Conclusion</h2><p>Starting with the iPad, iPhone 4, and Grand Central Dispatch in 2010, and ending with SwiftUI and Combine in 2019 ‚Äî it‚Äôs been an incredibly exciting decade to be a developer for Apple‚Äôs platforms. Seeing so many new people joining our community from all around the world, and constantly seeing new ideas, patterns and conventions being shared through articles, videos, podcasts and conferences is absolutely wonderful.</p><p>There‚Äôs no doubt that both Swift and SwiftUI have been incredible energizers for the community at large, enabling new developers to write their very first app, for new patterns and tools to be invented, and for existing code bases to be improved. It may <em>just</em> be a programming language, but the way it has influenced our community, and fundamentally changed my work and my career, there‚Äôs no doubt in my mind that this has been <em>The Decade of Swift</em>.</p><p>I can‚Äôt wait to see what the next decade will bring, and how both Apple and the community will continue to improve, evolve and invent new tools that‚Äôll help us build even better software ‚Äî both for our existing devices and for brand new ones. I‚Äôll of course continue to cover Swift and its related technologies on this site and on <a href="https://www.swiftbysundell.com/podcast">the podcast</a> for as long as I possibly can, hopefully all throughout the 2020s, and I hope that you‚Äôll join me for that ride.</p><p>Thanks for reading, and Happy New Year! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/initializers-in-swift</guid><title>Initializers in Swift</title><description>Let‚Äôs take a look at one of the core aspects of object-oriented programming ‚Äî initialization. What characteristics should an initializer ideally have, and what sort of techniques could be useful in order to keep our initializers simple and predictable?</description><link>https://www.swiftbysundell.com/articles/initializers-in-swift</link><pubDate>Sun, 22 Dec 2019 20:45:00 +0100</pubDate><content:encoded><![CDATA[<p>Although Swift‚Äôs overall design incorporates several distinct programming paradigms, and makes it possible to write code using many different styles, it‚Äôs still substantially rooted in the object-oriented world.</p><p>From the way objects and values are constructed, to how inheritance and references still play a huge role in how Apple‚Äôs frameworks are designed, object-oriented concepts are a key part of Swift ‚Äî even though they are often mixed with influences from other paradigms, such as functional programming.</p><p>This week, let‚Äôs take a look at one of the core aspects of object-oriented programming ‚Äî initialization, which is the act of preparing an object or value for use. What characteristics should an initializer ideally have, and what sort of techniques and patterns could be useful in order to keep our initializers simple and predictable? Let‚Äôs dive right in.</p><h2>The simplicity of structs</h2><p>Arguably one of the most significant characteristics that we‚Äôre looking for in an initializer is <em>simplicity</em>. After all, the way an object or value is created often acts as our very first impression of its API ‚Äî so making that process as simple and as easy to understand as possible is definitely important.</p><p>One way that Swift assists us in achieving that sort of simplicity is through the way structs work ‚Äî specifically how their <em>memberwise initializers</em> enable us to easily create a new instance of a given type without requiring any custom logic.</p><p>For example, let‚Äôs say that our code base contains a <code>User</code> type that has the following properties ‚Äî some of which are required, and some of which are optional:</p><pre class="splash"><code><span class="s-keyword">struct</span> User {
    <span class="s-keyword">let</span> id = <span class="s-type">ID</span>()
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> address: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> cityName: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> emailAddress: <span class="s-type">String</span>?
}</code></pre><p>While Swift was always capable of auto-generating initializers matching a struct‚Äôs list of properties, as of Swift 5.1, those initializers no longer require us to pass values for the properties that are optional (or that have a default value) ‚Äî enabling us to create a new <code>User</code> instance like this:</p><pre class="splash"><code><span class="s-keyword">let</span> user = <span class="s-type">User</span>(id: <span class="s-type">User</span>.<span class="s-type">ID</span>(), name: <span class="s-string">"John"</span>)</code></pre><p>Not only does that act as a great convenience, and helps keep our call sites clean and simple, it also serves another important function ‚Äî it encourages us to keep our initializers free of logic and custom setup code.</p><p>By sticking with the initializers that the compiler generates for us, we‚Äôll automatically keep those initializers simple and side-effect-free, as assigning the passed values to our type‚Äôs various properties is the only work that they‚Äôll perform.</p><p class="info">Worth noting is that memberwise initializers are only available internally within the module that each given struct is defined in. While that may at first seem like an inconvenience (or an oversight, even), the benefit is that it ‚Äúforces‚Äù us to consider what we want each type‚Äôs public API to be, and to not have that API implicitly change if we modify a given type‚Äôs set of properties ‚Äî which would most likely be a breaking change for our API users.</p><h2>Ready from the start</h2><p>Since an initializer‚Äôs main job is to prepare its instance for use, the more complete and thorough we can make that setup process, the more robust our types are likely to become. Requiring additional data or dependencies to be assigned post-init often leads to misunderstandings and unintentional results, since it‚Äôs ‚Äî in most cases ‚Äî fair to assume that an instance is fully ready for use once it has been initialized.</p><p>Let‚Äôs say that we‚Äôre working on an app that includes some form of audio processing, and that we‚Äôve built an <code>AudioProcessor</code> class to perform that work. Currently, that type uses the <a href="https://www.swiftbysundell.com/articles/delegation-in-swift">delegate pattern</a> to enable its owner to decide whether or not a given file should actually be processed ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> AudioProcessingDelegate: <span class="s-type">AnyObject</span> {
    <span class="s-keyword">func</span> audioProcessor(<span class="s-keyword">_</span> processor: <span class="s-type">AudioProcessor</span>,
                        shouldProcessFile file: <span class="s-type">File</span>) -&gt; <span class="s-type">Bool</span>
}

<span class="s-keyword">class</span> AudioProcessor {
    <span class="s-keyword">weak var</span> delegate: <span class="s-type">AudioProcessingDelegate</span>?

    <span class="s-keyword">func</span> processAudioFiles(<span class="s-keyword">_</span> files: [<span class="s-type">File</span>]) <span class="s-keyword">throws</span> {
        <span class="s-keyword">for</span> file <span class="s-keyword">in</span> files {
            <span class="s-keyword">guard let</span> delegate = delegate <span class="s-keyword">else</span> {
                <span class="s-comment">// This code path should ideally never be entered</span>
                <span class="s-keyword">try</span> <span class="s-call">process</span>(file)
                <span class="s-keyword">continue</span>
            }

            <span class="s-keyword">let</span> shouldProcess = delegate.<span class="s-call">audioProcessor</span>(<span class="s-keyword">self</span>,
                shouldProcessFile: file
            )

            <span class="s-keyword">if</span> shouldProcess {
                <span class="s-keyword">try</span> <span class="s-call">process</span>(file)
            }
        }
    }
    
    ...
}</code></pre><p>While the delegate pattern is incredibly useful in many different circumstances, the way we‚Äôve implemented it above does come with a quite significant downside. Since we can‚Äôt guarantee that a delegate has been assigned by the time the <code>processAudioFiles</code> method is called, we‚Äôre forced to include a code path that causes all files to be processed whenever a delegate is missing ‚Äî which will most likely lead to unintended results, at least in some cases.</p><p>Thankfully, like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/delegation-in-swift">‚ÄúDelegation in Swift‚Äù</a></em>, using a weakly-referenced protocol isn‚Äôt the <em>only</em> way to implement the delegate pattern. When we‚Äôre dealing with a situation in which our delegation logic is required in order to perform an object‚Äôs work, it ideally shouldn‚Äôt be assigned post-init ‚Äî but rather be a part of the initializer itself. That way, we can be 100% sure that all of our required dependencies will be available right from the start.</p><p>One way to do just that in this case is to change our protocol-based approach from before into a closure-based one instead ‚Äî which also results in a much more compact implementation:</p><pre class="splash"><code><span class="s-keyword">class</span> AudioProcessor {
    <span class="s-keyword">private let</span> predicate: (<span class="s-type">File</span>) -&gt; <span class="s-type">Bool</span>

    <span class="s-keyword">init</span>(predicate: <span class="s-keyword">@escaping</span> (<span class="s-type">File</span>) -&gt; <span class="s-type">Bool</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">predicate</span> = predicate
    }

    <span class="s-keyword">func</span> processAudioFiles(<span class="s-keyword">_</span> files: [<span class="s-type">File</span>]) <span class="s-keyword">throws</span> {
        <span class="s-keyword">for</span> file <span class="s-keyword">in</span> files <span class="s-keyword">where</span> predicate(file) {
            <span class="s-keyword">try</span> <span class="s-call">process</span>(file)
        }
    }
    
    ...
}</code></pre><p class="info">A simple closure might be all that we need in the above situation, but if we wanted to take things one step further, we could‚Äôve also opted for a more powerful predicate implementation ‚Äî like the one from <a href="https://www.swiftbysundell.com/articles/predicates-in-swift">‚ÄúPredicates in Swift‚Äù</a>.</p><p>Regardless of whether we choose a protocol, a closure, or some other form of abstraction, the goal remains the same ‚Äî to be able to guarantee that our objects are as fully configured as possible by the time their initializer returns. The more we can avoid requiring any form of post-init setup, the easier to understand our types usually become.</p><h2>Avoiding complexity and side effects</h2><p>Another factor that often has a huge impact on our types‚Äô ease of use is how predictable their underlying implementations are. If we can make the results of calling our APIs match user expectations ‚Äî then we can avoid misunderstandings, and ultimately, bugs.</p><p>When it comes to initializers in particular, avoiding all sorts of side-effects is often key to maintaining a high degree of predictability. For example, the following <code>Request</code> type‚Äôs initializer doesn‚Äôt only set up its instance, it also starts the underlying <code>URLSessionDataTask</code> ‚Äî which might be quite unexpected:</p><pre class="splash"><code><span class="s-keyword">class</span> Request&lt;Value: <span class="s-type">Codable</span>&gt; {
    <span class="s-keyword">private let</span> task: <span class="s-type">URLSessionDataTask</span>

    <span class="s-keyword">init</span>(url: <span class="s-type">URL</span>,
         session: <span class="s-type">URLSession</span> = .<span class="s-dotAccess">shared</span>,
         handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>) {
        task = session.<span class="s-call">dataTask</span>(with: url) {
            data, response, error <span class="s-keyword">in</span>
            ...
            <span class="s-call">handler</span>(result)
        }

        task.<span class="s-call">resume</span>()
    }

    ...
}</code></pre><p>Whenever we have to use the word <em>‚Äúand‚Äù</em> when explaining what one of our initializers does, chances are high that it causes some form of side-effect. For example, the above initializer might be described as <em>‚ÄúSetting up <strong>and</strong> performing a given request‚Äù</em> ‚Äî and while that may seem completely harmless at first, it‚Äôll most likely make our initializer way too complex, and less flexible ‚Äî as we give our API users no control over when and how each request is actually performed.</p><p>Instead, let‚Äôs make our initializer only set up a <code>Request</code> instance with its required property values, and then create a new, dedicated method for performing it ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> Request&lt;Value: <span class="s-type">Codable</span>&gt; {
    <span class="s-keyword">private let</span> url: <span class="s-type">URL</span>
    <span class="s-keyword">private let</span> session: <span class="s-type">URLSession</span>
    <span class="s-keyword">private var</span> task: <span class="s-type">URLSessionDataTask</span>?

    <span class="s-keyword">init</span>(url: <span class="s-type">URL</span>, session: <span class="s-type">URLSession</span> = .<span class="s-dotAccess">shared</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">url</span> = url
        <span class="s-keyword">self</span>.<span class="s-property">session</span> = session
    }

    <span class="s-keyword">func</span> perform(then handler: <span class="s-keyword">@escaping</span> (<span class="s-type">Result</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>) {
        task?.<span class="s-call">cancel</span>()

        <span class="s-keyword">let</span> task = session.<span class="s-call">dataTask</span>(with: url) {
            [<span class="s-keyword">weak self</span>] data, <span class="s-keyword">_</span>, error <span class="s-keyword">in</span>
            ...
            <span class="s-call">handler</span>(result)
            <span class="s-keyword">self</span>?.<span class="s-property">task</span> = <span class="s-keyword">nil</span>
        }

        <span class="s-keyword">self</span>.<span class="s-property">task</span> = task
        task.<span class="s-call">resume</span>()
    }

    ...
}</code></pre><p>The above change doesn‚Äôt only give each call site the power to freely decide when to perform the requests they create, we‚Äôve also made it possible to reuse a single <code>Request</code> instance within each given context ‚Äî since a new task is now created (and any previous one cancelled) each time that our <code>perform</code> method is called.</p><p>Another potential source of unpredictability is when a given type‚Äôs initializer performs some form of internal setup that varies in terms of complexity and execution time. For example, the following <code>TagIndex</code> type is initialized with an array of <code>Note</code> values, that it then iterates over in order to index them according to their assigned tags:</p><pre class="splash"><code><span class="s-keyword">struct</span> TagIndex {
    <span class="s-keyword">private var</span> notes = [<span class="s-type">Tag</span> : [<span class="s-type">Note</span>]]()

    <span class="s-keyword">init</span>(notes: [<span class="s-type">Note</span>]) {
        <span class="s-keyword">for</span> note <span class="s-keyword">in</span> notes {
            <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> note.<span class="s-property">tags</span> {
                <span class="s-keyword">self</span>.<span class="s-property">notes</span>[tag, default: []].<span class="s-call">append</span>(note)
            }
        }
    }

    ...
}</code></pre><p>Again, the above approach might not seem problematic ‚Äî but the fact that we‚Äôre hiding an <code>O(n)</code> iteration behind what looks like a constant-time initializer isn‚Äôt really a great design ‚Äî since calling it with a large amount of notes within some form of critical path will most likely turn it into a bottleneck.</p><p>Just like how we before moved our <code>Request</code> type‚Äôs main work out from its initializer, let‚Äôs do the same thing here, and define a separate method dedicated to performing our indexing work:</p><pre class="splash"><code><span class="s-keyword">struct</span> TagIndex {
    <span class="s-keyword">private var</span> notes = [<span class="s-type">Tag</span> : [<span class="s-type">Note</span>]]()

    <span class="s-keyword">mutating func</span> index(<span class="s-keyword">_</span> notes: [<span class="s-type">Note</span>]) {
        <span class="s-keyword">for</span> note <span class="s-keyword">in</span> notes {
            <span class="s-keyword">for</span> tag <span class="s-keyword">in</span> note.<span class="s-property">tags</span> {
                <span class="s-keyword">self</span>.<span class="s-property">notes</span>[tag, default: []].<span class="s-call">append</span>(note)
            }
        }
    }
    
    ...
}</code></pre><p>It‚Äôs a subtle change, but it‚Äôs now crystal clear that calling the <code>index</code> method causes indexing to performed, rather than having that be an implicit side-effect of initializing our type.</p><p>However, just like how we before wanted to avoid requiring any post-init calls in order to make a type usable, it would be great if we could find a way to perform our indexing process in a way that‚Äôs both automatic, and predictable.</p><p>One way that we could do that is by using a <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory method</a>, which we can name in a way that makes it obvious that calling that method doesn‚Äôt only create a new <code>TagIndex</code> instance, but also indexes the notes that were passed into it:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TagIndex</span> {
    <span class="s-keyword">static func</span> makeByIndexing(<span class="s-keyword">_</span> notes: [<span class="s-type">Note</span>]) -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">var</span> instance = <span class="s-type">Self</span>()
        instance.<span class="s-call">index</span>(notes)
        <span class="s-keyword">return</span> instance
    }
}</code></pre><p>Using static factory methods can be a great way to let us keep our initializer implementations simple, while still making it as easy as possible to create and configure new instances of our types.</p><h2>Conclusion</h2><p>By keeping our initializers free of side-effects, and by making the process of configuring our types as simple and predictable as possible, we not only make our types easier to understand, but also give them a much greater degree of flexibility.</p><p>However, if we make our initializers too simple, that can sometimes result in quite ambiguous setups that require a fair amount of post-init configuration ‚Äî which isn‚Äôt ideal. Like with so many other things, writing great initializers becomes a balancing act between simplicity and completeness ‚Äî and by using techniques like closures and static factory methods, we can often get closer to achieving that perfect balance.</p><p>What do you think? How do you like your initializers to work, and what kind of principles do you tend to follow when configuring your objects and values? Let me know ‚Äî along with any questions, comments and feedback that you might have ‚Äî either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/maintaining-model-consistency-in-swift</guid><title>Maintaining model consistency in Swift</title><description>This week, let‚Äôs take a look at how we can improve the internal consistency within each of our core data models, and how doing so can let us establish a much stronger foundation for our codebase as a whole.</description><link>https://www.swiftbysundell.com/articles/maintaining-model-consistency-in-swift</link><pubDate>Sun, 15 Dec 2019 15:00:00 +0100</pubDate><content:encoded><![CDATA[<p>When designing the model layer of any app or system, establishing a <em>‚Äùsingle source of truth‚Äù</em> for each state and piece of data that we‚Äôre dealing with is often essential in order to make our logic behave predictably.</p><p>However, ensuring that each state is stored in just a single place can often be easier said than done ‚Äî and it‚Äôs very common to end up with bugs and errors resulting from inconsistent model data, especially when such models are passed around and mutated in several different places.</p><p>While some of those errors are bound to happen outside of the models themselves, this week, let‚Äôs take a look at how we can improve the internal consistency within each of our models ‚Äî and how doing so can let us establish a much stronger foundation for our codebase as a whole.</p><h2>Deriving dependent states</h2><p>The overall model layer of any given system can most often be described as a hierarchy, in which more high-level pieces of data depend on some form of underlying state. As a simple example, let‚Äôs say that we‚Äôre working on a contact management app, and that we have a <code>Contact</code> model which contains each person‚Äôs contact information ‚Äî such as their name and email address:</p><pre class="splash"><code><span class="s-keyword">struct</span> Contact {
    <span class="s-keyword">let</span> id: <span class="s-type">ID</span>
    <span class="s-keyword">var</span> firstName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> lastName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> fullName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> emailAddress: <span class="s-type">String</span>
    ...
}</code></pre><p>At first glance, the above might look like any standard data model, but there is actually a substantial risk for it to become inconsistent. Since we have three separate properties for <code>firstName</code>, <code>lastName</code> and <code>fullName</code>, we‚Äôre going to always have to remember to update a contact‚Äôs <code>fullName</code> whenever we make any changes to either the <code>firstName</code> or <code>lastName</code> property ‚Äî otherwise, we‚Äôll end up ambiguous information.</p><p>Since <code>fullName</code> is, at the end of the day, a convenience ‚Äî a higher-level state that makes building our UI simpler ‚Äî let‚Äôs make it derivative. Rather than implementing it as a separate, stored property, let‚Äôs turn it into a computed one instead:</p><pre class="splash"><code><span class="s-keyword">struct</span> Contact {
    <span class="s-keyword">let</span> id: <span class="s-type">ID</span>
    <span class="s-keyword">var</span> firstName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> lastName: <span class="s-type">String</span>
    <span class="s-keyword">var</span> fullName: <span class="s-type">String</span> { <span class="s-string">"</span>\(firstName) \(lastName)<span class="s-string">"</span> }
    <span class="s-keyword">var</span> emailAddress: <span class="s-type">String</span>
    ...
}</code></pre><p>That way, we no longer have to worry about our model becoming inconsistent, since a contact‚Äôs <code>fullName</code> will now be re-computed each time that it‚Äôs accessed according to the current <code>firstName</code> and <code>lastName</code>.</p><p>However, always re-computing a dependent state each time that it gets accessed is not always practical ‚Äî especially if that state depends on a potentially large collection of elements, or if the required computation involves a bit more than simply combining a few underlying values.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">‚ÄúUtilizing value semantics in Swift‚Äù</a></em>, in those situations, maintaining a separate stored property might again be the best approach ‚Äî but if we prevent that property from being externally mutated, and if we make it auto-update whenever its underlying state changes, then we can still ensure that its containing model remains consistent.</p><p>Here‚Äôs how we might use a <a href="https://www.swiftbysundell.com/articles/property-observers-in-swift">property observer</a> to do that for a <code>Leaderboard</code> model, which contains high score entries for the top players of a game, as well as the current average score among those players:</p><pre class="splash"><code><span class="s-keyword">struct</span> Leaderboard {
    <span class="s-keyword">typealias</span> Entry = (name: <span class="s-type">String</span>, score: <span class="s-type">Int</span>)

    <span class="s-keyword">var</span> entries: [<span class="s-type">Entry</span>] {
        <span class="s-comment">// Each time that our array of entries gets modified, we
        // re-compute the current average score:</span>
        <span class="s-keyword">didSet</span> { <span class="s-call">updateAverageScore</span>() }
    }
    
    <span class="s-comment">// By marking our property as 'private(set)', we prevent it
    // from being mutated outside of this type:</span>
    <span class="s-keyword">private(set) var</span> averageScore = <span class="s-number">0</span>

    <span class="s-keyword">init</span>(entries: [<span class="s-type">Entry</span>]) {
        <span class="s-keyword">self</span>.<span class="s-property">entries</span> = entries
        <span class="s-comment">// Property observers don't get triggered as part of
        // initializers, so we have to call our update method
        // manually here:</span>
        <span class="s-call">updateAverageScore</span>()
    }

    <span class="s-keyword">private mutating func</span> updateAverageScore() {
        <span class="s-keyword">guard</span> !entries.<span class="s-property">isEmpty</span> <span class="s-keyword">else</span> {
            averageScore = <span class="s-number">0</span>
            <span class="s-keyword">return</span>
        }

        <span class="s-keyword">let</span> totalScore = entries.<span class="s-call">reduce</span>(into: <span class="s-number">0</span>) { score, entry <span class="s-keyword">in</span>
            score += entry.<span class="s-property">score</span>
        }

        averageScore = totalScore / entries.<span class="s-property">count</span>
    }
}</code></pre><p>The patterns used above don‚Äôt only improve the consistency of our models, they also make those models easier to use and understand ‚Äî since we no longer have to be aware of rules like <em>‚Äúalways remember to update X when you modify Y‚Äù</em> ‚Äî as that sort of logic is now baked into the models themselves.</p><h2>Consistent collections</h2><p>While maintaining a 1:1 relationship between two pieces of state can be challenging enough, things get even trickier when we have to ensure that multiple collections remain consistent with each other. Going back to the example of a contact management app from before, let‚Äôs say that we‚Äôre now building a <code>ContactList</code> class ‚Äî which will store a set of contacts, while also enabling those contacts to be organized into groups, and to be marked as favorites:</p><pre class="splash"><code><span class="s-keyword">class</span> ContactList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> contacts = [<span class="s-type">Contact</span>.<span class="s-type">ID</span> : <span class="s-type">Contact</span>]()
    <span class="s-keyword">var</span> favoriteIDs = <span class="s-type">Set</span>&lt;<span class="s-type">Contact</span>.<span class="s-type">ID</span>&gt;()
    <span class="s-keyword">var</span> groups = [<span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span> : <span class="s-type">Contact</span>.<span class="s-type">Group</span>]()

    <span class="s-keyword">init</span>(name: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">name</span> = name
    }
}</code></pre><p class="info">Above we‚Äôre making use of <a href="https://www.swiftbysundell.com/articles/namespacing-swift-code-with-nested-types">nested types</a> in order to make types like <code>Group</code> and <code>Name</code> more contextual and <a href="https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code">‚Äúself-documenting‚Äù</a>.</p><p>Similar to the earlier example in which we were required to manually keep a contact‚Äôs names in sync, the above model also makes each of its call sites responsible for keeping it consistent. For example, when removing a contact, we also have to remember to remove its ID from our set of <code>favoriteIDs</code> ‚Äî and when renaming a group, we always have to update its key within the <code>groups</code> dictionary as well.</p><p>Both of the two functions below fail to do that, and even though they might look perfectly valid, they‚Äôre both causing the <code>ContactList</code> they‚Äôre mutating to become inconsistent:</p><pre class="splash"><code><span class="s-keyword">func</span> removeContact(<span class="s-keyword">_</span> contact: <span class="s-type">Contact</span>) {
    <span class="s-comment">// If the removed contact was also added as a favorite, its
    // ID will still remain in that list, even after it was removed.</span>
    contactList.<span class="s-property">contacts</span>[contact.<span class="s-property">id</span>] = <span class="s-keyword">nil</span>
}

<span class="s-keyword">func</span> renameGroup(named currentName: <span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span>,
                 to newName: <span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span>) {
    <span class="s-comment">// The renamed group's key will now be incorrect, since
    // it's still referring to the group's previous name.</span>
    contactList.<span class="s-property">groups</span>[currentName]?.name = newName
}</code></pre><p>An initial idea on how to avoid the above kind of inconsistencies might be to take the same <code>private(set)</code> approach that we used on our <code>Leaderboard</code> model from before, and prevent our collections from being mutated outside of the <code>ContactList</code> type:</p><pre class="splash"><code><span class="s-keyword">class</span> ContactList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">private(set) var</span> contacts = [<span class="s-type">Contact</span>.<span class="s-type">ID</span> : <span class="s-type">Contact</span>]()
    <span class="s-keyword">private(set) var</span> favoriteIDs = <span class="s-type">Set</span>&lt;<span class="s-type">Contact</span>.<span class="s-type">ID</span>&gt;()
    <span class="s-keyword">private(set) var</span> groups = [<span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span> : <span class="s-type">Contact</span>.<span class="s-type">Group</span>]()
    ...
}</code></pre><p>However, in this case we actually need to be able to mutate our collections <em>somehow</em> ‚Äî so the above approach would require us to replicate several of our underlying collections‚Äô APIs, in order to make mutations like adding and removing contacts possible:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span> {
    <span class="s-keyword">func</span> add(<span class="s-keyword">_</span> contact: <span class="s-type">Contact</span>) {
        contacts[contact.<span class="s-property">id</span>] = contact
    }

    <span class="s-keyword">func</span> remove(<span class="s-keyword">_</span> contact: <span class="s-type">Contact</span>) {
        contacts[contact.<span class="s-property">id</span>] = <span class="s-keyword">nil</span>
        favoriteIDs.<span class="s-call">remove</span>(contact.<span class="s-property">id</span>)
    }

    <span class="s-keyword">func</span> renameGroup(named currentName: <span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span>,
                     to newName: <span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-type">Name</span>) {
        <span class="s-keyword">guard var</span> group = groups.<span class="s-call">removeValue</span>(forKey: currentName) <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span>
        }

        group.<span class="s-property">name</span> = newName
        groups[newName] = group
    }
}</code></pre><p>The above might work as long as we only have to mutate our collections in very simple ways, and as long as we won‚Äôt add any new pieces of data to our model, but it‚Äôs not a very flexible solution overall. Requiring a brand new API to be created for each mutation is, in general, not a great design ‚Äî so let‚Äôs see if we can find a more dynamic and future-proof approach.</p><p>If we think about it, keeping our <code>ContactList</code> data in sync really just requires us to be able to react to any changes to the property that‚Äôs also used as an element‚Äôs key (<code>id</code> in the case of <code>Contact</code> and <code>name</code> in the case of <code>Contact.Group</code>), and to be able to perform an update whenever an element was removed (so that we can make sure that no removed contacts still remain in the <code>favoriteIDs</code> set).</p><p>Let‚Äôs add both of those two capabilities by implementing a very lightweight wrapper around <code>Dictionary</code>. Our wrapper, let‚Äôs call it <code>Storage</code>, will use Swift‚Äôs <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths mechanism</a> in order to keep our keys in sync ‚Äî and will also enable us to attach a <code>keyRemovalHandler</code> closure to get notified whenever a key was removed:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span> {
    <span class="s-keyword">struct</span> Storage&lt;Key: <span class="s-type">Hashable</span>, Value&gt; {
        <span class="s-keyword">fileprivate var</span> keyRemovalHandler: ((<span class="s-type">Key</span>) -&gt; <span class="s-type">Void</span>)?

        <span class="s-keyword">private let</span> keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Key</span>&gt;
        <span class="s-keyword">private var</span> values = [<span class="s-type">Key</span> : <span class="s-type">Value</span>]()

        <span class="s-keyword">fileprivate init</span>(keyPath: <span class="s-type">KeyPath</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Key</span>&gt;) {
            <span class="s-keyword">self</span>.<span class="s-property">keyPath</span> = keyPath
        }
    }
}</code></pre><p class="info">Our initializer and <code>keyRemovalHandler</code> are marked as <code>fileprivate</code> in order to prevent instances of our new <code>Storage</code> type to be created outside of the file that <code>ContactList</code> is defined in, further strengthening the consistency of our model code.</p><p>To make <code>Storage</code> behave like a <em>real</em> Swift collection, we have two options. We could either make it <a href="https://www.swiftbysundell.com/articles/creating-custom-collections-in-swift">conform to the full <code>Collection</code> protocol</a> or, if we only need to be able to iterate over it, we could simply make it conform to <code>Sequence</code> ‚Äî by forwarding the call to <code>makeIterator()</code> to its underlying dictionary:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span>.<span class="s-type">Storage</span>: <span class="s-type">Sequence</span> {
    <span class="s-keyword">func</span> makeIterator() -&gt; <span class="s-type">Dictionary</span>&lt;<span class="s-type">Key</span>, <span class="s-type">Value</span>&gt;.<span class="s-type">Iterator</span> {
        values.<span class="s-call">makeIterator</span>()
    }
}</code></pre><p>With the above in place, we will still be able to write <code>for</code> loops over our collections, and to use APIs like <code>forEach</code>, <code>map</code> and <code>filter</code> on them ‚Äî just like when using <code>Dictionary</code> directly.</p><p>Next, to enable <code>Storage</code> to be mutated, we‚Äôre going to add a <a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift"><code>subscript</code> implementation</a> that both ensures that an element‚Äôs key gets updated in case the property its key is based on was changed, and that also calls our <code>keyRemovalHandler</code> when a key was removed:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span>.<span class="s-type">Storage</span> {
    <span class="s-keyword">subscript</span>(key: <span class="s-type">Key</span>) -&gt; <span class="s-type">Value</span>? {
        <span class="s-keyword">get</span> { values[key] }
        <span class="s-keyword">set</span> {
            <span class="s-keyword">guard let</span> newValue = newValue <span class="s-keyword">else</span> {
                <span class="s-keyword">return</span> <span class="s-call">remove</span>(key)
            }

            <span class="s-keyword">let</span> newKey = newValue[keyPath: keyPath]
            values[newKey] = newValue

            <span class="s-keyword">if</span> key != newKey {
                <span class="s-call">remove</span>(key)
            }
        }
    }

    <span class="s-keyword">private mutating func</span> remove(<span class="s-keyword">_</span> key: <span class="s-type">Key</span>) {
        values[key] = <span class="s-keyword">nil</span>
        keyRemovalHandler?(key)
    }
}</code></pre><p>Just like that, our collection wrapper is done, and we‚Äôre ready to update <code>ContactList</code> to use it ‚Äî by storing our contacts and groups using our new type, and by registering a <code>keyremovalHandler</code> that ensures that our <code>favoriteIDs</code> set stays in sync with our collection of contacts:</p><pre class="splash"><code><span class="s-keyword">class</span> ContactList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> contacts = <span class="s-type">Storage</span>(keyPath: \<span class="s-type">Contact</span>.<span class="s-property">id</span>)
    <span class="s-keyword">var</span> favoriteIDs = <span class="s-type">Set</span>&lt;<span class="s-type">Contact</span>.<span class="s-type">ID</span>&gt;()
    <span class="s-keyword">var</span> groups = <span class="s-type">Storage</span>(keyPath: \<span class="s-type">Contact</span>.<span class="s-type">Group</span>.<span class="s-property">name</span>)

    <span class="s-keyword">init</span>(name: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">name</span> = name

        contacts.<span class="s-property">keyRemovalHandler</span> = { [<span class="s-keyword">weak self</span>] key <span class="s-keyword">in
            self</span>?.<span class="s-property">favoriteIDs</span>.<span class="s-call">remove</span>(key)
        }
    }
}</code></pre><p class="info">Note how Swift is able to infer the generic <code>Key</code> and <code>Value</code> types of our <code>Storage</code> instances based on the key paths that are passed into them ‚Äî beautiful!</p><p>With our new implementation, we‚Äôll still be able mutate our collections by adding and removing values, just like when using <code>Dictionary</code> directly ‚Äî only now we‚Äôre ensuring that our data remains consistent, completely automatically.</p><p>As an added bonus, since we now have a custom collection type in place, we could go one step further and make it <em>even nicer</em> to use ‚Äî by adding convenience APIs for adding and removing values without having to worry about what key to use:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ContactList</span>.<span class="s-type">Storage</span> {
    <span class="s-keyword">mutating func</span> add(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) {
        <span class="s-keyword">let</span> key = value[keyPath: keyPath]
        values[key] = value
    }

    <span class="s-keyword">mutating func</span> remove(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) {
        <span class="s-keyword">let</span> key = value[keyPath: keyPath]
        <span class="s-call">remove</span>(key)
    }
}</code></pre><p>Using the above APIs and our <code>subscript</code> implementation from before, we‚Äôre now free to decide how we want to add and remove values within each situation, without impacting the consistency of our model in any way:</p><pre class="splash"><code><span class="s-comment">// Adding values:</span>
contactList.<span class="s-property">contacts</span>[contact.<span class="s-property">id</span>] = contact
contactList.<span class="s-property">contacts</span>.<span class="s-call">add</span>(contact)

<span class="s-comment">// Removing values:</span>
contactList.<span class="s-property">contacts</span>[contact.<span class="s-property">id</span>] = <span class="s-keyword">nil</span>
contactList.<span class="s-property">contacts</span>.<span class="s-call">remove</span>(contact)</code></pre><p>While writing a custom collection isn‚Äôt always appropriate, whenever we want to add new behaviors to one of the data structures that the standard library offers, creating lightweight wrappers that are each tailored to a very specific domain can be a great approach.</p><h2>Conclusion</h2><p>In many ways, in order to make a code base really robust and capable, we have to start by making its core data models as predictable and consistent as we possibly can ‚Äî since those models often act as the foundation on top of which the rest of our code base is built.</p><p>By not requiring various states to be synced manually, and by preventing inconsistent states from being stored in the first place, we not only end up with a much stronger foundation ‚Äî but one that‚Äôs often easier to work with as well, as our model architecture ends up doing much of that synchronization work for us.</p><p>What do you think? How do you currently ensure that your models remain as consistent as possible, and will any of the techniques covered in this article help you get closer to that goal? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/predicates-in-swift</guid><title>Predicates in Swift</title><description>Predicates can enable us to filter various collections in ways that are incredibly flexible. Let‚Äôs take a look at how we could construct powerful, type-safe predicates using closures, generics, and operators.</description><link>https://www.swiftbysundell.com/articles/predicates-in-swift</link><pubDate>Sun, 8 Dec 2019 22:00:00 +0100</pubDate><content:encoded><![CDATA[<p>Even though modern apps tend to rely heavily on some form of server component in order to load their data and perform various kinds of work, it‚Äôs also incredibly common for an app to have to deal with significant amounts of locally stored data as well.</p><p>Not only do we have to come up with efficient and secure ways to store such data, we also have to design APIs for accessing it ‚Äî and to ensure that those are flexible enough to let us keep iterating on new features and capabilities in a smooth and productive manner.</p><p>This week, let‚Äôs take a look at how we could leverage the power of predicates to achieve a great degree of flexibility when it comes to working with local data, and how Swift enables us to model predicates in a way that‚Äôs both highly expressive and very powerful.</p><h2>Filtering a collection of models</h2><p>As an example, let‚Äôs say that we‚Äôre building a classic todo app that lets our users organize their tasks and todo items using multiple lists ‚Äî each of which is represented by a <code>TodoList</code> instance.</p><p>Since we want to enable our users to easily filter their tasks in various ways ‚Äî we‚Äôve created several APIs that let us query a list‚Äôs items based on a number of different conditions, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Date</span> {
    <span class="s-keyword">static var</span> now: <span class="s-type">Date</span> { <span class="s-type">Date</span>() }
}

<span class="s-keyword">struct</span> TodoList {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">private var</span> items = [<span class="s-type">TodoItem</span>]()

    <span class="s-keyword">func</span> futureItems(basedOnDate date: <span class="s-type">Date</span> = .<span class="s-dotAccess">now</span>) -&gt; [<span class="s-type">TodoItem</span>] {
        items.<span class="s-call">filter</span> {
            !$0.<span class="s-property">isCompleted</span> &amp;&amp; $0.<span class="s-property">dueDate</span> &gt; date
        }
    }

    <span class="s-keyword">func</span> overdueItems(basedOnDate date: <span class="s-type">Date</span> = .<span class="s-dotAccess">now</span>) -&gt; [<span class="s-type">TodoItem</span>] {
        items.<span class="s-call">filter</span> {
            !$0.<span class="s-property">isCompleted</span> &amp;&amp; $0.<span class="s-property">dueDate</span> &lt; date
        }
    }

    <span class="s-keyword">func</span> itemsTaggedWith(<span class="s-keyword">_</span> tag: <span class="s-type">Tag</span>) -&gt; [<span class="s-type">TodoItem</span>] {
        items.<span class="s-call">filter</span> { $0.<span class="s-property">tags</span>.<span class="s-call">contains</span>(tag) }
    }
}</code></pre><p class="info">Note that simply calling <code>filter</code> on an array is often not the most efficient way to search through a (potentially large) collection of values. However, we‚Äôll stick with <code>filter</code> in this article for simplicity. For more advanced ways of structuring data, check out <a href="https://www.swiftbysundell.com/articles/picking-the-right-data-structure-in-swift">‚ÄúPicking the right data structure in Swift‚Äù</a>.</p><p>While there‚Äôs nothing wrong with the above APIs, it would be nice to have a slightly greater degree of flexibility as we keep iterating on our app and as more filtering features are added. As our <code>TodoList</code> type is currently designed, every time we want to add a new way of filtering our data, we have to go back and add a brand new API.</p><p>Let‚Äôs see if we instead can find a way to let the <em>consumers</em> of our data decide exactly how they‚Äôd like to filter it. That way we would only have to build and maintain a single API, while also enabling new features to be built without any modifications to our underlying datastore.</p><h2>A case for predicates</h2><p>One way that we could achieve such a level of flexibility is by using Foundation‚Äôs <code>NSPredicate</code> class, which leverages the dynamic nature of Objective-C in order to let us filter collections of data using string-based queries. For example, here‚Äôs how we could use an <code>NSPredicate</code> to retrieve all overdue items from an array of <code>TodoItem</code> values:</p><pre class="splash"><code><span class="s-comment">// Before we can apply a predicate to our array, we must
// first convert it into an Objective-C-based NSArray:</span>
<span class="s-keyword">let</span> array = <span class="s-type">NSArray</span>(array: items)

<span class="s-keyword">let</span> overdueItems = array.<span class="s-call">filtered</span>(using: <span class="s-type">NSPredicate</span>(
    format: <span class="s-string">"isCompleted == false &amp;&amp; dueDate &lt; %@"</span>,
    <span class="s-type">NSDate</span>()
))</code></pre><p>While <code>NSPredicate</code> is incredibly powerful, it does come with a fair amount of downsides when used in Swift. First of all, since queries are written as strings, they don‚Äôt come with any sort of compile-time safety ‚Äî as there is no way for the compiler to validate our property names, or even verify that our queries are syntactically correct.</p><p>Using Objective-C based APIs, like <code>NSPredicate</code> and <code>NSArray</code>, also requires us to turn our data models into classes that inherit from <code>NSObject</code> ‚Äî which would prevents us from using value semantics, and require us to conform to Objective-C conventions, like enabling dynamic string-based access to our properties.</p><p>So while the <em>idea and concept</em> of predicates is incredibly appealing, let‚Äôs see if we can implement them in a more <em>‚ÄúSwifty‚Äù</em> way. After all, implementation details aside, a predicate is just a function that returns a <code>Bool</code> for a given value ‚Äî and could, in the very simplest of forms, be modeled like this:</p><pre class="splash"><code><span class="s-keyword">typealias</span> Predicate&lt;T&gt; = (<span class="s-type">T</span>) -&gt; <span class="s-type">Bool</span></code></pre><p>While we could definitely define our predicates as free-form functions and closures, let‚Äôs instead create a simple wrapping struct that takes a closure and stores it as its <em>matcher</em>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Predicate&lt;Target&gt; {
    <span class="s-keyword">var</span> matches: (<span class="s-type">Target</span>) -&gt; <span class="s-type">Bool</span>

    <span class="s-keyword">init</span>(matcher: <span class="s-keyword">@escaping</span> (<span class="s-type">Target</span>) -&gt; <span class="s-type">Bool</span>) {
        matches = matcher
    }
}</code></pre><p class="info">If the above design looks similar, it might be because we used the exact same setup to implement plugins in last week‚Äôs article, <a href="https://www.swiftbysundell.com/articles/making-swift-code-extensible-through-plugins">‚ÄúMaking Swift code extensible through plugins‚Äù</a>.</p><p>With the above in place, we can now go back to our <code>TodoList</code> type and replace all of our previous filtering APIs with just a single one ‚Äî that takes a <code>Predicate</code> and passes its matching closure to <code>items.filter</code> in order to return the items that we‚Äôre looking for:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TodoList</span> {
    <span class="s-keyword">func</span> items(matching predicate: <span class="s-type">Predicate</span>&lt;<span class="s-type">TodoItem</span>&gt;) -&gt; [<span class="s-type">TodoItem</span>] {
        items.<span class="s-call">filter</span>(predicate.<span class="s-property">matches</span>)
    }
}</code></pre><p>Now, whenever we want to filter a <code>TodoList</code> based on any sort of query, we can now easily do so by calling the above method:</p><pre class="splash"><code><span class="s-keyword">let</span> list: <span class="s-type">TodoList</span> = ...

<span class="s-keyword">let</span> overdueItems = list.<span class="s-call">items</span>(matching: <span class="s-type">Predicate</span> {
    !$0.<span class="s-property">isCompleted</span> &amp;&amp; $0.<span class="s-property">dueDate</span> &lt; .<span class="s-dotAccess">now</span>
})</code></pre><p>However, while we‚Äôve now made our filtering API a lot more flexible, we‚Äôve also lost some of the consistency that our previous approach gave us. If we would need to re-type the same predicate code over and over again, chances are high that we‚Äôll end up with inconsistencies, bugs and mistakes.</p><p>Thankfully, there‚Äôs a way to both achieve a decent level of consistency, while still maintaining the power and flexibility of free-form predicates. By combining <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static properties and factory methods</a> with <a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4">generic type constraints</a>, we can construct our most commonly used predicates in one central place ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Predicate</span> <span class="s-keyword">where</span> <span class="s-type">Target</span> == <span class="s-type">TodoItem</span> {
    <span class="s-keyword">static var</span> isOverdue: <span class="s-type">Self</span> {
        <span class="s-type">Predicate</span> {
            !$0.<span class="s-property">isCompleted</span> &amp;&amp; $0.<span class="s-property">dueDate</span> &lt; .<span class="s-dotAccess">now</span>
        }
    }
}</code></pre><p>Not only does the above approach give us a much greater degree of consistency, it also makes our call sites look really elegant, since we can reference the above kind of static properties using <em>dot-syntax</em>:</p><pre class="splash"><code><span class="s-keyword">let</span> overdueItems = list.<span class="s-call">items</span>(matching: .<span class="s-dotAccess">isOverdue</span>)</code></pre><p>Now that we‚Äôve found a way to make our new predicate system both consistent and flexible ‚Äî let‚Äôs see if we can keep iterating on it to make it even easier to define and compose various predicates.</p><h2>Expressive operators</h2><p>One of the perhaps most divisive features that Swift offers is the ability to <a href="https://www.swiftbysundell.com/articles/custom-operators-in-swift">define and overload operators</a>. While there‚Äôs definitely an argument to be made that relying too heavily on (especially custom) operators can make our code much more cryptic and harder to understand ‚Äî they could also have the complete opposite effect when used within the right contexts.</p><p>For example, let‚Äôs see what would happen if we would overload the <code>==</code> operator to enable a predicate to be defined using a <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key path</a> and a value to match against:</p><pre class="splash"><code><span class="s-keyword">func</span> ==&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Equatable</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { $0[keyPath: lhs] == rhs }
}</code></pre><p class="info">In Swift, operator implementations are just normal functions that take their operands as arguments (in this case a left-hand side one, and a right-hand side one).</p><p>Using the above, we can now create matching predicates like this:</p><pre class="splash"><code><span class="s-keyword">let</span> uncompletedItems = list.<span class="s-call">items</span>(matching: \.<span class="s-property">isCompleted</span> == <span class="s-keyword">false</span>)</code></pre><p>That‚Äôs pretty cool! If we wanted to, we could also overload the <code>!</code> operator as well ‚Äî which would enable us to encapsulate the above <code>== false</code> check within the resulting predicate:</p><pre class="splash"><code><span class="s-keyword">prefix func</span> !&lt;<span class="s-type">T</span>&gt;(rhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">Bool</span>&gt;) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    rhs == <span class="s-keyword">false</span>
}</code></pre><p>With the above in place, our call site syntax now becomes really lightweight:</p><pre class="splash"><code><span class="s-keyword">let</span> uncompletedItems = list.<span class="s-call">items</span>(matching: !\.<span class="s-property">isCompleted</span>)</code></pre><p>Along the same lines, we could also overload the <code>&gt;</code> and <code>&lt;</code> operators for values that conform to Swift‚Äôs <code>Comparable</code> protocol ‚Äî enabling us to define comparing predicates using the same lightweight syntax:</p><pre class="splash"><code><span class="s-keyword">func</span> &gt;&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Comparable</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { $0[keyPath: lhs] &gt; rhs }
}

<span class="s-keyword">func</span> &lt;&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Comparable</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { $0[keyPath: lhs] &lt; rhs }
}

<span class="s-keyword">let</span> highPriorityItems = list.<span class="s-call">items</span>(matching: \.<span class="s-property">priority</span> &gt; <span class="s-number">5</span>)</code></pre><p>The fact that operators allow us to express completely custom types purely using language syntax is really fascinating, and gives us an incredible amount of power when it comes to how we design our APIs. We just have to make sure to use that power responsibly.</p><h2>Composition built-in</h2><p>The fact that we chose to base our <code>Predicate</code> type on closures also opens up a lot of opportunities for composition ‚Äî since functions and closures can easily be combined in order to form new functionality.</p><p>For example, here‚Äôs how we could define an additional pair of operators to enable our predicates to be composed into double-matching, or either-matching combinations:</p><pre class="splash"><code><span class="s-keyword">func</span> &amp;&amp;&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt;, rhs: <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt;) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { lhs.<span class="s-call">matches</span>($0) &amp;&amp; rhs.<span class="s-call">matches</span>($0) }
}

<span class="s-keyword">func</span> ||&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt;, rhs: <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt;) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-type">Predicate</span> { lhs.<span class="s-call">matches</span>($0) || rhs.<span class="s-call">matches</span>($0) }
}</code></pre><p>Using the above, along with the other operator overloads that we‚Äôve defined so far, we can now create much more complex predicates that can have any number of conditions ‚Äî all using existing operators that we‚Äôre already familiar with:</p><pre class="splash"><code><span class="s-keyword">let</span> futureItems = list.<span class="s-call">items</span>(
    matching: !\.<span class="s-property">isCompleted</span> &amp;&amp; \.<span class="s-property">dueDate</span> &gt; .<span class="s-dotAccess">now</span>
)

<span class="s-keyword">let</span> overdueItems = list.<span class="s-call">items</span>(
    matching: !\.<span class="s-property">isCompleted</span> &amp;&amp; \.<span class="s-property">dueDate</span> &lt; .<span class="s-dotAccess">now</span>
)

<span class="s-keyword">let</span> myTasks = list.<span class="s-call">items</span>(
    matching: \.<span class="s-property">creator</span> == .<span class="s-dotAccess">currentUser</span> || \.<span class="s-property">assignedTo</span> == .<span class="s-dotAccess">currentUser</span>
)</code></pre><p>However, going back to the point of consistency from before, when it comes to complex predicates that are intended to be reused throughout our code base, it‚Äôs arguably better to still use a static factory method ‚Äî as doing so lets us neatly encapsulate all of the associated logic in a single place:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Predicate</span> <span class="s-keyword">where</span> <span class="s-type">Target</span> == <span class="s-type">TodoItem</span> {
    <span class="s-keyword">static func</span> isOverdue(
        comparedTo date: <span class="s-type">Date</span> = .<span class="s-dotAccess">now</span>,
        inlcudingCompleted includeCompleted: <span class="s-type">Bool</span> = <span class="s-keyword">false</span>
    ) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">Predicate</span> {
            <span class="s-keyword">if</span> !includeCompleted {
                <span class="s-keyword">guard</span> !$0.<span class="s-property">isCompleted</span> <span class="s-keyword">else</span> {
                    <span class="s-keyword">return false</span>
                }
            }

            <span class="s-keyword">return</span> $0.<span class="s-property">dueDate</span> &lt; date
        }
    }
}

<span class="s-keyword">let</span> overdueItems = list.<span class="s-call">items</span>(matching: .<span class="s-call">isOverdue</span>())</code></pre><p class="info">By using a method, rather than a computed property, we can also inject customization options and data that can be stubbed when writing tests.</p><p>One of the major benefits of using a wrapping type, rather than referencing functions and closures directly, is that doing so enables us to decide which kind of syntax that‚Äôs the most appropriate within each situation.</p><h2>An expandable pattern</h2><p>The beauty of the predicate pattern that we‚Äôve now established is that it enables us to keep expanding our implementation to suit our evolving needs. For example, if we found ourselves needing to check whether a given nested collection contains an element, we could add yet another operator overload for that:</p><pre class="splash"><code><span class="s-keyword">func</span> ~=&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Collection</span>&gt;(
    lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>.<span class="s-type">Element</span>
) -&gt; <span class="s-type">Predicate</span>&lt;<span class="s-type">T</span>&gt; <span class="s-keyword">where</span> <span class="s-type">V</span>.<span class="s-type">Element</span>: <span class="s-type">Equatable</span> {
    <span class="s-type">Predicate</span> { $0[keyPath: lhs].<span class="s-call">contains</span>(rhs) }
}

<span class="s-keyword">let</span> importantItems = list.<span class="s-call">items</span>(matching: \.<span class="s-property">tags</span> ~= <span class="s-string">"important"</span>)</code></pre><p>Finally, since we built our <code>Predicate</code> type as a simple closure-based wrapper, it‚Äôs automatically compatible with many of the standard library‚Äôs various collection APIs ‚Äî as we can pass a predicate‚Äôs <code>matches</code> closure as a <a href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift">first class function</a>:</p><pre class="splash"><code><span class="s-keyword">let</span> strings: [<span class="s-type">String</span>] = ...
<span class="s-keyword">let</span> predicate: <span class="s-type">Predicate</span>&lt;<span class="s-type">String</span>&gt; = \.<span class="s-property">count</span> &gt; <span class="s-number">3</span>

strings.<span class="s-call">filter</span>(predicate.<span class="s-property">matches</span>)
strings.<span class="s-call">drop</span>(while: predicate.<span class="s-property">matches</span>)
strings.<span class="s-call">prefix</span>(while: predicate.<span class="s-property">matches</span>)
strings.<span class="s-call">contains</span>(where: predicate.<span class="s-property">matches</span>)</code></pre><p>The above call sites also read really nicely, almost like normal English sentences, thanks to our use of a wrapping type and the way its <code>matches</code> property is named.</p><h2>Conclusion</h2><p>Predicates can enable us to filter through in-memory data in ways that are both flexible and incredibly powerful, without requiring us to maintain a growing set of highly specific APIs.</p><p>By modeling our predicates in a way that takes advantage of some of Swift‚Äôs most powerful features ‚Äî like generics, operators, and first class functions ‚Äî we can also create predicates that are not only flexible, but completely type-safe as well.</p><p>I‚Äôm also really looking forward to the implementation of <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0249-key-path-literal-function-expressions.md">Swift Evolution proposal SE-0249</a>, which will enable key paths to be directly converted into functions ‚Äî enabling even more kinds of predicates to be easily constructed.</p><p>However, the kind of predicates that we explored in this article are really only suitable for querying in-memory data, as it‚Äôd be very hard to encode free-form closures into something that could be passed to a server, or to an on-disk database.</p><p>What do you think? Have you used predicates in this sort of way before, or is it something that‚Äôd be suitable for your code base? Let me know ‚Äî along with your questions, comments or feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/making-swift-code-extensible-through-plugins</guid><title>Making Swift code extensible through plugins</title><description>Let‚Äôs take a look at a few different ways to add plugin support to a type or library, and how doing so can enable a system to become a lot more decoupled and flexible.</description><link>https://www.swiftbysundell.com/articles/making-swift-code-extensible-through-plugins</link><pubDate>Sun, 1 Dec 2019 17:30:00 +0100</pubDate><content:encoded><![CDATA[<p>When writing shared abstractions, libraries and other kinds of code that‚Äôs intended to be used by multiple developers or different parts of a system, it‚Äôs often quite tricky to decide what the exact scope of that code‚Äôs functionality should be.</p><p>With a very narrow feature set the code might not be able to accomplish what we need it to, and if it has too many features there‚Äôs a substantial risk that it becomes huge, messy and hard to maintain ‚Äî by attempting to cover too much ground and by taking on too many responsibilities.</p><p>This week, let‚Äôs continue exploring the topic of <em><a href="https://www.swiftbysundell.com/articles/configurable-types-in-swift">configurable types</a></em> that was covered earlier this year ‚Äî by taking a look at how setting up a plugin-based architecture can help us keep a library or piece of functionality as narrow and as small as possible, while still enabling it to be extended and tailored for more specific use cases.</p><h2>Starting out simple</h2><p>There‚Äôs definitely an argument to be made that most of the code that we write should ideally start out as simple as possible. Making things too generic and flexible from the start often leads to over-complicated implementations, and APIs that might never end up being used in practice.</p><p>Let‚Äôs say that we've started building an <code>ImageLoader</code> class for loading images over the network, and that in order to follow that philosophy of not making things too complicated, we‚Äôve simply made our new class act as a relatively thin wrapper around an existing <code>Networking</code> protocol ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    <span class="s-keyword">typealias</span> Handler = (<span class="s-type">Result</span>&lt;<span class="s-type">UIImage</span>, <span class="s-type">Error</span>&gt;) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">private let</span> networking: <span class="s-type">Networking</span>

    <span class="s-keyword">init</span>(networking: <span class="s-type">Networking</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">networking</span> = networking
    }

    <span class="s-keyword">func</span> loadImage(from url: <span class="s-type">URL</span>,
                   then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">let</span> request = <span class="s-type">Request</span>(url: url, method: .<span class="s-dotAccess">get</span>)

        networking.<span class="s-call">perform</span>(request) { result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> data):
                <span class="s-keyword">guard let</span> image = <span class="s-type">UIImage</span>(data: data) <span class="s-keyword">else</span> {
                    <span class="s-call">handler</span>(.<span class="s-call">failure</span>(<span class="s-type">ImageError</span>.<span class="s-property">invalidData</span>))
                    <span class="s-keyword">return</span>
                }

                <span class="s-call">handler</span>(.<span class="s-call">success</span>(image))
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>The above implementation might be simple, but it‚Äôll probably be enough as long as our requirements stay simple as well. However, as our project evolves, that situation might change. We might also decide that we want to share the above class with other developers, or between different apps, which could make its requirements grow increasingly more complex as a result.</p><p>For example, some use cases might require certain requests to be authenticated, or we might want to add support for displaying placeholder images if the user‚Äôs network connection was lost, and so on.</p><p>While we could, of course, decide to let our <code>ImageLoader</code> take on all of those new responsibilities (and have it grow in scope and complexity as a result) ‚Äî let‚Äôs instead take a look at how we could enable external code to be injected into it, and how that code could implement those kind of features in a very flexible way.</p><h2>Plugins</h2><p>Like the name implies, a <em>plugin</em> is a piece of code that can be plugged into another type or system in order to modify its functionality. While plugins can take on many different shapes and forms, let‚Äôs again start out simple and say that a plugin will, in this case, simply be a function ‚Äî that takes a value of a given type as input and returns a new version of it as output:</p><pre class="splash"><code><span class="s-keyword">typealias</span> Plugin&lt;T&gt; = (<span class="s-type">T</span>) -&gt; <span class="s-type">T</span></code></pre><p>With just that simple type alias, we could now start defining many different kinds of plugins and modifiers. For example, here‚Äôs how we might set up a plugin function that adds a watermark to any image that was passed into it:</p><pre class="splash"><code><span class="s-keyword">let</span> watermarkingPlugin: <span class="s-type">Plugin</span>&lt;<span class="s-type">UIImage</span>&gt; = { image <span class="s-keyword">in
    let</span> renderer = <span class="s-type">UIGraphicsImageRenderer</span>(size: image.<span class="s-property">size</span>)

    <span class="s-keyword">return</span> renderer.<span class="s-call">image</span> { context <span class="s-keyword">in</span>
        context.<span class="s-call">draw</span>(image)
        context.<span class="s-call">drawWatermark</span>(forImageSize: image.<span class="s-property">size</span>)
    }
}</code></pre><p>However, being able to define plugins is not enough ‚Äî we also need a way for them to actually interact with the type that they‚Äôre for. To make that happen, let‚Äôs start by implementing a simple collection type that‚Äôll let us keep track of all plugins that were added for a certain value and use case, and to also apply them to a given value as well:</p><pre class="splash"><code><span class="s-keyword">struct</span> PluginCollection&lt;Value&gt; {
    <span class="s-keyword">private var</span> plugins = [<span class="s-type">Plugin</span>&lt;<span class="s-type">Value</span>&gt;]()

    <span class="s-keyword">mutating func</span> add(<span class="s-keyword">_</span> plugin: <span class="s-keyword">@escaping</span> <span class="s-type">Plugin</span>&lt;<span class="s-type">Value</span>&gt;) {
        plugins.<span class="s-call">append</span>(plugin)
    }

    <span class="s-keyword">func</span> apply(to value: <span class="s-type">Value</span>) -&gt; <span class="s-type">Value</span> {
        plugins.<span class="s-call">reduce</span>(value) { value, plugin <span class="s-keyword">in</span>
            <span class="s-call">plugin</span>(value)
        }
    }
}</code></pre><p class="info">The reason we keep the underlying array of plugins private is that we don‚Äôt want to allow any external code to freely modify it. Using the above setup, the only type of mutation that‚Äôs allowed is to add new plugins to the collection.</p><p>With the above infrastructure in place, let‚Äôs start enabling plugins to be attached to our <code>ImageLoader</code> from before. The first thing we‚Äôll do is to define two <code>PluginCollection</code> properties ‚Äî one for plugins that‚Äôll be called before we start performing a request, and one for those that wish to modify the result of loading an image:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    ...
    <span class="s-keyword">var</span> preProcessingPlugins = <span class="s-type">PluginCollection</span>&lt;<span class="s-type">Request</span>&gt;()
    <span class="s-keyword">var</span> postProcessingPlugins = <span class="s-type">PluginCollection</span>&lt;<span class="s-type">Result</span>&lt;<span class="s-type">UIImage</span>, <span class="s-type">Error</span>&gt;&gt;()
    ...
}</code></pre><p>Next, let‚Äôs invoke each set of plugins as part of our image loading process. Since our collection of <code>preProcessingPlugins</code> will be capable of modifying each request before it‚Äôs sent, let‚Äôs call it when initializing our <code>Request</code> value ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">let</span> request = preProcessingPlugins.<span class="s-call">apply</span>(
    to: <span class="s-type">Request</span>(url: url, method: .<span class="s-dotAccess">get</span>)
)</code></pre><p>On the other end, our collection of <code>postProcessingPlugins</code> should be called after a request finished loading ‚Äî enabling each of those plugins to perform post-processing on the loaded image (or the resulting error). Using <em><a href="https://www.swiftbysundell.com/tips/variable-shadowing">variable shadowing</a></em>, we‚Äôll wrap the <code>handler</code> that was passed into our image loading function, in order to inject our plugin logic:</p><pre class="splash"><code><span class="s-keyword">let</span> handler: <span class="s-type">Handler</span> = { [postProcessingPlugins] result <span class="s-keyword">in</span>
    <span class="s-call">handler</span>(postProcessingPlugins.<span class="s-call">apply</span>(to: result))
}</code></pre><p>If we now update <code>ImageLoader</code> with the above two pieces of code, our <code>loadImage</code> method will end up looking like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ImageLoader {
    ...
    <span class="s-keyword">func</span> loadImage(from url: <span class="s-type">URL</span>,
                   then handler: <span class="s-keyword">@escaping</span> <span class="s-type">Handler</span>) {
        <span class="s-keyword">let</span> request = preProcessingPlugins.<span class="s-call">apply</span>(
            to: <span class="s-type">Request</span>(url: url, method: .<span class="s-dotAccess">get</span>)
        )

        <span class="s-keyword">let</span> handler: <span class="s-type">Handler</span> = { [postProcessingPlugins] result <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(postProcessingPlugins.<span class="s-call">apply</span>(to: result))
        }

        networking.<span class="s-call">perform</span>(request) { result <span class="s-keyword">in
            switch</span> result {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>(<span class="s-keyword">let</span> data):
                <span class="s-keyword">guard let</span> image = <span class="s-type">UIImage</span>(data: data) <span class="s-keyword">else</span> {
                    <span class="s-call">handler</span>(.<span class="s-call">failure</span>(<span class="s-type">ImageError</span>.<span class="s-property">invalidData</span>))
                    <span class="s-keyword">return</span>
                }

                <span class="s-call">handler</span>(.<span class="s-call">success</span>(image))
            <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error):
                <span class="s-call">handler</span>(.<span class="s-call">failure</span>(error))
            }
        }
    }
}</code></pre><p>In the grand scheme of things, the modifications that we just made to <code>ImageLoader</code> were really minor, but they still enable a ton of new flexibility and power. For example, besides the watermarking plugin we took a look at earlier, we could use our new plugin system to conditionally authenticate each request if the user of our app has logged in:</p><pre class="splash"><code>imageLoader.<span class="s-property">preProcessingPlugins</span>.<span class="s-call">add</span> { [loginController] request <span class="s-keyword">in</span>
    <span class="s-comment">// Don't authenticate external API calls</span>
    <span class="s-keyword">guard</span> request.<span class="s-property">url</span>.<span class="s-property">isInternalAPIURL</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> request
    }

    <span class="s-keyword">guard let</span> accessToken = loginController.<span class="s-property">session</span>?.<span class="s-property">accessToken</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span> request
    }

    <span class="s-keyword">return</span> request.<span class="s-call">addingHeader</span>(
        named: <span class="s-string">"Authorization"</span>,
        value: <span class="s-string">"Bearer</span> \(accessToken)<span class="s-string">"</span>
    )
}</code></pre><p>When it comes to post-processing, we could now easily inject a placeholder image in case a request failed with an offline error:</p><pre class="splash"><code>imageLoader.<span class="s-property">postProcessingPlugins</span>.<span class="s-call">add</span> { result <span class="s-keyword">in
    switch</span> result {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">success</span>:
        <span class="s-keyword">return</span> result
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>(<span class="s-keyword">let</span> error) <span class="s-keyword">where</span> error.<span class="s-property">isOfflineError</span>:
        <span class="s-keyword">return</span> .<span class="s-call">success</span>(.<span class="s-call">makePlaceholder</span>())
    <span class="s-keyword">case</span> .<span class="s-dotAccess">failure</span>:
        <span class="s-keyword">return</span> result
    }
}</code></pre><p class="info">Above we‚Äôre using Swift‚Äôs powerful pattern matching capabilities to match all failures with errors that were caused by our app being offline. To learn more about those capabilities, check out <a href="https://www.swiftbysundell.com/articles/pattern-matching-in-swift">‚ÄúPattern matching in Swift‚Äù</a>.</p><p>The benefit of building the above functionality as plugins, rather than implementing it within <code>ImageLoader</code> itself, is that our system becomes a lot more modular and flexible overall. Our image loader doesn‚Äôt need to know anything about access tokens, but can still support authenticated requests, and we could keep defining new kinds of plugins to do all sorts of both pre- and post-processing ‚Äî all using a very simple, closure-based abstraction.</p><h2>Multiple flavors of the same pattern</h2><p>Like with most patterns and techniques, there are multiple ways that a plugin-style architecture could be implemented ‚Äî and many different scales at which such a setup could be deployed. However, regardless of which abstraction that‚Äôs chosen and to what extent we end up using such a plugin system, the goal remains the same ‚Äî to enable functionality to be decoupled, and for specific overrides to be injected, rather than requiring one single type to cover all possible use cases.</p><p>Let‚Äôs take a look at two examples from the open source world, starting with the Core Animation-based game engine <a href="https://github.com/JohnSundell/ImagineEngine">Imagine Engine</a> ‚Äî which uses plugins to enable various game components and logic to be defined in a completely decoupled manner. Since these plugins require multiple APIs, they‚Äôre modeled as a protocol, rather than as a closure type:</p><pre class="splash"><code><span class="s-keyword">public protocol</span> Plugin: <span class="s-type">AnyObject</span> {
    <span class="s-keyword">associatedtype</span> Object: <span class="s-type">AnyObject</span>

    <span class="s-keyword">func</span> activate(for object: <span class="s-type">Object</span>, in game: <span class="s-type">Game</span>)
    <span class="s-keyword">func</span> deactivate()
}</code></pre><p>Just like our <code>ImageLoader</code> plugin system from before, the above protocol enables all sorts of plugins to be used to modify the game engine‚Äôs various objects. For example, here‚Äôs how a plugin could be implemented to have a scene‚Äôs camera follow the movement of any <em>actor</em> ‚Äî such as a player or an enemy:</p><pre class="splash"><code><span class="s-keyword">class</span> FollowActorPlugin: <span class="s-type">Plugin</span> {
    <span class="s-keyword">private let</span> actor: <span class="s-type">Actor</span>

    <span class="s-keyword">init</span>(actor: <span class="s-type">Actor</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">actor</span> = actor
    }

    <span class="s-keyword">func</span> activate(for camera: <span class="s-type">Camera</span>, in game: <span class="s-type">Game</span>) {
        actor.<span class="s-property">events</span>.<span class="s-property">moved</span>.<span class="s-call">addObserver</span>(camera) { camera, actor <span class="s-keyword">in</span>
            camera.<span class="s-property">position</span> = actor.<span class="s-property">position</span>
        }
    }
}</code></pre><p class="info">The above code also shows the observer pattern in action, which was covered in the two-part article <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-1">‚ÄúObservers in Swift‚Äù</a>.</p><p>Finally, let‚Äôs take a look at a third <em>‚Äúflavor‚Äù</em> of plugins, which can be found in the <a href="https://github.com/JohnSundell/Ink">Markdown parser Ink</a>, which enables <a href="https://daringfireball.net/projects/markdown">Markdown</a>-formatted strings to be converted into HTML. When using that library, the plugin-like <code>Modifier</code> type can be used to implement various modifiers that are plugged into the Markdown parsing process ‚Äî for example in order to add a heading on top of each code block within an article:</p><pre class="splash"><code><span class="s-keyword">let</span> modifier = <span class="s-type">Modifier</span>(target: .<span class="s-dotAccess">codeBlocks</span>) { html, markdown <span class="s-keyword">in
    return</span> <span class="s-string">"&lt;h3&gt;Sample code:&lt;/h3&gt;"</span> + html
}</code></pre><p class="info">Fun meta fact: Ink was used to generate the very article that you‚Äôre reading right now.</p><p>Acting as a sort of hybrid between the protocol-oriented approach found in Imagine Engine, and the simpler closure-based approach that we built in this article, Ink‚Äôs <code>Modifier</code> type uses a <code>Target</code> enum to enable the library to decide in which context to execute each plugin closure ‚Äî and looks like this:</p><pre class="splash"><code><span class="s-keyword">public struct</span> Modifier {
    <span class="s-keyword">public typealias</span> Input = (html: <span class="s-type">String</span>, markdown: <span class="s-type">Substring</span>)
    <span class="s-keyword">public typealias</span> Closure = (<span class="s-type">Input</span>) -&gt; <span class="s-type">String</span>

    <span class="s-keyword">public var</span> target: <span class="s-type">Target</span>
    <span class="s-keyword">public var</span> closure: <span class="s-type">Closure</span>

    <span class="s-keyword">public init</span>(target: <span class="s-type">Target</span>, closure: <span class="s-keyword">@escaping</span> <span class="s-type">Closure</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">target</span> = target
        <span class="s-keyword">self</span>.<span class="s-property">closure</span> = closure
    }
}</code></pre><p>Each of the above examples enable their libraries to remain focused on their core set of tasks, rather than having to include explicit APIs for all sorts of functionality ‚Äî which in turns enables the users of those libraries to more freely customize how they behave, and to implement new functionality without having to make any modifications to the library itself.</p><h2>Conclusion</h2><p>When deployed in the right contexts, plugin architectures can be incredibly powerful ‚Äî and can let us unlock new capabilities for both external users, and for our internal implementations as well. Adding plugin support to a library or type can not only act as an <em>‚Äúescape hatch‚Äù</em> that lets users implement missing APIs and features themselves, but can also help prevent a project from growing too much in both scope and complexity.</p><p>However, plugins are not always appropriate, and they do come with their own set of trade-offs as well. One risk with using a plugin-heavy approach is that the overall system could become too fragmented and distributed ‚Äî potentially making certain issues harder to debug, or making it more time-consuming to get an overview of the system. Whether or not those trade-offs are worth it will, like always, depend on the sort of system that we‚Äôre looking to build.</p><p>What do you think? Have you ever added plugin support to a library or system, or have you perhaps benefited from one of your dependencies supporting plugins? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift</guid><title>Lightweight API design in Swift</title><description>This week, let‚Äôs take a look at a few core language features that enable us to design really lightweight APIs in Swift, and how we can use them to make a feature or system much more capable through the power of composition.</description><link>https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift</link><pubDate>Sun, 24 Nov 2019 21:30:00 +0100</pubDate><content:encoded><![CDATA[<p>One of the most powerful aspects of Swift is just how much flexibility it gives us when it comes to how APIs can be designed. Not only does that flexibility enable us to define functions and types that are easier to understand and use ‚Äî it also lets us create APIs that give a very lightweight first impression, while still progressively disclosing more power and complexity if needed.</p><p>This week, let‚Äôs take a look at some of the core language features that enable those kind of lightweight APIs to be created, and how we can use them to make a feature or system much more capable through the power of composition.</p><h2>A trade-off between power and ease of use</h2><p>Often when we design how our various types and functions will interact with each other, we have to find some form of balance between power and ease of use. Make things too simple, and they might not be flexible enough to enable our features to continuously evolve ‚Äî but on the other hand, too much complexity often leads to frustration, misunderstandings, and ultimately bugs.</p><p>As an example, let‚Äôs say that we‚Äôre working on an app that lets our users apply various filters to images ‚Äî for example to be able to edit photos from their camera roll or library. Each filter is made up of an array of image transforms, and is defined using an <code>ImageFilter</code> struct, that looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> ImageFilter {
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
    <span class="s-keyword">var</span> icon: <span class="s-type">Icon</span>
    <span class="s-keyword">var</span> transforms: [<span class="s-type">ImageTransform</span>]
}</code></pre><p>When it comes to the <code>ImageTransform</code> API, it‚Äôs currently modeled as a protocol, which is then conformed to by various types that implement our individual transform operations:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ImageTransform {
    <span class="s-keyword">func</span> apply(to image: <span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span>
}

<span class="s-keyword">struct</span> PortraitImageTransform: <span class="s-type">ImageTransform</span> {
    <span class="s-keyword">var</span> zoomMultiplier: <span class="s-type">Double</span>

    <span class="s-keyword">func</span> apply(to image: <span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span> {
        ...
    }
}

<span class="s-keyword">struct</span> GrayScaleImageTransform: <span class="s-type">ImageTransform</span> {
    <span class="s-keyword">var</span> brightnessLevel: <span class="s-type">BrightnessLevel</span>

    <span class="s-keyword">func</span> apply(to image: <span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span> {
        ...
    }
}</code></pre><p>One core advantage of the above approach is that, since each transform is implemented as its own type, we‚Äôre free to let each type define its own set of properties and parameters ‚Äî such as how <code>GrayScaleImageTransform</code> accepts a <code>BrightnessLevel</code> to use when turning an image into grayscale.</p><p>We can then combine as many of the above types as we wish in order to form each filter ‚Äî for example one that gives an image a bit of a <em>‚Äúdramatic‚Äù</em> look through a series of transforms:</p><pre class="splash"><code><span class="s-keyword">let</span> dramaticFilter = <span class="s-type">ImageFilter</span>(
    name: <span class="s-string">"Dramatic"</span>,
    icon: .<span class="s-dotAccess">drama</span>,
    transforms: [
        <span class="s-type">PortraitImageTransform</span>(zoomMultiplier: <span class="s-number">2.1</span>),
        <span class="s-type">ContrastBoostImageTransform</span>(),
        <span class="s-type">GrayScaleImageTransform</span>(brightnessLevel: .<span class="s-dotAccess">dark</span>)
    ]
)</code></pre><p>So far so good ‚Äî but if we take a closer look at the above API, it can definitely be argued that we‚Äôve chosen to optimize for power and flexibility, rather than for ease of use. Since each transform is implemented as an individual type, it‚Äôs not immediately clear what kind of transforms that our code base contains, since there‚Äôs no single place in which they can all be instantly discovered.</p><p>Compare that to if we would‚Äôve chosen to use an enum to model our transforms instead ‚Äî which would‚Äôve given us a very clear overview of all possible options:</p><pre class="splash"><code><span class="s-keyword">enum</span> ImageTransform {
    <span class="s-keyword">case</span> portrait(zoomMultiplier: <span class="s-type">Double</span>)
    <span class="s-keyword">case</span> grayScale(<span class="s-type">BrightnessLevel</span>)
    <span class="s-keyword">case</span> contrastBoost
}</code></pre><p>Using an enum would‚Äôve also resulted in very nice and readable call sites ‚Äî making our API feel much more lightweight and easy to use, since we would‚Äôve been able to construct any number of transforms using <em>dot-syntax</em>, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> dramaticFilter = <span class="s-type">ImageFilter</span>(
    name: <span class="s-string">"Dramatic"</span>,
    icon: .<span class="s-dotAccess">drama</span>,
    transforms: [
        .<span class="s-call">portrait</span>(zoomMultiplier: <span class="s-number">2.1</span>),
        .<span class="s-dotAccess">contrastBoost</span>,
        .<span class="s-call">grayScale</span>(.<span class="s-dotAccess">dark</span>)
    ]
)</code></pre><p>However, while Swift enums are a fantastic tool in many different situations, this isn‚Äôt really one of them.</p><p>Since each transform needs to perform vastly different image operations, using an enum in this case would‚Äôve forced us to write one massive <code>switch</code> statement to handle each and every one of those operations ‚Äî which would most likely become somewhat of a nightmare to maintain.</p><h2>Light as an enum, capable as a struct</h2><p>Thankfully, there‚Äôs a third option ‚Äî which sort of gives us the best of both worlds. Rather than using either a protocol or an enum, let‚Äôs instead use a struct, which in turn will contain a closure that encapsulates a given transform‚Äôs various operations:</p><pre class="splash"><code><span class="s-keyword">struct</span> ImageTransform {
    <span class="s-keyword">let</span> closure: (<span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span>

    <span class="s-keyword">func</span> apply(to image: <span class="s-type">Image</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Image</span> {
        <span class="s-keyword">try</span> <span class="s-call">closure</span>(image)
    }
}</code></pre><p class="info">Note that the <code>apply(to:)</code> method is no longer required, but we still add it both for backward compatibility, and to make our call sites read a bit nicer.</p><p>With the above in place, we can now use <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory methods and properties</a> to create our transforms ‚Äî each of which can still be individually defined and have its own set of parameters:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ImageTransform</span> {
    <span class="s-keyword">static var</span> contrastBoost: <span class="s-type">Self</span> {
        <span class="s-type">ImageTransform</span> { image <span class="s-keyword">in</span>
            ...
        }
    }

    <span class="s-keyword">static func</span> portrait(withZoomMultipler multiplier: <span class="s-type">Double</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">ImageTransform</span> { image <span class="s-keyword">in</span>
            ...
        }
    }

    <span class="s-keyword">static func</span> grayScale(withBrightness brightness: <span class="s-type">BrightnessLevel</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">ImageTransform</span> { image <span class="s-keyword">in</span>
            ...
        }
    }
}</code></pre><p class="info">That <code>Self</code> can now be used as a return type for static factory methods is one of the <a href="https://www.swiftbysundell.com/articles/5-small-but-significant-improvements-in-swift-5-1/">small but significant improvements introduced in Swift 5.1</a>.</p><p>The beauty of the above approach is that we‚Äôre back to the same level of flexibility and power that we had when defining <code>ImageTransform</code> as a protocol, while still being able to use a more or less identical dot-syntax as when using an enum:</p><pre class="splash"><code><span class="s-keyword">let</span> dramaticFilter = <span class="s-type">ImageFilter</span>(
    name: <span class="s-string">"Dramatic"</span>,
    icon: .<span class="s-dotAccess">drama</span>,
    transforms: [
        .<span class="s-call">portrait</span>(withZoomMultipler: <span class="s-number">2.1</span>),
        .<span class="s-dotAccess">contrastBoost</span>,
        .<span class="s-call">grayScale</span>(withBrightness: .<span class="s-dotAccess">dark</span>)
    ]
)</code></pre><p>The fact that dot syntax isn‚Äôt tied to enums, but can instead be used with any sort of static API, is incredibly powerful ‚Äî and even lets us encapsulate things one step further, by modeling the above filter creation as a computed static property as well:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">ImageFilter</span> {
    <span class="s-keyword">static var</span> dramatic: <span class="s-type">Self</span> {
        <span class="s-type">ImageFilter</span>(
            name: <span class="s-string">"Dramatic"</span>,
            icon: .<span class="s-dotAccess">drama</span>,
            transforms: [
                .<span class="s-call">portrait</span>(withZoomMultipler: <span class="s-number">2.1</span>),
                .<span class="s-dotAccess">contrastBoost</span>,
                .<span class="s-call">grayScale</span>(withBrightness: .<span class="s-dotAccess">dark</span>)
            ]
        )
    }
}</code></pre><p>The result of all of the above is that we can now take a really complex series of tasks ‚Äî applying image filters and transforms ‚Äî and encapsulate them into an API that, on the surface level, appears as lightweight as simply passing a value to a function:</p><pre class="splash"><code><span class="s-keyword">let</span> filtered = image.<span class="s-call">withFilter</span>(.<span class="s-dotAccess">dramatic</span>)</code></pre><p>While it‚Äôs easy to dismiss the above change as purely adding <em>‚Äùsyntactic sugar‚Äù</em>, we haven‚Äôt only improved the way our API reads, but also the way in which its parts can be composed. Since all transforms and filters are now just values, they can be combined in a huge number of ways ‚Äî which doesn‚Äôt only make them more lightweight, but also much more flexible as well.</p><h2>Variadic parameters and further composition</h2><p>Next, let‚Äôs take a look at another really interesting language feature ‚Äî variadic parameters ‚Äî and what kind of API design choices that they can unlock.</p><p>Let‚Äôs now say that we‚Äôre working on an app that uses shape-based drawing in order to create parts of its user interface, and that we‚Äôve used a similar struct-based approach as above in order to model how each shape is drawn into a <code>DrawingContext</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Shape {
    <span class="s-keyword">var</span> drawing: (<span class="s-keyword">inout</span> <span class="s-type">DrawingContext</span>) -&gt; <span class="s-type">Void</span>
}</code></pre><p class="info">Above we use the <code>inout</code> keyword to enable a value type (<code>DrawingContext</code>) to be passed as if it was a reference. For more on that keyword, and value semantics in general, check out <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">‚ÄúUtilizing value semantics in Swift‚Äù</a>.</p><p>Just like how we enabled <code>ImageTransform</code> values to be easily created using static factory methods before, we‚Äôre now also able to encapsulate each shape‚Äôs drawing code within completely separate methods ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Shape</span> {
    <span class="s-keyword">static func</span> square(at point: <span class="s-type">Point</span>, sideLength: <span class="s-type">Double</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">Shape</span> { context <span class="s-keyword">in
            let</span> origin = point.<span class="s-call">movedBy</span>(
                x: -sideLength / <span class="s-number">2</span>,
                y: -sideLength / <span class="s-number">2</span>
            )

            context.<span class="s-call">move</span>(to: origin)
            context.<span class="s-call">drawLine</span>(to: origin.<span class="s-call">movedBy</span>(x: sideLength))
            context.<span class="s-call">drawLine</span>(to: origin.<span class="s-call">movedBy</span>(x: sideLength, y: sideLength))
            context.<span class="s-call">drawLine</span>(to: origin.<span class="s-call">movedBy</span>(y: sideLength))
            context.<span class="s-call">drawLine</span>(to: origin)
        }
    }
}</code></pre><p>Since each shape is simply modeled as a value, drawing arrays of them becomes quite easy ‚Äî all we have to do is to create an instance of <code>DrawingContext</code>, and then pass that into each shape‚Äôs closure in order to build up our final image:</p><pre class="splash"><code><span class="s-keyword">func</span> draw(<span class="s-keyword">_</span> shapes: [<span class="s-type">Shape</span>]) -&gt; <span class="s-type">Image</span> {
    <span class="s-keyword">var</span> context = <span class="s-type">DrawingContext</span>()
    
    shapes.<span class="s-call">forEach</span> { shape <span class="s-keyword">in</span>
        context.<span class="s-call">move</span>(to: .<span class="s-dotAccess">zero</span>)
        shape.<span class="s-call">drawing</span>(&amp;context)
    }
    
    <span class="s-keyword">return</span> context.<span class="s-call">makeImage</span>()
}</code></pre><p>Calling the above function also looks quite elegant, since we‚Äôre again able to use dot syntax to heavily reduce the amount of syntax needed to perform our work:</p><pre class="splash"><code><span class="s-keyword">let</span> image = <span class="s-call">draw</span>([
    .<span class="s-call">circle</span>(at: point, radius: <span class="s-number">10</span>),
    .<span class="s-call">square</span>(at: point, sideLength: <span class="s-number">5</span>)
])</code></pre><p>However, let‚Äôs see if we can take things one step further using variadic parameters. While not a feature unique to Swift, when combined with Swift‚Äôs really flexible parameter naming capabilities, using variadic parameters can yield some really interesting results.</p><p>When a parameter is marked as variadic (by adding the <code>...</code> suffix to its type), we‚Äôre essentially able to pass any number of values to that parameter ‚Äî and the compiler will automatically organize those values into an array for us, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> draw(<span class="s-keyword">_</span> shapes: <span class="s-type">Shape</span>...) -&gt; <span class="s-type">Image</span> {
    ...
    <span class="s-comment">// Within our function, 'shapes' is still an array:</span>
    shapes.<span class="s-call">forEach</span> { ... }
}</code></pre><p>With the above change in place, we can now remove all of the array literals from the calls to our <code>draw</code> function, and instead make them look like this:</p><pre class="splash"><code><span class="s-keyword">let</span> image = <span class="s-call">draw</span>(.<span class="s-call">circle</span>(at: point, radius: <span class="s-number">10</span>),
                 .<span class="s-call">square</span>(at: point, sideLength: <span class="s-number">5</span>))</code></pre><p>That might not seem like such a big change, but especially when designing more lower-level APIs that are intended to be used to create more higher-level values (such as our <code>draw</code> function), using variadic parameters can make those kind of APIs feel much more lightweight and convenient.</p><p>However, one drawback of using variadic parameters is that an array of pre-computed values can no longer be passed as a single argument. Thankfully, that can quite easily be fixed in this case, by creating a special <code>group</code> shape that ‚Äî just like the <code>draw</code> function itself ‚Äî iterates over an array of underlying shapes and draws them:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Shape</span> {
    <span class="s-keyword">static func</span> group(<span class="s-keyword">_</span> shapes: [<span class="s-type">Shape</span>]) -&gt; <span class="s-type">Self</span> {
        <span class="s-type">Shape</span> { context <span class="s-keyword">in</span>
            shapes.<span class="s-call">forEach</span> { shape <span class="s-keyword">in</span>
                context.<span class="s-call">move</span>(to: .<span class="s-dotAccess">zero</span>)
                shape.<span class="s-call">drawing</span>(&amp;context)
            }
        }
    }
}</code></pre><p>With the above in place, we can now once again easily pass a group of pre-computed <code>Shape</code> values to our <code>draw</code> function, like this:</p><pre class="splash"><code><span class="s-keyword">let</span> shapes: [<span class="s-type">Shape</span>] = <span class="s-call">loadShapes</span>()
<span class="s-keyword">let</span> image = <span class="s-call">draw</span>(.<span class="s-call">group</span>(shapes))</code></pre><p>What‚Äôs really cool though, is that not only does the above <code>group</code> API enable us to construct arrays of shapes ‚Äî it also enables us to much more easily compose multiple shapes into more higher-level components. For example, here‚Äôs how we could express an entire drawing (such as a logo), using a group of composed shapes:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Shape</span> {
    <span class="s-keyword">static func</span> logo(withSize size: <span class="s-type">Size</span>) -&gt; <span class="s-type">Self</span> {
        .<span class="s-call">group</span>([
            .<span class="s-call">rectangle</span>(at: size.<span class="s-property">centerPoint</span>, size: size),
            .<span class="s-call">text</span>(<span class="s-string">"The Drawing Company"</span>, fittingInto: size),
            ...
        ])
    }
}</code></pre><p>Since the above logo is a <code>Shape</code> just like any other, we can easily draw it with a single call to our <code>draw</code> method, using the same elegant dot syntax as we used before:</p><pre class="splash"><code><span class="s-keyword">let</span> logo = <span class="s-call">draw</span>(.<span class="s-call">logo</span>(withSize: size))</code></pre><p>What‚Äôs interesting is that while our initial goal might‚Äôve been to make our API more lightweight, in doing so we also made it more composable and more flexible as well.</p><h2>Conclusion</h2><p>The more tools that we add to our <em>‚ÄúAPI designer‚Äôs toolbox‚Äù</em>, the more likely it is that we‚Äôll be able to design APIs that strike the right balance between power, flexibility and ease of use.</p><p>Making APIs as lightweight as possible might not be our ultimate goal, but by trimming our APIs down as much as we can, we also often discover how they can be made more powerful ‚Äî by making the way we create our types more flexible, and by enabling them to be composed. All of which can aid us in achieving that perfect balance between simplicity and power.</p><p>What do you think? Do you like the kind of lightweight API design used in this article, or do you prefer your APIs to be a bit more verbose? Let me know ‚Äî along with any questions, comments or feedback that you might have ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/defining-custom-patterns-in-swift</guid><title>Defining custom patterns in Swift</title><description>This week, let‚Äôs dive deep into the world of pattern matching in Swift ‚Äî to take a look at how we can construct completely custom patterns, and some of the interesting techniques that we can unlock by doing so.</description><link>https://www.swiftbysundell.com/articles/defining-custom-patterns-in-swift</link><pubDate>Sun, 17 Nov 2019 14:30:00 +0100</pubDate><content:encoded><![CDATA[<p>One of the most interesting aspects of Swift as a language is just how many of its core features that are implemented using the language itself, rather than being hard-coded into the compiler. That‚Äôs not only elegant from a theoretical perspective, but also gives us a ton of practical flexibility, as it lets us tweak how the language works and behaves in really powerful ways.</p><p>An example of one such feature is <em><a href="https://www.swiftbysundell.com/articles/pattern-matching-in-swift">pattern matching</a></em> which, among other things, determines how control flow constructs like <code>switch</code> and <code>case</code> statements are evaluated. This week, let‚Äôs dive deep into the world of pattern matching in Swift ‚Äî to take a look at how we can construct completely custom patterns, and some of the interesting techniques that we can unlock by doing so.</p><h2>Building the basics</h2><p>As the name implies, <em>pattern matching</em> is all about matching a given value against a pre-defined pattern, often in order to figure out which code branch to continue executing a program on. For example, every time we switch on a value, we are using Swift‚Äôs pattern matching feature:</p><pre class="splash"><code><span class="s-keyword">func</span> items(in section: <span class="s-type">Section</span>) -&gt; [<span class="s-type">Item</span>] {
    <span class="s-keyword">switch</span> section {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">featured</span>:
        <span class="s-keyword">return</span> dataSource.<span class="s-property">featuredItems</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">recent</span>:
        <span class="s-keyword">return</span> dataSource.<span class="s-property">recentItems</span>
    }
}</code></pre><p>Above we‚Äôre matching a <code>Section</code> enum value against two patterns that are made up of its cases (<code>featured</code> and <code>recent</code>), and while that‚Äôs a very common way of using pattern matching in Swift ‚Äî it barely scratches the surface of what the feature is capable of.</p><p>To take things further, let‚Äôs start by defining a <code>Pattern</code> struct, which we‚Äôll use to define our own closure-based patterns. Those closures will simply take a value to match, and then return the result as a <code>Bool</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> Pattern&lt;Value&gt; {
    <span class="s-keyword">let</span> closure: (<span class="s-type">Value</span>) -&gt; <span class="s-type">Bool</span>
}</code></pre><p>The above struct may be simple, but it actually enables us to now define all sorts of custom patterns, by extending it using <a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4">generic type constraints</a> in order to add <a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory methods</a> that create our patterns. For example, here‚Äôs how we could define a pattern that lets us match a value against a given set of candidates:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Pattern</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Hashable</span> {
    <span class="s-keyword">static func</span> any(of candidates: <span class="s-type">Set</span>&lt;<span class="s-type">Value</span>&gt;) -&gt; <span class="s-type">Pattern</span> {
        <span class="s-type">Pattern</span> { candidates.<span class="s-call">contains</span>($0) }
    }
}</code></pre><p>Before we‚Äôll be able to use our new <code>Pattern</code> struct within a <code>switch</code> statement, however, we‚Äôll also need to tell Swift how to actually evaluate it within such a context.</p><p>All forms of pattern matching in Swift are powered by the <code>~=</code> operator, which takes the pattern to evaluate as its <em>left-hand-side</em> argument, and the value being matched as its <em>right-hand-side</em> one. So in order to hook our <code>Pattern</code> type into that system, all we have to do is to overload <code>~=</code> with a function that takes an instance of our new struct and a value to match ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">func</span> ~=&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">Pattern</span>&lt;<span class="s-type">T</span>&gt;, rhs: <span class="s-type">T</span>) -&gt; <span class="s-type">Bool</span> {
    lhs.<span class="s-call">closure</span>(rhs)
}</code></pre><p>With the above in place, we‚Äôve now built all of the infrastructure required to define our own custom patterns ‚Äî so let‚Äôs get started!</p><h2>Mix and match</h2><p>Let‚Äôs say that we‚Äôre working on some form of social networking app, that uses a <code>LoggedInUser</code> struct in order to keep track of the currently logged in user‚Äôs data ‚Äî for example the user‚Äôs ID, as well the IDs of the friends they‚Äôve added using our app:</p><pre class="splash"><code><span class="s-keyword">struct</span> LoggedInUser {
    <span class="s-keyword">let</span> id: <span class="s-type">Identifier</span>&lt;<span class="s-type">User</span>&gt;
    <span class="s-keyword">var</span> friendIDs: <span class="s-type">Set</span>&lt;<span class="s-type">Identifier</span>&lt;<span class="s-type">User</span>&gt;&gt;
    ...
}</code></pre><p class="info">Above we‚Äôre using the <code>Identifier</code> type from <a href="https://www.swiftbysundell.com/articles/type-safe-identifiers-in-swift">‚ÄúType-safe identifiers in Swift‚Äù</a> and the <a href="https://github.com/JohnSundell/Identity">Identity package</a>.</p><p>Now let‚Äôs say that we‚Äôre building a view controller that lets us display any number of users as a list ‚Äî and that we want to render different icons depending on what kind of user that we‚Äôre displaying. That decision can now be made completely within a single <code>switch</code> statement, thanks to our new <code>Pattern</code> type and its <code>any(of:)</code> variant:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">UserListViewController</span> {
    <span class="s-keyword">func</span> resolveIcon(for userID: <span class="s-type">Identifier</span>&lt;<span class="s-type">User</span>&gt;) -&gt; <span class="s-type">Icon</span> {
        <span class="s-keyword">switch</span> userID {
        <span class="s-keyword">case</span> loggedInUser.<span class="s-property">id</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">currentUser</span>
        <span class="s-keyword">case</span> .<span class="s-dotAccess">any</span>(of: loggedInUser.<span class="s-property">friendIDs</span>):
            <span class="s-keyword">return</span> .<span class="s-dotAccess">friend</span>
        <span class="s-keyword">default</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">anyUser</span>
        }
    }
}</code></pre><p>The above may at first not seem <em>that</em> different compared to writing our logic as a series of <code>if</code> and <code>else</code> statements, but it does make our code more declarative ‚Äî and also makes <code>userID</code> a single source of truth for all of our possible rules and outcomes.</p><h2>Comparing patterns</h2><p>Let‚Äôs continue extending our <code>Pattern</code> type with more capabilities ‚Äî this time by adding support for patterns that compare one value against another. We‚Äôll do that by writing an extension constrained by the standard library‚Äôs <code>Comparable</code> protocol (another example of how a core language feature is implemented using a standard Swift protocol), which‚Äôll contain two methods ‚Äî one for matching against lower values, and one for greater ones:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Pattern</span> <span class="s-keyword">where</span> <span class="s-type">Value</span>: <span class="s-type">Comparable</span> {
    <span class="s-keyword">static func</span> lessThan(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) -&gt; <span class="s-type">Pattern</span> {
        <span class="s-type">Pattern</span> { $0 &lt; value }
    }

    <span class="s-keyword">static func</span> greaterThan(<span class="s-keyword">_</span> value: <span class="s-type">Value</span>) -&gt; <span class="s-type">Pattern</span> {
        <span class="s-type">Pattern</span> { $0 &gt; value }
    }
}</code></pre><p>The above comes very much in handy anytime we want to compare a value against both a lower and upper bound ‚Äî like in this example, in which we‚Äôre determining whether a user passed a required game score threshold, or whether they achieved a new high score ‚Äî all within a single <code>switch</code> statement:</p><pre class="splash"><code><span class="s-keyword">func</span> levelFinished(withScore score: <span class="s-type">Int</span>) {
    <span class="s-keyword">switch</span> score {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">lessThan</span>(<span class="s-number">50</span>):
        <span class="s-call">showGameOverScreen</span>()
    <span class="s-keyword">case</span> .<span class="s-dotAccess">greaterThan</span>(highscore):
        <span class="s-call">showNewHighscore</span>(score)
    <span class="s-keyword">default</span>:
        <span class="s-call">goToNextLevel</span>()
    }
}</code></pre><p class="info">The cases within a <code>switch</code> statement are always evaluated top-to-bottom, meaning that the above <code>lessThan</code> check will be performed before the <code>greaterThan</code> one.</p><p>We‚Äôre now starting to uncover the true power of Swift‚Äôs pattern matching capabilities, since we‚Äôve gone beyond just matching against single (or groups of) candidates, and are now constructing more complex pattern expressions ‚Äî all without making our call sites any more complicated.</p><h2>Converting key paths into patterns</h2><p>Another way of forming patterns that can be incredibly useful, is by using <em><a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key paths</a></em>. Since key paths are already represented by a concrete type, <code>KeyPath</code>, we simply need to add another <code>~=</code> overload in order to enable any key path to be used as a pattern:</p><pre class="splash"><code><span class="s-keyword">func</span> ~=&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">Bool</span>&gt;, rhs: <span class="s-type">T</span>?) -&gt; <span class="s-type">Bool</span> {
    rhs?[keyPath: lhs] ?? <span class="s-keyword">false</span>
}</code></pre><p class="info">Above we‚Äôre accepting an optional, <code>T?</code>, which will enable us to match non-optional key paths against optional values.</p><p>With the above in place, we can now freely mix key paths with other kinds of patterns, which will enable us to express even quite complex pieces of logic using just a single <code>switch</code> statement.</p><p>For example, here we‚Äôre deciding how to parse a line of text into a list item, based on its first character ‚Äî by using the <code>Character</code> type‚Äôs <a href="https://www.swiftbysundell.com/tips/character-category-properties">category properties</a> to form key path-based patterns, combined with patterns that match against the <code>Optional</code> enum‚Äôs two cases, as well as <code>where</code> clauses:</p><pre class="splash"><code><span class="s-keyword">struct</span> ListItemParser {
    <span class="s-keyword">enum</span> Kind {
        <span class="s-keyword">case</span> numbered
        <span class="s-keyword">case</span> unordered
    }

    <span class="s-keyword">let</span> kind: <span class="s-type">Kind</span>

    <span class="s-keyword">func</span> parseLine(<span class="s-keyword">_</span> line: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">ListItem</span> {
        <span class="s-comment">// Here we're switching on an optional Character, which is
        // the type of values that Swift strings are made up of:</span>
        <span class="s-keyword">switch</span> line.<span class="s-property">first</span> {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">none</span>:
            <span class="s-keyword">throw</span> <span class="s-type">Error</span>.<span class="s-property">emptyLine</span>
        <span class="s-keyword">case</span> \.<span class="s-property">isNewline</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">empty</span>
        <span class="s-keyword">case</span> \.<span class="s-property">isNumber</span> <span class="s-keyword">where</span> kind == .<span class="s-dotAccess">numbered</span>:
            <span class="s-keyword">return</span> <span class="s-call">parseLineAsNumberedItem</span>(line)
        <span class="s-keyword">case</span> <span class="s-string">"-"</span> <span class="s-keyword">where</span> kind == .<span class="s-dotAccess">unordered</span>:
            <span class="s-keyword">return</span> <span class="s-call">parseLineAsUnorderedItem</span>(line)
        <span class="s-keyword">case</span> .<span class="s-dotAccess">some</span>(<span class="s-keyword">let</span> character):
            <span class="s-keyword">throw</span> <span class="s-type">Error</span>.<span class="s-call">invalidFirstCharacter</span>(character)
        }
    }
}</code></pre><p class="info">The <code>.none</code> and <code>.some</code> cases used above are the two cases that make up Swift‚Äôs <code>Optional</code> enum, which is the type used to model all optional values within a Swift program.</p><p>As if the above wasn‚Äôt cool enough, let‚Äôs also take a look at how we could take any key path-based expression and combine it with a value comparison ‚Äî enabling us to compose the two in order to form even more powerful patterns.</p><p>To make that happen, let‚Äôs define yet another operator overload, this time of <code>==</code> ‚Äî which will return a <code>Pattern</code> that combines a <code>KeyPath</code> and a constant value, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> ==&lt;<span class="s-type">T</span>, <span class="s-type">V</span>: <span class="s-type">Equatable</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">V</span>&gt;, rhs: <span class="s-type">V</span>) -&gt; <span class="s-type">Pattern</span>&lt;<span class="s-type">T</span>&gt; {
    <span class="s-keyword">return</span> <span class="s-type">Pattern</span> { $0[keyPath: lhs] == rhs }
}</code></pre><p>To take the above for a spin, let‚Äôs say that we‚Äôre now working on a shopping app, and that we‚Äôre calculating the shipping cost for each order based on the <code>Destination</code> that it‚Äôll be sent to. In this example, our logistics center is located in the city of Paris, which lets us to offer free shipping to everyone living in that city, as well as reduced shipping costs within Europe.</p><p>Since we‚Äôre now able to combine key paths with values to form patterns, we can simply implement the way we calculate what level of shipping costs that are associated with a given <code>Destination</code> like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Destination {
    <span class="s-keyword">var</span> address: <span class="s-type">String</span>
    <span class="s-keyword">var</span> city: <span class="s-type">String</span>
    <span class="s-keyword">var</span> country: <span class="s-type">Country</span>
}

<span class="s-keyword">extension</span> <span class="s-type">Destination</span> {
    <span class="s-keyword">var</span> shippingCost: <span class="s-type">ShippingCost</span> {
        <span class="s-keyword">switch self</span> {
        <span class="s-comment">// Combining a key path with a constant value:</span>
        <span class="s-keyword">case</span> \.<span class="s-property">city</span> == <span class="s-string">"Paris"</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">free</span>
        <span class="s-comment">// Using a nested key path as a pattern:</span>
        <span class="s-keyword">case</span> \.<span class="s-property">country</span>.<span class="s-property">isInEurope</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">reduced</span>
        <span class="s-keyword">default</span>:
            <span class="s-keyword">return</span> .<span class="s-dotAccess">normal</span>
        }
    }
}</code></pre><p>Pretty cool! Not only does the above read really nicely, it also enables us to easily insert new rules whenever needed, in a way that doesn‚Äôt necessarily increase the complexity of our code. We could also keep iterating on our <code>Pattern</code> struct, and the ways it can be combined with key paths, in order to enable even more powerful combinations to be created.</p><h2>Conclusion</h2><p>The fact that Swift‚Äôs pattern matching feature isn‚Äôt only specifically implemented for a small number of hard-coded types, but is rather a completely dynamic system that can be extended and customized, gives us some incredibly powerful capabilities.</p><p>However, like with any powerful system, it‚Äôs important to carefully consider when and how to deploy it ‚Äî and to always use the resulting call sites as guidance as to what kind of patterns that we want to be able to construct. After all, the end goal of using powerful patterns to model complex logic using single <code>switch</code> statements should be to make that logic easier to understand, not the other way around.</p><p>What do you think? To what extent have you used Swift‚Äôs pattern matching capabilities so far, and will you try any of the techniques mentioned in this article within your code base? Let me know ‚Äî and feel free to send me any questions, comments or feedback that you have ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift</guid><title>Combining value and reference types in Swift</title><description>Let‚Äôs take a look at how combining value and reference types can unlock some really powerful capabilities, enabling us to utilize both the convenience of reference types, and the safety and limited mutability of value types.</description><link>https://www.swiftbysundell.com/articles/combining-value-and-reference-types-in-swift</link><pubDate>Sun, 10 Nov 2019 18:00:00 +0100</pubDate><content:encoded><![CDATA[<p>A very common type of decision that all Swift developers have to make on an ongoing basis is whether to model a given piece of functionality or state as either a <em>value</em> or a <em>reference</em>. While values give us very clear semantics, as each value is automatically copied when passed, references enable us to establish a single source of truth ‚Äî even though that might mean sharing state, which can also become a liability if we‚Äôre not careful.</p><p>However, not all of those decisions need to result in <em>either</em> a reference type or a value type ‚Äî sometimes <em>combining</em> the two can give us some really powerful capabilities, and open up some incredibly interesting code design options. That‚Äôs exactly what we‚Äôll explore this week ‚Äî let‚Äôs dive in!</p><h2>Collections of weak references</h2><p>Often when establishing a relationship between two kinds of objects we‚Äôd like one side of that relationship to be referenced <em>weakly</em> (since if both sides reference each other strongly, that‚Äôd lead to a <a href="https://www.swiftbysundell.com/basics/memory-management">retain cycle</a>).</p><p>For example, let‚Äôs say that we‚Äôre building a <code>VideoPlayer</code>, and that we‚Äôd like to enable another object to observe it. To make that happen, we might define a class-bound <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-1">observation protocol</a> called <code>PlaybackObserver</code>, and then enable a conforming object to attach itself to our video player through an <code>observer</code> property:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    <span class="s-keyword">weak var</span> observer: <span class="s-type">PlaybackObserver</span>?
    ...
}</code></pre><p class="info">Arguably, if our <code>VideoPlayer</code> will maintain a 1:1 relationship to its observer, it might be more appropriate to make it a <a href="https://www.swiftbysundell.com/articles/delegation-in-swift">delegate instead</a>.</p><p>While the above approach works as long as we only support a <em>single</em> observer to be attached to each video player, once we add support for multiple ones, things start to get tricky ‚Äî as we‚Äôd have to store our observers within some form of collection, like an <code>Array</code>:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    <span class="s-keyword">private var</span> observers = [<span class="s-type">PlaybackObserver</span>]()

    <span class="s-keyword">func</span> addObserver(<span class="s-keyword">_</span> observer: <span class="s-type">PlaybackObserver</span>) {
        observers.<span class="s-call">append</span>(observer)
    }
    
    ...
}</code></pre><p>The problem is that, by making the above change, our observers are no longer stored weakly (since arrays retain their elements strongly). Thankfully, that‚Äôs quite easily fixed, by combining our <em>reference type-based</em> <code>PlaybackObserver</code> protocol with a <em>boxing value type</em> ‚Äî which‚Äôll simply wrap an observer instance by storing a weak reference to it, like this:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">VideoPlayer</span> {
    <span class="s-keyword">struct</span> Observation {
        <span class="s-keyword">weak var</span> observer: <span class="s-type">PlaybackObserver</span>?
    }
}</code></pre><p>With the above in place, we can now update our <code>VideoPlayer</code> to store <code>Observation</code> values, rather than direct (strong) references to each observer ‚Äî which‚Äôll break any possible retain cycles, since each observer is now again referenced weakly:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    <span class="s-keyword">private var</span> observations = [<span class="s-type">Observation</span>]()

    <span class="s-keyword">func</span> addObserver(<span class="s-keyword">_</span> observer: <span class="s-type">PlaybackObserver</span>) {
        <span class="s-keyword">let</span> observation = <span class="s-type">Observation</span>(observer: observer)
        observations.<span class="s-call">append</span>(observation)
    }
    
    ...
}</code></pre><p class="info">To learn more about the above way of managing observations, and the observer pattern in general, check out the two-part article <a href="https://www.swiftbysundell.com/articles/observers-in-swift-part-1">‚ÄúObservers in Swift‚Äù</a>.</p><p>While the above implementation solved the problem of storing instances of a <em>specific type</em> in a weak fashion, let‚Äôs now say that we want to generalize that concept to let us use the same implementation within different parts of a code base. An initial idea on how to do that might be to create a generic <code>Weak</code> struct, which ‚Äî similar to our above <code>Observation</code> type ‚Äî stores a given object weakly:</p><pre class="splash"><code><span class="s-keyword">struct</span> Weak&lt;Object: <span class="s-type">AnyObject</span>&gt; {
    <span class="s-keyword">weak var</span> object: <span class="s-type">Object</span>?
}</code></pre><p>However, while the above <code>Weak</code> type will work great as long as we know the <em>exact type</em> of the object that it should store, it‚Äôll turn out to be quite problematic for protocol types. Even though a protocol might be class-bound (in that it‚Äôs constrained to <code>AnyObject</code>, which only makes it possible for classes to conform to it), it doesn‚Äôt make the <em>protocol itself</em> a class type. So if we tried to use our new <code>Weak</code> type within our <code>VideoPlayer</code>, we‚Äôd get this kind of compiler error:</p><pre class="splash"><code><span class="s-comment">// Error: 'Weak' requires that 'PlaybackObserver' be a class type</span>
<span class="s-keyword">private var</span> observations = [<span class="s-type">Weak</span>&lt;<span class="s-type">PlaybackObserver</span>&gt;]()</code></pre><p>At this point, it might seem like all hope is lost, but it turns out that there is <em>a way</em> for us to achieve what we want ‚Äî which involves using a capturing closure, rather than a <code>weak</code> property, to implement our object reference ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Weak&lt;Object&gt; {
    <span class="s-keyword">var</span> object: <span class="s-type">Object</span>? { <span class="s-call">provider</span>() }
    <span class="s-keyword">private let</span> provider: () -&gt; <span class="s-type">Object</span>?

    <span class="s-keyword">init</span>(<span class="s-keyword">_</span> object: <span class="s-type">Object</span>) {
        <span class="s-comment">// Any Swift value can be "promoted" to an AnyObject, however,
        // that doesn't automatically turn it into a reference.</span>
        <span class="s-keyword">let</span> reference = object <span class="s-keyword">as</span> <span class="s-type">AnyObject</span>

        provider = { [<span class="s-keyword">weak</span> reference] <span class="s-keyword">in</span>
            reference <span class="s-keyword">as</span>? <span class="s-type">Object</span>
        }
    }
}</code></pre><p>The downside of the above approach is that we‚Äôre now able to initialize our <code>Weak</code> struct with any object or value, not only with class instances. However, that might not be such a big deal, especially if we‚Äôre only using it as an implementation detail for tasks like managing observers. Because the upside is that we can now easily store collections of protocol-conforming instances weakly ‚Äî enabling us to update our <code>VideoPlayer</code> from before to now look like this:</p><pre class="splash"><code><span class="s-keyword">class</span> VideoPlayer {
    <span class="s-keyword">private var</span> observations = [<span class="s-type">Weak</span>&lt;<span class="s-type">PlaybackObserver</span>&gt;]()

    <span class="s-keyword">func</span> addObserver(<span class="s-keyword">_</span> observer: <span class="s-type">PlaybackObserver</span>) {
        observations.<span class="s-call">append</span>(<span class="s-type">Weak</span>(observer))
    }
    
    ...
}</code></pre><p>Pretty cool! Whether or not it‚Äôs worth it to create a generic <code>Weak</code> wrapper, rather than just using specific ones (like the <code>Observation</code> type we started out with), will of course depend heavily on how many use cases for storing collections of weak references that we have. Like always, it‚Äôs often best to start out with a very specific implementation, and then generalize later if needed.</p><h2>Passing references to value types</h2><p>Next, let‚Äôs flip the coin ‚Äî and take a look at how reference types can be used to wrap value types. Let‚Äôs say that we‚Äôre building an app that stores various user-configurable settings using a value type that looks like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Settings {
    <span class="s-keyword">var</span> colorTheme: <span class="s-type">ColorTheme</span>
    <span class="s-keyword">var</span> rememberLoggedInUser: <span class="s-type">Bool</span>
    ...
}</code></pre><p>While defining core data models as values is usually a good idea, as it lets us <a href="https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift">fully utilize value semantics</a> ‚Äî sometimes we might want to enable multiple objects to share a reference to a single instance of a given model.</p><p>For example, let‚Äôs say that we wanted multiple parts of our code base to be able to read and modify the same <code>Settings</code> value, without having to implement any complex data flows. One way to accomplish that would be to create another boxing type, just like our <code>Weak</code> struct from before, but this time to enable us to wrap a value type inside of a reference type ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> Reference&lt;Value&gt; {
    <span class="s-keyword">var</span> value: <span class="s-type">Value</span>

    <span class="s-keyword">init</span>(value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }
}</code></pre><p>With the above in place, we can now easily turn any value type into a reference, simply by wrapping it in a <code>Reference</code> instance, and then passing that instance to whichever object or function that we want to share our value with:</p><pre class="splash"><code><span class="s-keyword">let</span> settings = <span class="s-call">loadSettings</span>()
<span class="s-keyword">let</span> sharedSettings = <span class="s-type">Reference</span>(value: settings)</code></pre><p>For example, here‚Äôs how a <code>ProfileViewModel</code> could accept a referenced <code>Settings</code> value, rather than just a copy of one:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewModel {
    <span class="s-keyword">private let</span> user: <span class="s-type">User</span>
    <span class="s-keyword">private let</span> settings: <span class="s-type">Reference</span>&lt;<span class="s-type">Settings</span>&gt;

    <span class="s-keyword">init</span>(user: <span class="s-type">User</span>, settings: <span class="s-type">Reference</span>&lt;<span class="s-type">Settings</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">user</span> = user
        <span class="s-keyword">self</span>.<span class="s-property">settings</span> = settings
    }
    
    <span class="s-keyword">func</span> makeEmailAddressIcon() -&gt; <span class="s-type">Icon</span> {
        <span class="s-keyword">var</span> icon = <span class="s-type">Icon</span>.<span class="s-property">email</span>
        icon.<span class="s-property">useLightVersion</span> = settings.<span class="s-property">value</span>.<span class="s-property">colorTheme</span>.<span class="s-property">isDark</span>
        <span class="s-keyword">return</span> icon
    }
    
    ...
}</code></pre><p>While the above approach is a really convenient way to share value type-based data across an app, it does come with two major downsides. The first is that we have to always access the passed reference‚Äôs <code>value</code> property in order to <em>actually</em> get access to the value that we‚Äôre interested in, and the second is that we‚Äôre now sharing <em>mutable state</em> between multiple parts of our code base.</p><p>While we can‚Äôt do much about the first downside (unless we want to replicate each of our value type‚Äôs APIs within our reference type, which kind of defeats the point of it), we <em>could</em> limit our state‚Äôs mutability ‚Äî which often helps make a system a bit more predictable and easier to debug, since the number of places in which a piece of state can be modified is reduced.</p><p>One way to do that is to make our <code>Reference</code> type immutable, and then create a mutable subclass of it (let‚Äôs call it <code>MutableReference</code>). That way, only the creator of a reference will be able to mutate it, since it can simply be passed as an immutable <code>Reference</code> afterwards:</p><pre class="splash"><code><span class="s-keyword">class</span> Reference&lt;Value&gt; {
    <span class="s-keyword">fileprivate(set) var</span> value: <span class="s-type">Value</span>

    <span class="s-keyword">init</span>(value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }
}

<span class="s-keyword">class</span> MutableReference&lt;Value&gt;: <span class="s-type">Reference</span>&lt;<span class="s-type">Value</span>&gt; {
    <span class="s-keyword">func</span> update(with value: <span class="s-type">Value</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">value</span> = value
    }
}</code></pre><p>Here‚Äôs an example of how the above can be really useful, since it lets us update our shared value reference whenever needed, while still enabling us to pass it as an immutable object ‚Äî without having to do any kind of conversion:</p><pre class="splash"><code><span class="s-keyword">let</span> settings = <span class="s-call">loadSettings</span>()

<span class="s-comment">// Since this part of our code base knows that our reference is
// mutable, it can easily update it whenever needed:</span>
<span class="s-keyword">let</span> sharedSettings = <span class="s-type">MutableReference</span>(value: settings)
<span class="s-call">observeSettingsChange</span>(with: sharedSettings.<span class="s-property">update</span>)

<span class="s-comment">// Since our view model accepts an immutable reference, it won't
// be able to mutate our value in any way:</span>
<span class="s-keyword">let</span> viewModel = <span class="s-type">ProfileViewModel</span>(settings: sharedSettings)</code></pre><p>The above kind of boxing types can be incredibly useful, especially if we limit their mutation capabilities to only be visible within the parts of our code base that <em>should</em> be able to mutate them ‚Äî as that can give us much of the flexibility and power of reference types, without the problems that usually start to occur when over-sharing mutable state.</p><p>However, when deploying boxing types, it‚Äôs always worth considering whether another abstraction (such as a <a href="https://www.swiftbysundell.com/articles/model-controllers-in-swift">model controller</a>, a <a href="https://www.swiftbysundell.com/articles/bindable-values-in-swift">bindable value</a>, or a reactive framework such as Combine) would be more appropriate. Especially if the way we share and pass values across our app grows more complex, a more powerful abstraction might be the way to go ‚Äî even though we might choose to start out with something like the above <code>Reference</code> type in order to keep things simple initially.</p><h2>Using reference types as underlying storage</h2><p>Finally, let‚Äôs go beyond boxing types and take a look at how value and reference types can be truly combined to unlock some really powerful capabilities. Let‚Äôs say that we‚Äôve defined a value type that lets us express complex formatted texts, by splitting them up into separate components that can then be rendered into an <code>NSAttributedString</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> FormattedText {
    <span class="s-keyword">var</span> components: [<span class="s-type">Component</span>]

    <span class="s-keyword">func</span> render() -&gt; <span class="s-type">NSAttributedString</span> {
        <span class="s-keyword">let</span> result = <span class="s-type">NSMutableAttributedString</span>()
        components.<span class="s-call">forEach</span> { result.<span class="s-call">append</span>($0.<span class="s-call">render</span>()) }
        <span class="s-keyword">return</span> result
    }
}</code></pre><p>While the above provides a nice, <em>‚ÄúSwifty‚Äù</em> way of building up attributed strings, it requires an <code>O(n)</code> evaluation every time that we want to display each text ‚Äî which will result in duplicate work when rendering the same text in multiple places.</p><p>To address that, let‚Äôs take some inspiration from the Swift standard library, which uses pointers and references as storage for certain key value types ‚Äî such as <code>String</code> and <code>Array</code> ‚Äî to give them <em>copy-on-write</em> semantics. What that means is that multiple values can share the same underlying storage until one of them is actually mutated, minimizing the amount of copy operations that need to occur as we pass values around (since only the <em>‚Äúvalue type shell‚Äù</em> is actually copied).</p><p>In our case, we‚Äôll use a similar approach, but for a slightly different purpose ‚Äî to implement a <code>RenderingCache</code> for our above <code>FormattedText</code> type. That way we‚Äôll only have to render each copy of the same text once, which should significantly boost performance in situations when the same text is used in multiple places (effectively turning each subsequent rendering pass into an <code>O(1)</code> operation).</p><p>Our cache will be a simple class, which only has one job ‚Äî to store the result of a previous rendering operation:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">FormattedText</span> {
    <span class="s-keyword">class</span> RenderingCache {
        <span class="s-keyword">var</span> result: <span class="s-type">NSAttributedString</span>?
    }
}</code></pre><p>Then, as we‚Äôve finished rendering an <code>NSAttributedString</code>, we‚Äôll store the result in an instance of our <code>RenderingCache</code> ‚Äî which will be replaced whenever our <code>components</code> array is mutated. That way we‚Äôre avoiding caching stale data, and since our cache is a reference type, it will keep being pointed to the same instance ‚Äî even as a <code>FormattedText</code> value gets passed around our app.</p><p>Here‚Äôs what the complete implementation looks like:</p><pre class="splash"><code><span class="s-keyword">struct</span> FormattedText {
    <span class="s-keyword">var</span> components: [<span class="s-type">Component</span>] {
        <span class="s-keyword">didSet</span> { cache = <span class="s-type">RenderingCache</span>() }
    }

    <span class="s-keyword">private var</span> cache = <span class="s-type">RenderingCache</span>()

    <span class="s-keyword">init</span>(components: [<span class="s-type">Component</span>] = []) {
        <span class="s-keyword">self</span>.<span class="s-property">components</span> = components
    }

    <span class="s-keyword">func</span> render() -&gt; <span class="s-type">NSAttributedString</span> {
        <span class="s-keyword">if let</span> cached = cache.<span class="s-property">result</span> {
            <span class="s-keyword">return</span> cached
        }

        <span class="s-keyword">let</span> result = <span class="s-type">NSMutableAttributedString</span>()
        components.<span class="s-call">forEach</span> { result.<span class="s-call">append</span>($0.<span class="s-call">render</span>()) }
        cache.<span class="s-property">result</span> = result

        <span class="s-keyword">return</span> result
    }
}</code></pre><p>By using a reference type as our underlying storage, while keeping the API surface entirely value-type based ‚Äî we can combine the performance benefits of having a single source of truth, while still enabling the users of our API to take full advantage of value semantics, by limiting mutability and by not publicly sharing state.</p><h2>Conclusion</h2><p>The fact that Swift fully supports both value and reference types gives us a ton of flexibility when it comes to how we design our APIs, how we construct their underlying implementations, and how state is managed within an app or system.</p><p>While most types will probably continue being either purely a value or a class, sometimes, by combining the two we can achieve some really powerful results ‚Äî enabling us to utilize both the convenience and performance characteristics of reference types, and the safety and limited mutability of value types.</p><p>What do you think? Have you ever used one of the techniques mentioned in this article, or could they become useful to you either now or in the future? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/enums</guid><title>Basics: Enums</title><description>How enums work in Swift, a look at some of their most prominent features, and examples of situations in which they can be incredibly useful.</description><link>https://www.swiftbysundell.com/basics/enums</link><pubDate>Fri, 8 Nov 2019 18:30:00 +0100</pubDate><content:encoded><![CDATA[<p>An enum is a type that <em>enumerates</em> a finite set of values, such as raw values, like strings or integers. They‚Äôre really useful when modeling things like options, states, or anything else that can be described using a pre-defined number of values.</p><p>Let‚Äôs take a look at how enums work in Swift, some of their most prominent features, and examples of situations in which they can come very much in handy.</p><p>An enum is defined using the <code>enum</code> keyword, and can contain any number of <code>case</code> declarations that each define one of the enum‚Äôs possible states ‚Äî like how this <code>ContactType</code> enum contains cases for various kinds of contacts:</p><pre class="splash"><code><span class="s-keyword">enum</span> ContactType {
    <span class="s-keyword">case</span> friend
    <span class="s-keyword">case</span> family
    <span class="s-keyword">case</span> coworker
    <span class="s-keyword">case</span> businessPartner
}</code></pre><p>When using an instance of the above enum, we‚Äôll get a compile-time guarantee that it‚Äôll always be equal to one of the above cases ‚Äî which is what makes enums such a great match for <code>switch</code> statements (which, by default, have to be exhaustive):</p><pre class="splash"><code><span class="s-keyword">func</span> iconName(forContactType type: <span class="s-type">ContactType</span>) -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">switch</span> type {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">friend</span>:
        <span class="s-keyword">return</span> <span class="s-string">"friend"</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">family</span>:
        <span class="s-keyword">return</span> <span class="s-string">"family"</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">coworker</span>:
        <span class="s-keyword">return</span> <span class="s-string">"coworker"</span>
    <span class="s-keyword">case</span> .<span class="s-dotAccess">businessPartner</span>:
        <span class="s-keyword">return</span> <span class="s-string">"business_partner"</span>
    }
}</code></pre><p class="info">If we add a new case to our enum in the future, then the compiler will give us an error for the above code ‚Äî which is great, as it forces us to decide how we want to handle the new case.</p><p>Our <code>ContactType</code> enum currently doesn‚Äôt represent any concrete value, but rather just acts as an abstract representation of a contact type. To change that, we simply have to add a raw type (like <code>String</code> or <code>Int</code>) to our enum declaration ‚Äî like this:</p><pre class="splash"><code><span class="s-comment">// By adding ": String" after its name, we've now made our enum
// representable by a raw value ‚Äî String in this case:</span>
<span class="s-keyword">enum</span> ContactType: <span class="s-type">String</span> {
    <span class="s-keyword">case</span> friend
    <span class="s-keyword">case</span> family
    <span class="s-keyword">case</span> coworker
    <span class="s-comment">// We can also customize what exact raw value that we want a
    // case to be represented by (the default will match the
    // case's name for strings, and its index for integers):</span> 
    <span class="s-keyword">case</span> businessPartner = <span class="s-string">"business_partner"</span>
}</code></pre><p>The beauty of the above change is that it enables us to easily convert any <code>ContactType</code> value into a <code>String</code> ‚Äî meaning that we can now rewrite our <code>iconName</code> function from before to look like this instead:</p><pre class="splash"><code><span class="s-keyword">func</span> iconName(forContactType type: <span class="s-type">ContactType</span>) -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">return</span> type.<span class="s-property">rawValue</span>
}</code></pre><p>That works both ways, as we can now also easily convert a <code>String</code> value into a <code>ContactType</code> instance as well, given that the string matches the raw value of one of our cases:</p><pre class="splash"><code><span class="s-comment">// A valid raw value will be matched to its corresponding case,
// while an invalid one will result in 'nil':</span>
<span class="s-keyword">let</span> valid = <span class="s-type">ContactType</span>(rawValue: <span class="s-string">"coworker"</span>) <span class="s-comment">// .coworker</span>
<span class="s-keyword">let</span> invalid = <span class="s-type">ContactType</span>(rawValue: <span class="s-string">"unknown"</span>) <span class="s-comment">// nil</span></code></pre><p>Besides being representable by raw values, enums can also carry <em>associated values</em> ‚Äî which are values placed within individual enum cases. For example, here we‚Äôve defined a <code>ReadState</code> enum, which is used to describe a user‚Äôs progress through a book:</p><pre class="splash"><code><span class="s-keyword">enum</span> ReadState {
    <span class="s-comment">// The user hasn't started reading the book yet:</span>
    <span class="s-keyword">case</span> unread
    <span class="s-comment">// The user is currently reading the book at a
    // given page number:</span>
    <span class="s-keyword">case</span> inProgress(pageNumber: <span class="s-type">Int</span>)
    <span class="s-comment">// The user has finished reading the book, and gave it
    // a given rating once done:</span>
    <span class="s-keyword">case</span> finished(rating: <span class="s-type">Rating</span>)
}</code></pre><p class="info">Note that an enum cannot have <strong>both</strong> a raw value type and associated values.</p><p>Associated enum values are incredibly flexible, since each case is free to define its very own set of values (like above). That‚Äôs particularly useful when <a href="https://www.swiftbysundell.com/articles/modelling-state-in-swift">modeling state</a>, since rather than having to define all possible state values as optionals, we only have to deal with the values that are relevant for the <em>current</em> state ‚Äî again something that‚Äôs really useful when using a <code>switch</code> statement to handle an enum value:</p><pre class="splash"><code><span class="s-keyword">func</span> restore(fromState state: <span class="s-type">ReadState</span>) {
    <span class="s-keyword">switch</span> state {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">unread</span>:
        <span class="s-call">openBook</span>()
    <span class="s-keyword">case</span> .<span class="s-dotAccess">inProgress</span>(<span class="s-keyword">let</span> pageNumber):
        <span class="s-call">openBook</span>()
        <span class="s-call">turnToPage</span>(number: pageNumber)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">finished</span>(<span class="s-keyword">let</span> rating):
        <span class="s-call">displayRating</span>(rating)
    }
}</code></pre><p>Finally, let‚Äôs take a look at a few different ways to <em>declare</em> an enum value. Another thing that makes enums so nice in Swift is that they support <em>‚Äúdot-syntax‚Äù</em> ‚Äî which lets us refer to any enum case simply by prefixing it with a dot, when the enum‚Äôs type can be inferred by the compiler.</p><p>For example, here‚Äôs how we could call the above <code>restore</code> function using dot-syntax:</p><pre class="splash"><code><span class="s-call">restore</span>(fromState: .<span class="s-dotAccess">unread</span>)
<span class="s-call">restore</span>(fromState: .<span class="s-call">inProgress</span>(pageNumber: <span class="s-number">5</span>))</code></pre><p>While dot-syntax is arguably just <em>syntactic sugar</em>, it can make our function calls read so much nicer ‚Äî effectively enabling us to read the above code more or less like normal English sentences.</p><p>However, when the underlying type can‚Äôt be inferred by the compiler, we do have to declare it ‚Äî for example when storing an instance of the above <code>ReadState</code> enum as a property:</p><pre class="splash"><code><span class="s-keyword">struct</span> BookSession {
    <span class="s-keyword">var</span> book: <span class="s-type">Book</span>
    <span class="s-keyword">var</span> readState: <span class="s-type">ReadState</span> = .<span class="s-dotAccess">unread</span>
}</code></pre><p class="info">We could also have declared the above <code>readState</code> property as <code>ReadState.unread</code>, which would‚Äôve yielded the exact same result.</p><p>Swift enums are both incredibly powerful and flexible, and could also be used to simplify our code ‚Äî by pre-defining the number of states or configurations that a given value can be in at compile-time.</p><p>That‚Äôs a key part though, because enums are only really useful when the number of states can be specified up-front ‚Äî so for more free-form values that can only be determined at runtime, other constructs (like structs, protocols, or classes) are most likely going to be more appropriate.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/implementing-throwing-protocol-functions-as-non-throwing</guid><title>Tip: Implementing throwing protocol functions as non-throwing</title><description>In Swift, it‚Äôs possible to satisfy a throwing function protocol requirement using a non-throwing function, which can be very useful in certain situations.</description><link>https://www.swiftbysundell.com/tips/implementing-throwing-protocol-functions-as-non-throwing</link><pubDate>Tue, 5 Nov 2019 21:45:00 +0100</pubDate><content:encoded><![CDATA[<p>In Swift, it‚Äôs possible to satisfy a throwing function protocol requirement using a non-throwing function, which can be very useful in certain situations. For example, let‚Äôs say that we‚Äôve defined a protocol for parsers that enable us tokenize a string in some way:</p><pre class="splash"><code><span class="s-keyword">protocol</span> TokenParser {
    <span class="s-keyword">func</span> parseToken(from string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Token</span>
}</code></pre><p>While certain implementations of the above protocol will need to throw, that won‚Äôt necessarily be true for all conforming types. For example, the below <code>KeywordParser</code> throws, while <code>TextParser</code> doesn‚Äôt:</p><pre class="splash"><code><span class="s-keyword">struct</span> KeywordParser: <span class="s-type">TokenParser</span> {
    <span class="s-keyword">func</span> parseToken(from string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Token</span> {
        ...
    }
}

<span class="s-keyword">struct</span> TextParser: <span class="s-type">TokenParser</span> {
    <span class="s-comment">// This will satisfy our protocol requirement, even though
    // this implementation doesn't actually throw:</span>
    <span class="s-keyword">func</span> parseToken(from string: <span class="s-type">String</span>) -&gt; <span class="s-type">Token</span> {
        ...
    }
}</code></pre><p>Since the original declaration of our protocol function is marked as throwing, we‚Äôll always need to call it with <code>try</code> when the exact conforming type isn‚Äôt known ‚Äî regardless of whether the underlying implementation <em>actually</em> throws:</p><pre class="splash"><code><span class="s-keyword">let</span> parsers: [<span class="s-type">TokenParser</span>] = ...

<span class="s-keyword">for</span> parser <span class="s-keyword">in</span> parsers {
    <span class="s-comment">// Since all we know about each parser within this iteration
    // is that it conforms to our 'TokenParser' protocol, we'll
    // need to use 'try' when calling its function:</span>
    <span class="s-keyword">let</span> token = <span class="s-keyword">try</span> parser.<span class="s-call">parseToken</span>(from: string)
}</code></pre><p>However, when dealing with a non-throwing conforming type directly, we can now omit the <code>try</code> keyword ‚Äî even though the original protocol requirement was marked as throwing:</p><pre class="splash"><code><span class="s-keyword">let</span> parser = <span class="s-type">TextParser</span>()
<span class="s-keyword">let</span> text = parser.<span class="s-call">parseToken</span>(from: string)</code></pre><p>It‚Äôs a small feature, but the fact that we can implement a throwing function requirement using a non-throwing one gives us a slightly greater degree of flexibility when conforming to protocols that contain such functions.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/deciding-whether-to-adopt-new-swift-technologies</guid><title>Deciding whether to adopt new Swift technologies</title><description>This week, let‚Äôs take a look at a few tips and ways of thinking when it comes to approaching new tools and technologies ‚Äî using the decision of whether or not to be an early adopter of SwiftUI as an example.</description><link>https://www.swiftbysundell.com/articles/deciding-whether-to-adopt-new-swift-technologies</link><pubDate>Sun, 3 Nov 2019 20:30:00 +0100</pubDate><content:encoded><![CDATA[<p>As Swift developers, the ways we build apps and the tools that we use are constantly changing. Every year, there‚Äôs a huge amount of new technologies, tools, frameworks, and language features coming out ‚Äî both from Apple and third party developers ‚Äî and while many of them are both useful and exciting, it can sometimes be challenging to keep up with this very rapid flow of changes.</p><p>Since everything is moving so fast, and there‚Äôs no indication of things ever really slowing down ‚Äî making decisions as to what new technologies to adopt becomes incredibly important, especially as a project grows in both size and complexity. This week, let‚Äôs take a look at a few tips and ways of thinking when it comes to approaching new tools and technologies ‚Äî using the decision of whether or not to be an early adopter of <a href="https://www.swiftbysundell.com/basics/swiftui">SwiftUI</a> as an example.</p><h2>To be, or not to be, production-ready</h2><p>Whenever a new tool, library or framework comes out, there‚Äôs one main question that tends to get asked really frequently: <em>is this new piece of technology ‚Äúproduction-ready‚Äù?</em></p><p>While that‚Äôs a great question to ask, the answers are most often very context-specific. What the criteria are for something to be considered <em>production-ready</em> tend to vary quite a lot, both from person to person, and depending on what sort of environment that the technology will be deployed in. For one person, <em>production-ready</em> might simply mean that <em>‚Äúit seems to work when used‚Äù</em>, while others might have a much more extensive list of requirements to be fulfilled.</p><p>So rather than trying to obtain a singular answer as to whether the technology we‚Äôre looking to adopt is universally <em>production-ready</em>, it‚Äôs often much more productive to ask a series of questions that‚Äôll let us build up an idea of its current state ‚Äî questions like:</p><ul><li>Are there any examples of this technology being deployed in production, and what seems to be the results?</li><li>What sort of <em>scale</em> do we need this new tool to handle, and does that seem to be what the tool is currently designed for?</li><li>How does the vendor or creator of the tool use it themselves, and does that match the way we‚Äôre planning to use it?</li><li>What sort of documentation and support is available, and does that seem to match our needs?</li></ul><p>In many ways, choosing to become an <em>early adopter</em> of anything ‚Äî whether it‚Äôs hardware or software ‚Äî always comes with a certain degree of risk. However, the more aligned our use case is with what seems to be the most common one, the lower that risk usually becomes ‚Äî and the only way to really find out whether or not that‚Äôs true, is to do a little bit of research before we start writing any code.</p><h2>Non-critical first steps</h2><p>In general, a great way to start adopting a new API or technology is to start by deploying it in a fairly <em>non-critical</em> part of a project. That both reduces the risk of an essential feature breaking, and lets us ease our way into using the new tool ‚Äî to learn about its strengths, weaknesses and edge cases before fully deploying it across the project.</p><p>For example, let‚Äôs say that we‚Äôre currently deciding whether or not to adopt SwiftUI, and that we‚Äôve determined that it seems to be ‚Äåproduction-ready for our use case. However, since fully embracing SwiftUI requires us to drop support for older operating system versions ‚Äî we‚Äôd first like to test it in a way that lets us still maintain complete backward compatibility.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/shifting-paradigms-in-swift/">‚ÄúShifting paradigms in Swift‚Äù</a></em>, one way to do that is to add all of our SwiftUI code behind <em>availability checks</em> ‚Äî which will let us keep running our app on older system versions, by only activating our SwiftUI-related code when running on devices that support it.</p><p>Let‚Äôs say that our app contains a feature that lets us show some form of promotion to our users, and that it‚Äôs not something we consider to be essential for our overall user experience ‚Äî so we decide to use that feature as our <em>SwiftUI testbed</em>, by implementing it as a <code>View</code> marked with the <code>@available</code> attribute:</p><pre class="splash"><code><span class="s-keyword">import</span> SwiftUI

<span class="s-keyword">@available</span>(iOS <span class="s-number">13</span>, *)
<span class="s-keyword">struct</span> PromotionView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> { ... }
}</code></pre><p>Doing the above will give us a compiler error if we ever try to use our new <code>PromotionView</code> within code paths that aren‚Äôt guaranteed to only be executed on iOS 13 and above ‚Äî so to give the compiler that guarantee, we‚Äôll use an <code>#available</code> check at the call site, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> presentPromotion(in presentingViewController: <span class="s-type">UIViewController</span>) {
    <span class="s-comment">// Using this statement will let us assume that the rest
    // of this function will only be executed on iOS 13 and above:</span>
    <span class="s-keyword">guard #available</span>(iOS <span class="s-number">13</span>, *) <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span>
    }
    
    <span class="s-comment">// We also add a dynamic feature flag that'll let us control
    // whether our promotion feature will be enabled at runtime,
    // essentially acting as an additional safety mechanism in
    // case something goes wrong and we need to disable it:</span>
    <span class="s-keyword">guard</span> featureFlags.<span class="s-property">enablePromotion</span> <span class="s-keyword">else</span> {
        <span class="s-keyword">return</span>
    }

    <span class="s-comment">// We can now use iOS 13-only APIs without any problems:</span>
    <span class="s-keyword">let</span> view = <span class="s-type">PromotionView</span>()
    <span class="s-keyword">let</span> viewController = <span class="s-type">UIHostingController</span>(rootView: view)
    presentingViewController.<span class="s-call">present</span>(viewController, animated: <span class="s-keyword">true</span>)
}</code></pre><p class="info">To learn more about feature flags, check out <a href="https://www.swiftbysundell.com/articles/feature-flags-in-swift/">‚ÄúFeature flags in Swift‚Äù</a>.</p><p>Deploying a feature like the above feature in production, and monitoring the results over a period of time, perhaps gives us the very best indication as to whether or not a given piece of technology is something that‚Äôs ready for us to fully adopt. Doing so also lets us start working out how to integrate the new tool with the rest of our code base in a highly encapsulated way ‚Äî which is great in case we decide to not adopt the new tool after all, as it should let us delete our experimental code quite quickly.</p><h2>Where‚Äôs the escape hatch?</h2><p>When adopting new technologies, chances are quite high that we‚Äôll discover gaps in what their various APIs offer ‚Äî especially when compared to older tools that the new ones are aiming to replace. No matter how great a new piece of technology is, building out a diverse set of APIs that cover a lot of ground takes time ‚Äî which is definitely something that we need to take into account when picking what technologies to adopt.</p><p>One thing that creators of tools and frameworks can do to mitigate this problem, however, is to build in some form of <em>‚Äúescape hatch‚Äù</em> ‚Äî that enables us to temporarily step outside the realm of the tool in order to complete a given task. Having such a mechanism available heavily reduces the chance that we‚Äôll get stuck while adopting that technology, and also future-proofs it, as we‚Äôll be able to extend it to better fit our use case.</p><p>Again using SwiftUI as an example ‚Äî since it‚Äôs fully backward compatible with both UIKit and AppKit, that essentially acts as such an escape hatch. If we encounter something that‚Äôs missing in SwiftUI, or if we want to bring some of our existing code into it, we can do so by adopting <a href="https://www.swiftbysundell.com/tips/swiftui-mix-and-match/"><code>UIViewRepresentable</code></a>. Since we can also freely mix and match SwiftUI-based view controllers with UIKit-based ones, we can selectively adopt SwiftUI for the parts of our UI that it works great for ‚Äî while still falling back to UIKit (or AppKit on the Mac) whenever needed:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-comment">// This view controller is implemented using UIKit:</span>
        <span class="s-keyword">let</span> header = <span class="s-type">HeaderViewController</span>()
        ...
        <span class="s-call">add</span>(header)

        <span class="s-comment">// While this one is implemented using SwiftUI:</span>
        <span class="s-keyword">let</span> list = <span class="s-type">ListView</span>()
        <span class="s-keyword">let</span> listWrapper = <span class="s-type">UIHostingController</span>(rootView: list)
        ...
        <span class="s-call">add</span>(listWrapper)
    }
}</code></pre><p class="info">To see the implementation of the above <code>add</code> convenience API for managing child view controllers, check out <a href="https://www.swiftbysundell.com/basics/child-view-controllers">this Basics article</a>.</p><p>Whether or not a given tool supports some form of escape hatch-like mechanism, and how much flexibility that it gives us, is also something that we‚Äôll be able to gradually discover by adopting it slowly ‚Äî feature by feature.</p><h2>Conclusion</h2><p>It‚Äôs close to impossible to universally assert that any new tool, library or framework is fully ready for all kinds of use cases out of the gate ‚Äî as how well any new piece of technology will work depends highly on the context that it‚Äôll be used it. However, by learning from others‚Äô experience, by taking our time to experiment and try out the tool for ourselves, and by making sure that any new technologies that we choose to adopt has some way for us to temporarily work around its limits ‚Äî we can greatly increase our chances of success, even if we choose to become early adopters.</p><p>It‚Äôs also important to point out that <em>not</em> being an early adopter is also a perfectly valid choice ‚Äî and in many circumstances it‚Äôs even the <em>right</em> choice. New technologies will most likely <em>always</em> have problems, and while they might be exciting and fun to use, there‚Äôs rarely any harm in being a bit more conservative with our tech choices ‚Äî especially when working on a larger, existing code base. Like always, it‚Äôs all about finding the right balance between moving our tech stack forward, without running into too many problems along the way.</p><p>To learn more about SwiftUI in particular, and how Apple is both using it internally, as well as some of their plans for improving it ‚Äî make sure to listen to my <a href="https://www.swiftbysundell.com/podcast/59/">podcast interview with Josh Shaffer</a>, engineering director with the UIKit and SwiftUI team.</p><p>What do you think? How do you usually decide whether a given technology is production-ready, and what do you think about the suggestions in this article? Let me know ‚Äî along with any questions, comments and feedback that you might have ‚Äî either <a href="https://www.swiftbysundell.com/contact">via email</a> or <a href="https://twitter.com/johnsundell">on Twitter</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/pragmatic-unit-testing-in-swift</guid><title>Pragmatic unit testing in Swift</title><description>This week, let‚Äôs take a look at a few different ways to deploy unit testing in a more pragmatic manner ‚Äî to use testing to solve immediate problems, and to enable our code to be tested without having to fundamentally change it.</description><link>https://www.swiftbysundell.com/articles/pragmatic-unit-testing-in-swift</link><pubDate>Sun, 27 Oct 2019 21:40:00 +0100</pubDate><content:encoded><![CDATA[<p>It‚Äôs sometimes easy to think of the decision of whether or not to use unit testing as a binary one: either testing is fully embraced, and all of our project‚Äôs code refactored to be completely testable ‚Äî or no testing will be done at all.</p><p>When faced with such a binary decision, it‚Äôs not very surprising that many teams opt for the latter of the two options ‚Äî often because of time constraints, tight deadlines, and important new features that need shipping.</p><p>However, there‚Äôs really no reason to treat unit testing as such a big, binary decision. After all, any form of automated testing is <em>just another tool</em> that we can use to improve our code and the way we work with it. So this week, let‚Äôs take a look at a few different ways to deploy unit testing in a more pragmatic manner ‚Äî to use testing to solve immediate problems, and to enable our code to be tested without having to fundamentally change it.</p><h2>Verifying bug fixes</h2><p>When starting to add unit tests to a project ‚Äî or when wanting to extend the coverage of an existing, partial test suite ‚Äî it can often be hard to decide where to start. Do we start by verifying the functionality that‚Äôs closest to the user and our app‚Äôs UI, and then work our way down the stack, or vice versa?</p><p>Rather than having to search for the perfect starting point, a great way to get into the habit of unit testing changes to a code base is to start by using tests to verify bug fixes. Not only does that let us verify that we <em>actually</em> fixed the bug we were aiming to fix, it also lets us slowly but surely build up a solid suite of tests ‚Äî all while improving the quality of our code at the same time.</p><p>As an example, let‚Äôs say that we‚Äôre working on an app that lets our users read various forms of written content. Historically, our app has only supported books and magazines, but we‚Äôve recently also added support for newspapers ‚Äî with those three types of content being represented using this enum:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span> {
    <span class="s-keyword">enum</span> Kind {
        <span class="s-keyword">case</span> book
        <span class="s-keyword">case</span> magazine
        <span class="s-keyword">case</span> newspaper
    }
}</code></pre><p>Now let‚Äôs say that when shipping the newspaper feature, we started getting reports from users that no newspapers ever show up within the app‚Äôs <em>‚ÄúRecommended‚Äù</em> section ‚Äî which turns out to be a bug caused by the following code:</p><pre class="splash"><code><span class="s-keyword">struct</span> RecommendedItems {
    <span class="s-keyword">var</span> books = [<span class="s-type">Item</span>]()
    <span class="s-keyword">var</span> magazines = [<span class="s-type">Item</span>]()
    <span class="s-keyword">var</span> newspapers = [<span class="s-type">Item</span>]()

    <span class="s-keyword">func</span> items(ofKind kind: <span class="s-type">Item</span>.<span class="s-type">Kind</span>) -&gt; [<span class="s-type">Item</span>] {
        <span class="s-keyword">if</span> kind == .<span class="s-dotAccess">book</span> {
            <span class="s-keyword">return</span> books
        } <span class="s-keyword">else</span> {
            <span class="s-keyword">return</span> magazines
        }
    }
}</code></pre><p>The problem is that we‚Äôre making the assumption that if the requested <code>Item.Kind</code> isn‚Äôt <code>.book</code>, then that must mean that we should return magazines ‚Äî which might‚Äôve made total sense when that code was written (since at that point, books and magazines were the only two kinds of items that we supported).</p><p>While we could of course simply fix the above bug and move on, let‚Äôs use it as an opportunity to add a test that‚Äôll ensure that things will keep working in the future. So <em>before</em> we implement our fix, let‚Äôs add a test for it ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> RecommendedItemsTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testRecommendedNewspapers() {
        <span class="s-keyword">let</span> item = <span class="s-type">Item</span>(
            kind: .<span class="s-dotAccess">newspaper</span>,
            id: <span class="s-string">"nytimes"</span>,
            name: <span class="s-string">"The New York Times"</span>
        )

        <span class="s-keyword">let</span> recommended = <span class="s-type">RecommendedItems</span>(newspapers: [item])

        <span class="s-call">XCTAssertEqual</span>(
            recommended.<span class="s-call">items</span>(ofKind: .<span class="s-dotAccess">newspaper</span>),
            [item]
        )
    }
}</code></pre><p>The above test will currently fail, which is great, as it reproduces the problem that our users have been facing. With that failing test in place, let‚Äôs now actually fix the bug, by turning our original <code>if/else</code> statements into a <code>switch</code> in order to handle all cases (which‚Äôll also give us a compile time error if we ever end up with an unhandled case again):</p><pre class="splash"><code><span class="s-keyword">struct</span> RecommendedItems {
    <span class="s-keyword">var</span> books = [<span class="s-type">Item</span>]()
    <span class="s-keyword">var</span> magazines = [<span class="s-type">Item</span>]()
    <span class="s-keyword">var</span> newspapers = [<span class="s-type">Item</span>]()

    <span class="s-keyword">func</span> items(ofKind kind: <span class="s-type">Item</span>.<span class="s-type">Kind</span>) -&gt; [<span class="s-type">Item</span>] {
        <span class="s-keyword">switch</span> kind {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">book</span>: <span class="s-keyword">return</span> books
        <span class="s-keyword">case</span> .<span class="s-dotAccess">magazine</span>: <span class="s-keyword">return</span> magazines
        <span class="s-keyword">case</span> .<span class="s-dotAccess">newspaper</span>: <span class="s-keyword">return</span> newspapers
        }
    }
}</code></pre><p>With the above fix in place, our test will now pass ‚Äî and we‚Äôre ready to submit our patch! Not only does the above approach give us a greater degree of confidence when fixing bugs, it also lets us make sure that the same bug won‚Äôt happen twice, since if we ever end up causing the same regression again ‚Äî our test will now tell us about it.</p><h2>Safeguarding against future errors</h2><p>While the above kind of bug-fixing tests are incredibly useful, they‚Äôre written in reaction to a bug that was <em>already caused</em>, and only protects us against the exact same regression. So let‚Äôs see if we can take things one step further, while we‚Äôre already working on this part of the code base, to give ourselves a much stronger safeguard against related regressions as well.</p><p>To do that in this case, let‚Äôs add a test that‚Äôll make sure that our <code>RecommendedItems</code> type will <em>always</em> be capable of returning items for <em>any</em> <code>Item.Kind</code>. We‚Äôll start by making our <code>Item.Kind</code> enum conform to <code>CaseIterable</code> ‚Äî which will let us iterate over its cases:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span>.<span class="s-type">Kind</span>: <span class="s-type">CaseIterable</span> {}</code></pre><p class="info">For more information on <code>CaseIterable</code>, check out <a href="https://www.swiftbysundell.com/articles/enum-iterations-in-swift-42">‚ÄúEnum iterations in Swift‚Äù</a>.</p><p>Next, let‚Äôs make it slightly easier to create stubbed <code>Item</code> values (instances that we create purely for testing reasons), by adding the following extension to our unit testing target:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Item</span> {
    <span class="s-keyword">static func</span> stub(ofKind kind: <span class="s-type">Kind</span>, id: <span class="s-type">Item</span>.<span class="s-type">ID</span>) -&gt; <span class="s-type">Item</span> {
        <span class="s-keyword">return</span> <span class="s-type">Item</span>(kind: kind, id: id, name: <span class="s-string">"</span>\(kind)<span class="s-string">-</span>\(id)<span class="s-string">"</span>)
    }
}</code></pre><p class="info">For much more advanced ways of stubbing values, check out <a href="https://www.swiftbysundell.com/articles/defining-testing-data-in-swift">‚ÄúDefining testing data in Swift‚Äù</a>.</p><p>With those two small extensions in place, we‚Äôre now ready to write our test, which will iterate over all cases within <code>Item.Kind</code> in order to make sure that there‚Äôs a recommended item defined for each kind ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> RecommendedItems: <span class="s-type">XCTestCase</span> {
    ...
    
    <span class="s-keyword">func</span> testItemsForAllKinds() {
        <span class="s-keyword">let</span> book = <span class="s-type">Item</span>.<span class="s-call">stub</span>(ofKind: .<span class="s-dotAccess">book</span>, id: <span class="s-string">"book"</span>)
        <span class="s-keyword">let</span> magazine = <span class="s-type">Item</span>.<span class="s-call">stub</span>(ofKind: .<span class="s-dotAccess">magazine</span>, id: <span class="s-string">"magazine"</span>)
        <span class="s-keyword">let</span> newspaper = <span class="s-type">Item</span>.<span class="s-call">stub</span>(ofKind: .<span class="s-dotAccess">newspaper</span>, id: <span class="s-string">"newspaper"</span>)

        <span class="s-keyword">let</span> recommended = <span class="s-type">RecommendedItems</span>(
            books: [book],
            magazines: [magazine],
            newspapers: [newspaper]
        )

        <span class="s-keyword">for</span> kind <span class="s-keyword">in</span> <span class="s-type">Item</span>.<span class="s-type">Kind</span>.<span class="s-property">allCases</span> {
            <span class="s-keyword">let</span> items = recommended.<span class="s-call">items</span>(ofKind: kind)

            <span class="s-keyword">switch</span> kind {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">book</span>:
                <span class="s-call">XCTAssertEqual</span>(items, [book])
            <span class="s-keyword">case</span> .<span class="s-dotAccess">magazine</span>:
                <span class="s-call">XCTAssertEqual</span>(items, [magazine])
            <span class="s-keyword">case</span> .<span class="s-dotAccess">newspaper</span>:
                <span class="s-call">XCTAssertEqual</span>(items, [newspaper])
            }
        }
    }
}</code></pre><p>The above test might be simple, but it gives us a much stronger guarantee that the way we keep track of recommended items within our app will keep working as we iterate on our code ‚Äî even if we might yet again add support for a new content type in the future.</p><h2>Pragmatic refactoring</h2><p>While writing tests for the above kind of synchronous model code is often quite straightforward, things tend to get increasingly difficult and tricky as we enter the domain of asynchronous code ‚Äî especially if the code in question wasn‚Äôt written with testing in mind.</p><p>For example, let‚Äôs say that we wanted to write a test to verify that a boolean flag is correctly stored in our app‚Äôs <code>UserDefaults</code> when the user successfully completes our onboarding process. All of that code currently lives inside of a <code>OnboardingViewController</code>, and looks like this:</p><pre class="splash"><code><span class="s-keyword">class</span> OnboardingViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">func</span> finishOnboarding() {
        <span class="s-keyword">let</span> task = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTask</span>(
            with: .<span class="s-dotAccess">onboardingFinishedEndpoint</span>
        ) { [<span class="s-keyword">weak self</span>] <span class="s-keyword">_</span>, <span class="s-keyword">_</span>, error <span class="s-keyword">in</span>
            <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>.<span class="s-call">async</span> {
                <span class="s-keyword">guard let self</span> = <span class="s-keyword">self else</span> { <span class="s-keyword">return</span> }

                <span class="s-keyword">if let</span> error = error {
                    <span class="s-type">ErrorPresenter</span>.<span class="s-property">shared</span>.<span class="s-call">present</span>(error, in: <span class="s-keyword">self</span>)
                    <span class="s-keyword">return</span>
                }

                <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>.<span class="s-call">setValue</span>(<span class="s-keyword">true</span>,
                    forKey: <span class="s-type">UserDefaultsKeys</span>.<span class="s-property">onboardingFinished</span>
                )

                <span class="s-keyword">self</span>.<span class="s-call">dismiss</span>(animated: <span class="s-keyword">true</span>)
            }
        }

        task.<span class="s-call">resume</span>()
    }
}</code></pre><p>As it currently stands, writing tests for the above code will be quite difficult. The main problem is that singletons are used to access <code>URLSession</code>, <code>ErrorPresenter</code> and <code>UserDefaults</code>, which will make it hard (or even impossible) for us to take control over those instances within our tests, in order to verify our functionality in a predictable way. Ideally we‚Äôd like those <a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift">dependencies to be injected</a>, so that we‚Äôd be able to <a href="https://www.swiftbysundell.com/articles/mocking-in-swift">mock them</a>.</p><p>However, completely refactoring <code>OnboardingViewController</code> to fully support dependency injection (and to also abstract our dependencies to the extent that they can be fully mocked) will most likely be a huge task ‚Äî so let‚Äôs see if we can find a way to enable us to test our functionality with only a minor set of tweaks.</p><p>One way to do so is to encapsulate our view controller‚Äôs dependencies using functions, and then define a struct that contains all of those functions ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> OnboardingDependencies {
    <span class="s-comment">// Our networking code, modeled as a function that takes
    // a URL and a completion handler, and then calls the
    // underlying URLSession:</span>
    <span class="s-keyword">var</span> networking: (<span class="s-type">URL</span>, <span class="s-keyword">@escaping</span> (<span class="s-type">Error</span>?) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">Void</span> = {
        url, handler <span class="s-keyword">in

        let</span> task = <span class="s-type">URLSession</span>.<span class="s-property">shared</span>.<span class="s-call">dataTask</span>(with: url) {
            <span class="s-keyword">_</span>, <span class="s-keyword">_</span>, error <span class="s-keyword">in</span>
            
            <span class="s-type">DispatchQueue</span>.<span class="s-property">main</span>.<span class="s-call">async</span> {
                <span class="s-call">handler</span>(error)
            }
        }

        task.<span class="s-call">resume</span>()
    }

    <span class="s-comment">// Our error presenting function can be directly referenced,
    // since Swift supports first class functions:</span> 
    <span class="s-keyword">var</span> errorPresenting = <span class="s-type">ErrorPresenter</span>.<span class="s-property">shared</span>.<span class="s-property">present</span>

    <span class="s-comment">// Our key/value persistence code, which we turn into
    // a function that wraps our app's standard UserDefaults:</span>
    <span class="s-keyword">var</span> keyValuePesistance: (<span class="s-type">String</span>, <span class="s-type">Bool</span>) -&gt; <span class="s-type">Void</span> = {
        <span class="s-type">UserDefaults</span>.<span class="s-property">standard</span>.<span class="s-call">setValue</span>($1, forKey: $0)
    }
}</code></pre><p>With the above in place, we can now define a new <code>dependencies</code> property within our view controller, and simply call the above functions in order to access our dependencies‚Äô functionality:</p><pre class="splash"><code><span class="s-keyword">class</span> OnboardingViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">var</span> dependencies = <span class="s-type">OnboardingDependencies</span>()
    
    ...

    <span class="s-keyword">func</span> finishOnboarding() {
        dependencies.<span class="s-call">networking</span>(.<span class="s-dotAccess">onboardingFinishedEndpoint</span>) {
            [<span class="s-keyword">weak self</span>] error <span class="s-keyword">in

            guard let self</span> = <span class="s-keyword">self else</span> { <span class="s-keyword">return</span> }

            <span class="s-keyword">if let</span> error = error {
                <span class="s-keyword">self</span>.<span class="s-property">dependencies</span>.<span class="s-call">errorPresenting</span>(error, <span class="s-keyword">self</span>)
                <span class="s-keyword">return</span>
            }

            <span class="s-keyword">self</span>.<span class="s-property">dependencies</span>.<span class="s-call">keyValuePesistance</span>(
                <span class="s-type">UserDefaultsKeys</span>.<span class="s-property">onboardingFinished</span>,
                <span class="s-keyword">true</span>
            )

            <span class="s-keyword">self</span>.<span class="s-call">dismiss</span>(animated: <span class="s-keyword">true</span>)
        }
    }
}</code></pre><p>The above might not be our ideal way of doing dependency injection, but it works remarkably well, and doesn‚Äôt require any modifications to our view controller‚Äôs API ‚Äî nor to any of its dependencies. We don‚Äôt need to define any new protocols, or fundamentally change our code, but we‚Äôve still enabled the above function to be fully tested.</p><p>To do just that, we‚Äôll simply create an instance of <code>OnboardingViewController</code>, and then override the dependency functions that we wish to take control over. Here‚Äôs how we might do that to write the test that we originally set out to add ‚Äî which verifies that the correct flag is persisted when the user finishes the onboarding process:</p><pre class="splash"><code><span class="s-keyword">class</span> OnboardingViewControllerTests: <span class="s-type">XCTestCase</span> {
    <span class="s-keyword">func</span> testPersistingOnboardingFinished() {
        <span class="s-keyword">let</span> vc = <span class="s-type">OnboardingViewController</span>()
        <span class="s-keyword">var</span> persistance: (key: <span class="s-type">String</span>, value: <span class="s-type">Bool</span>)?

        <span class="s-comment">// Hard-wire our networking function to always
        // return a nil error when called:</span>
        vc.<span class="s-property">dependencies</span>.<span class="s-property">networking</span> = { <span class="s-keyword">_</span>, handler <span class="s-keyword">in</span>
            <span class="s-call">handler</span>(<span class="s-keyword">nil</span>)
        }

        <span class="s-comment">// Override our view controller's key/value persistance
        // function in order to capture its input:</span>
        vc.<span class="s-property">dependencies</span>.<span class="s-property">keyValuePesistance</span> = {
            persistance = ($0, $1)
        }

        vc.<span class="s-call">finishOnboarding</span>()

        <span class="s-comment">// Verify that the correct key and value were persisted:</span>
        <span class="s-call">XCTAssertEqual</span>(persistance?.<span class="s-property">key</span>, <span class="s-type">UserDefaultsKeys</span>.<span class="s-property">onboardingFinished</span>)
        <span class="s-call">XCTAssertEqual</span>(persistance?.<span class="s-property">value</span>, <span class="s-keyword">true</span>)
    }
}</code></pre><p>Pretty cool! While our primary goal might‚Äôve been to make <code>OnboardingViewController</code> testable, as an added bonus, we‚Äôve now also made that class both simpler and more flexible ‚Äî since it no longer has any strong coupling to its dependencies.</p><h2>Conclusion</h2><p>While unit testing might initially seem like a very big deal ‚Äî something that will require months of refactoring work before a single test can be written ‚Äî that‚Äôs rarely the case. While we might need to perform <em>some</em> modifications to certain parts of our code base in order to test it, those changes can often be done in a fully backward compatible manner, and in a way that takes just a short amount of time to implement.</p><p>At the end of the day, unit testing is not a way of life, nor will it completely remove the need for manual testing, or magically make an app error-free ‚Äî it‚Äôs just a tool like any other. A tool that ‚Äî if tactically and thoughtfully deployed ‚Äî can help us verify bug fixes, prevent many kinds of future errors, and ensure that our code keeps working as intended as we add new features and capabilities.</p><p>What do you think? Do you already use some of the techniques within this article, or will you try them out? Let me know ‚Äî along with your questions, comments and feedback ‚Äî either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/using-key-paths-in-switch-statements</guid><title>Tip: Using key paths in switch statements</title><description>How to enable key paths to be used in switch statements, and within any other context that supports pattern matching.</description><link>https://www.swiftbysundell.com/tips/using-key-paths-in-switch-statements</link><pubDate>Wed, 23 Oct 2019 15:00:00 +0200</pubDate><content:encoded><![CDATA[<p>One of Swift‚Äôs lesser known, but incredibly powerful language features is how the <code>~=</code> operator lets us implement custom pattern matching variants between different types. Those new pattern matching capabilities can then be used in <code>switch</code> statements, when using <code>if case</code> syntax, or within any other context in which pattern matching is supported.</p><p>Here‚Äôs how we could use that language feature to define a <code>~=</code> overload that matches a boolean <a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift">key path</a> into a type against an instance of that type:</p><pre class="splash"><code><span class="s-keyword">func</span> ~=&lt;<span class="s-type">T</span>&gt;(lhs: <span class="s-type">KeyPath</span>&lt;<span class="s-type">T</span>, <span class="s-type">Bool</span>&gt;, rhs: <span class="s-type">T</span>) -&gt; <span class="s-type">Bool</span> {
    rhs[keyPath: lhs]
}</code></pre><p>With the above in place, we can now simply use a key path to define a pattern, and mix those patterns freely with those that match against a value ‚Äî which is really useful when using a <code>switch</code> statement to decide how to parse or handle a given value:</p><pre class="splash"><code><span class="s-keyword">func</span> handle(<span class="s-keyword">_</span> character: <span class="s-type">Character</span>) {
    <span class="s-keyword">switch</span> character {
    <span class="s-keyword">case</span> <span class="s-string">"&lt;"</span>:
        <span class="s-call">parseElement</span>()
    <span class="s-keyword">case</span> <span class="s-string">"#"</span>:
        <span class="s-call">parseHashtag</span>()
    <span class="s-keyword">case</span> \.<span class="s-property">isNumber</span>:
        <span class="s-call">parseNumber</span>()
    <span class="s-keyword">case</span> \.<span class="s-property">isNewline</span>:
        <span class="s-call">startNewLine</span>()
    <span class="s-keyword">default</span>:
        <span class="s-call">parseAnyCharacter</span>()
    }
}</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/default-arguments-in-swift</guid><title>Default arguments in Swift</title><description>When designing APIs, using default arguments can often let us strike a nice balance between flexibility and ease of use ‚Äî as they let us add solid, intuitive defaults to many of the configuration options that we‚Äôll end up providing. Let‚Äôs take a look at a few examples of how they may be used.</description><link>https://www.swiftbysundell.com/articles/default-arguments-in-swift</link><pubDate>Sun, 20 Oct 2019 13:30:00 +0200</pubDate><content:encoded><![CDATA[<p>A major part of designing powerful, flexible APIs that still feel lightweight and easy to use, is deciding what aspects to make user-configurable. On one hand, the more configuration options that we add, the more versatile an API becomes ‚Äî but on the other hand, it might also make it more complicated and harder to understand.</p><p>That‚Äôs what makes <em>default arguments</em> such a great tool in Swift ‚Äî as they let us add solid, intuitive defaults to many of the configuration options that we‚Äôll end up providing. That way we can often strike a nice balance between flexibility and ease of use, and this week, let‚Äôs take a look at a few examples of how we might do just that.</p><h2>Making the easy path the right path</h2><p>One of the key ways that a project can be made more maintainable (especially as it grows in size, both code-wise and team-wise), is by ensuring that the easiest way to accomplish a certain task is also <em>the right way to do it</em>. It‚Äôs so common for highly similar functionality to be accidentally re-implemented multiple times by different developers, simply because there was no simple, shared abstraction available to use.</p><p>For example, let‚Äôs say that we wanted to make an effort to unify the durations used for various animations across an app. To make that happen, our goal needs to be to create a <em>simpler</em> API than what the system provides out of the box, so that all members of our team (including ourselves) will continuously choose to use that new API over the default one. In this case, we might build something like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIResponder</span> {
    <span class="s-comment">// Here we use a default argument to define what we want
    // our unified, default animation duration to be:</span>
    <span class="s-keyword">func</span> animate(withDuration duration: <span class="s-type">TimeInterval</span> = <span class="s-number">0.3</span>,
                 animations: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-type">UIView</span>.<span class="s-call">animate</span>(withDuration: duration,
                       animations: animations)
    }
}</code></pre><p class="info">We scope the above function to <code>UIResponder</code> (which both <code>UIView</code> and <code>UIViewController</code> are subclasses of), to avoid getting it as an autocompletion suggestion within non-UI contexts.</p><p>With the above in place, most animation code will ‚Äî over time‚Äî most likely end up simply looking like this:</p><pre class="splash"><code><span class="s-call">animate</span> {
    button.<span class="s-property">frame</span>.<span class="s-property">size</span> = <span class="s-type">CGSize</span>(width: <span class="s-number">100</span>, height: <span class="s-number">100</span>)
}</code></pre><p>That‚Äôs great, both for readability, and since we‚Äôll now have a single source of truth for the duration of all of our default animations. Equally important, however, is that our new default can easily be overridden ‚Äî simply by specifying a value for that argument at the call site:</p><pre class="splash"><code><span class="s-call">animate</span>(withDuration: <span class="s-number">2</span>) {
    button.<span class="s-property">frame</span>.<span class="s-property">size</span> = <span class="s-type">CGSize</span>(width: <span class="s-number">100</span>, height: <span class="s-number">100</span>)
}</code></pre><p>Besides providing a great way to standardize various values across a code base, default arguments can also enable us to <a href="https://www.swiftbysundell.com/articles/designing-swift-apis">design more scalable APIs</a> ‚Äî by making increasingly complex use cases and customization possible, without requiring all API users to take on that added complexity.</p><p>For example, here‚Äôs how we might extend our simplified animation API to support a much larger set of parameters ‚Äî while still keeping the default use case as simple as possible:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIResponder</span> {
    <span class="s-keyword">func</span> animate(withDuration duration: <span class="s-type">TimeInterval</span> = <span class="s-number">0.3</span>,
                 delay: <span class="s-type">TimeInterval</span> = <span class="s-number">0</span>,
                 options: <span class="s-type">UIView</span>.<span class="s-type">AnimationOptions</span> = .<span class="s-dotAccess">curveEaseInOut</span>,
                 animations: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
        <span class="s-type">UIView</span>.<span class="s-call">animate</span>(withDuration: duration,
                       delay: delay,
                       options: options,
                       animations: animations)
    }
}</code></pre><p>That‚Äôs really what makes default arguments so incredibly useful ‚Äî they let us keep expanding our APIs to make them increasingly more powerful and flexible, in a way that won‚Äôt impact any of our code that doesn‚Äôt need to take advantage of those new capabilities.</p><h2>The importance of being obvious</h2><p>However, when deciding what values to turn into defaults, it‚Äôs always important to consider whether a given default will end up becoming intuitive to our API users. After all, the best kind of defaults are those that <em>feel obvious</em>, since it‚Äôll help us avoid misunderstandings and bugs caused by an API doing something that we didn‚Äôt expect.</p><p>For example, let‚Äôs say that we‚Äôve written a function for storing a given value in a local database, and that we enable the API user to decide how to handle conflicts ‚Äî whenever a similar value already exists within that database. In an attempt to make our API as simple as possible, we‚Äôve again specified a default argument ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> ConflictResolution {
    <span class="s-keyword">case</span> overwriteExisting
    <span class="s-keyword">case</span> stopIfExisting
    <span class="s-keyword">case</span> askUser
}

<span class="s-keyword">func</span> store&lt;T: <span class="s-type">Storable</span>&gt;(
    <span class="s-keyword">_</span> value: <span class="s-type">T</span>,
    conflictResolution: <span class="s-type">ConflictResolution</span> = .<span class="s-dotAccess">stopIfExisting</span>
) <span class="s-keyword">throws</span> {
    ...
}</code></pre><p>Doing the above may at first seem like a good idea, but if we think about it, it‚Äôs not really <em>obvious</em> that calling our function without explicitly specifying a <code>ConflictResolution</code> will result in no value being stored if our database already contains an existing one. By simply calling <code>try store(value)</code>, we‚Äôd expect a value to actually be stored, but at the same time ‚Äî we wouldn‚Äôt want to make <code>overwriteExisting</code> the default either, as that could result in unexpected data loss.</p><p>In this type of situation, when there‚Äôs really no obvious default to be found, it might be better to simply define a separate function if we want to provide some form of convenience API. For example, here‚Äôs how we might create a <code>storeIfNeeded</code> function to be able to easily store a value only if a similar one doesn‚Äôt already exist:</p><pre class="splash"><code><span class="s-keyword">func</span> storeIfNeeded&lt;T: <span class="s-type">Storable</span>&gt;(<span class="s-keyword">_</span> value: <span class="s-type">T</span>) <span class="s-keyword">throws</span> {
    <span class="s-keyword">try</span> <span class="s-call">store</span>(value, conflictResolution: .<span class="s-dotAccess">stopIfExisting</span>)
}</code></pre><p>So while default arguments are really useful in many kinds of situations, they‚Äôre not the <em>only</em> way to define convenience APIs, and like with so many other things ‚Äî it all comes down to picking the right tool for the job within each given context.</p><h2>Retrofitted dependency injection</h2><p>Default arguments can also provide a great way to retrofit a given type or function with <em><a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift">dependency injection</a></em>. Like we‚Äôve taken a look at in <a href="https://www.swiftbysundell.com/tags/dependency-injection">previous articles</a> ‚Äî injecting our code-level dependencies, rather than relying on singletons, is often key to writing more well-structured and testable code. However, completely refactoring a code base to introduce dependency injection everywhere can be a huge task ‚Äî but thankfully, default arguments can enable us to perform those changes in a step-by-step fashion.</p><p>Let‚Äôs say that our code base makes heavy use of a <code>FileLoader</code> class ‚Äî that currently accesses its underlying <code>FileManager</code>, as well as a globally shared <code>Cache</code>, as singletons. That does have <em>some</em> benefits, as it lets us simply initialize a <code>FileLoader</code> from anywhere, without having to worry about its dependencies. However, it also makes it much harder to both unit test that class, and to get a clear overview of what kind of dependencies that it has.</p><p>The good news is that by simply transforming the way we access those singletons to instead become default initializer arguments, we can both improve our type‚Äôs structure, and also make it a lot more testable ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> FileLoader {
    <span class="s-keyword">private let</span> fileManager: <span class="s-type">FileManager</span>
    <span class="s-keyword">private let</span> cache: <span class="s-type">Cache</span>

    <span class="s-keyword">init</span>(fileManager: <span class="s-type">FileManager</span> = .<span class="s-dotAccess">default</span>,
         cache: <span class="s-type">Cache</span> = .<span class="s-dotAccess">shared</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">fileManager</span> = fileManager
        <span class="s-keyword">self</span>.<span class="s-property">cache</span> = cache
    }
}</code></pre><p>Since we‚Äôve now parameterized all of our file loader‚Äôs dependencies, they can much more easily be <a href="https://www.swiftbysundell.com/articles/mocking-in-swift">mocked</a> or <a href="https://www.swiftbysundell.com/articles/defining-testing-data-in-swift">stubbed</a> within our tests. For example, here‚Äôs how we might replace our app‚Äôs default <code>Cache</code> with one that automatically empties itself each time that our tests are run:</p><pre class="splash"><code><span class="s-keyword">let</span> loader = <span class="s-type">FileLoader</span>(cache: .<span class="s-dotAccess">autoEmptyingForTests</span>)</code></pre><p>For more info on unit testing, check out <a href="https://www.swiftbysundell.com/basics/unit-testing">this Basics article</a>, as well as this site‚Äôs many other <a href="https://www.swiftbysundell.com/tags/unit-testing">articles and podcast episodes</a> on that topic.</p><h2>Associated values within enums</h2><p>Finally, let‚Äôs take a look at a new <em>‚Äúflavor‚Äù</em> of default arguments that was added as part of Swift 5.1 ‚Äî default associated values for enum cases.</p><p>Let‚Äôs say that we‚Äôre building a Swift library for creating XML documents. Since XML is a tree-like format in which all data is defined using nodes that come in a finite number of variations, we might choose to model each such node using an <code>XMLNode</code> enum that looks like this:</p><pre class="splash"><code><span class="s-keyword">enum</span> XMLNode {
    <span class="s-comment">// A standard element, which can contain child elements:</span>
    <span class="s-keyword">case</span> element(
        name: <span class="s-type">String</span>,
        attributes: [<span class="s-type">Attribute</span>],
        children: [<span class="s-type">XMLNode</span>]
    )
    <span class="s-comment">// A "void" element that closes itself, and can't have children:</span>
    <span class="s-keyword">case</span> voidElement(
        name: <span class="s-type">String</span>,
        attributes: [<span class="s-type">Attribute</span>]
    )
    <span class="s-comment">// An inline piece of text, defined as a child node:</span>
    <span class="s-keyword">case</span> text(<span class="s-type">String</span>)
}</code></pre><p>Before Swift 5.1, using the above kind of approach did come with a quite major tradeoff, in that no default arguments could be defined. So even if we just wanted to create an empty (but still non-void) element, we‚Äôd still have to pass all associated values for that case:</p><pre class="splash"><code><span class="s-keyword">let</span> emptyItems = <span class="s-type">XMLNode</span>.<span class="s-call">element</span>(
    name: <span class="s-string">"items"</span>,
    attributes: [],
    children: []
)</code></pre><p>While we could‚Äôve extended <code>XMLNode</code> with convenience APIs that would‚Äôve filled in those empty defaults for us, we no longer have to ‚Äî as we‚Äôre now able to define default arguments for associated enum values as well, exactly the same way as we do for function arguments:</p><pre class="splash"><code><span class="s-keyword">enum</span> XMLNode {
    <span class="s-keyword">case</span> element(
        name: <span class="s-type">String</span>,
        attributes: [<span class="s-type">Attribute</span>] = [],
        children: [<span class="s-type">XMLNode</span>] = []
    )
    <span class="s-keyword">case</span> voidElement(
        name: <span class="s-type">String</span>,
        attributes: [<span class="s-type">Attribute</span>] = []
    )
    <span class="s-keyword">case</span> text(<span class="s-type">String</span>)
}</code></pre><p>With the above change in place, our <code>XMLNode</code> API immediately becomes a lot more flexible ‚Äî as we can now define all sorts of nodes, simply by using the above enum type:</p><pre class="splash"><code><span class="s-keyword">let</span> emptyItems = <span class="s-type">XMLNode</span>.<span class="s-call">element</span>(name: <span class="s-string">"items"</span>)
<span class="s-keyword">let</span> link = <span class="s-type">XMLNode</span>.<span class="s-call">element</span>(name: <span class="s-string">"link"</span>, children: [.<span class="s-call">text</span>(url)])
<span class="s-keyword">let</span> metadata = <span class="s-type">XMLNode</span>.<span class="s-call">voidElement</span>(name: <span class="s-string">"meta"</span>, attributes: metadataAttributes)</code></pre><p>Pretty cool! Especially for structures and models used to define data, using default values can be really powerful, as the granularity of any kind of data tends to vary quite a lot from use case to use case.</p><h2>Conclusion</h2><p>When deployed to provide a solid set of obvious and consistent defaults for an API, default arguments can be incredibly powerful. They can make our APIs feel so much more lightweight, and enable the callers of those APIs to ease their way into using them ‚Äî by starting out simple, and then customizing and overriding the defaults values as needed.</p><p>Default arguments can also provide a way to easily retrofit an existing type or function with dependency injection, and to make enums a lot more flexible.</p><p>But we also have to be careful not to make too many assumptions when defining our default arguments. Because at the end of the day, even though defaults and strong conventions are incredibly useful, a non-obvious default is arguably much worse than having no default at all.</p><p>What do you think? How do you usually use default arguments, and what guiding principles do you think are good to keep in mind when deciding what value to turn into a default. Let me know ‚Äî along with your questions, comments and feedback ‚Äî either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/omitting-the-return-keyword</guid><title>Tip: Omitting the return keyword</title><description></description><link>https://www.swiftbysundell.com/tips/omitting-the-return-keyword</link><pubDate>Mon, 14 Oct 2019 18:00:00 +0200</pubDate><content:encoded><![CDATA[<p><strong>New in Swift 5.1:</strong> The <code>return</code> keyword can now be omitted when declaring functions and computed properties that only contain a single expression, which is really nice when declaring simpler convenience APIs:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">MarkdownReader</span> {
    <span class="s-keyword">var</span> isAtStart: <span class="s-type">Bool</span> { index == string.<span class="s-property">startIndex</span> }
    <span class="s-keyword">var</span> didReachEnd: <span class="s-type">Bool</span> { index == string.<span class="s-property">endIndex</span> }
    <span class="s-keyword">var</span> currentCharacter: <span class="s-type">Character</span> { string[index] }
    
    <span class="s-keyword">func</span> encodeCurrentCharacter() -&gt; <span class="s-type">String</span> {
        currentCharacter.<span class="s-call">encoded</span>()
    }
}</code></pre><p>While this new behavior might take a little while to get used to, it matches the way <a href="https://www.swiftbysundell.com/basics/closures">closures</a> work, which does result in improved consistency between properties, methods, and closures:</p><pre class="splash"><code><span class="s-comment">// Here's how the above 'isAtStart' property might have been
// declared as a closure instead, prior to Swift 5.1:</span>
<span class="s-keyword">let</span> isAtStart: () -&gt; <span class="s-type">Bool</span> = { index == string.<span class="s-property">startIndex</span> }</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/encapsulating-configuration-code-in-swift</guid><title>Encapsulating configuration code in Swift</title><description>Let‚Äôs take a look at a few different techniques that can let us achieve a nice balance between code reuse and configurability, by building lightweight abstractions that enable us to encapsulate our configuration code.</description><link>https://www.swiftbysundell.com/articles/encapsulating-configuration-code-in-swift</link><pubDate>Sun, 13 Oct 2019 19:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Striking a nice balance between code reuse and configurability can often be quite challenging. While we‚Äôd ideally like to avoid repeating code and accidentally creating multiple sources of truth, much of how our various objects and values need to be configured tends to be dependent on the context that they‚Äôre used in.</p><p>This week, let‚Äôs take a look at a few different techniques that can let us achieve such a balance ‚Äî by building lightweight abstractions that enable us to encapsulate our configuration code, and how those abstractions can then be shared across a code base to also increase its level of consistency.</p><h2>Building components, rather than screens</h2><p>When doing any kind of software development, it often helps to slice a program up into various parts, in order to be able to deal with them as separate units. For UI-heavy applications, such as iOS and Mac apps, it‚Äôs often tempting to do that kind of slicing based on the various screens that make up the app. For example, a shopping app might have a product screen, a list screen, a search screen, and so on.</p><p>While that kind of screen-level slicing makes a lot of sense from a high-level perspective (especially since it matches the way we tend to discuss our apps with other collaborators ‚Äî like testers and designers), it tends to result in UI code that needs to be quite heavily configured for each screen.</p><p>Take this <code>ProductViewController</code> for example, which contains a buy button, as well as views for displaying details and related items for each product ‚Äî all of which are configured within the view controller‚Äôs <code>viewDidLoad</code> method:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">let</span> product: <span class="s-type">Product</span>
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        <span class="s-comment">// Buy button</span>
        <span class="s-keyword">let</span> buyButton = <span class="s-type">UIButton</span>(type: .<span class="s-dotAccess">custom</span>)
        buyButton.<span class="s-call">setImage</span>(.<span class="s-dotAccess">buy</span>, for: .<span class="s-dotAccess">normal</span>)
        buyButton.<span class="s-property">backgroundColor</span> = .<span class="s-dotAccess">systemGreen</span>
        buyButton.<span class="s-call">addTarget</span>(<span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(buyButtonTapped),
            for: .<span class="s-dotAccess">touchUpInside</span>
        )
        view.<span class="s-call">addSubview</span>(buyButton)
        
        <span class="s-comment">// Product detail view</span>
        <span class="s-keyword">let</span> productDetailView = <span class="s-type">UIView</span>()
        ...
        
        <span class="s-comment">// Related products view</span>
        <span class="s-keyword">let</span> relatedProductsView = <span class="s-type">UIView</span>()
        ...
    }
}</code></pre><p>Even though we‚Äôve attempted to make the above code a bit easier to read by adding a comment before each configuration block, our current <code>viewDidLoad</code> implementation does arguably suffer from a lack of structure. Since all of our configuration happens in one place, it‚Äôs easy for variables to be accidentally used in the wrong context, and for our code to become increasingly intertwined as time goes on.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code">‚ÄúWriting self-documenting Swift code‚Äù</a></em>, one way to mitigate the above problem is to simply break out the different parts of our configuration code into separate methods, which <code>viewDidLoad</code> can then call:</p><pre class="splash"><code><span class="s-keyword">private extension</span> <span class="s-type">ProductViewController</span> {
    <span class="s-keyword">func</span> setupBuyButton() {
        <span class="s-keyword">let</span> buyButton = <span class="s-type">UIButton</span>(type: .<span class="s-dotAccess">custom</span>)
        ...
    }

    <span class="s-keyword">func</span> setupProductDetailView() {
        <span class="s-keyword">let</span> productDetailView = <span class="s-type">UIView</span>()
        ...
    }

    <span class="s-keyword">func</span> setupRelatedProductsView() {
        <span class="s-keyword">let</span> relatedProductsView = <span class="s-type">UIView</span>()
        ...
    }
}</code></pre><p>While the above approach does solve our structural problem, and definitely makes our code more <em>self-documenting</em> and easier to read, it still strongly couples our individual view components with their presenting container ‚Äî <code>ProductViewController</code> in this case.</p><p>That‚Äôs probably not a problem for one-off views that are currently only used within a single view controller, but for more general-purpose UI code, it‚Äôd be nice if we were able to easily reuse our various configurations across our code base.</p><p>One way to do so, which doesn‚Äôt require any new types to be defined, is to use <em><a href="https://www.swiftbysundell.com/articles/static-factory-methods-in-swift">static factory methods</a></em> ‚Äî which enable us to encapsulate the way we configure each view, in a way that‚Äôs both easy to define, and easy to use:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIView</span> {
    <span class="s-keyword">static func</span> buyButton(withTarget target: <span class="s-type">Any</span>, action: <span class="s-type">Selector</span>) -&gt; <span class="s-type">UIButton</span> {
        <span class="s-keyword">let</span> button = <span class="s-type">UIButton</span>(type: .<span class="s-dotAccess">custom</span>)
        button.<span class="s-call">setImage</span>(.<span class="s-dotAccess">buy</span>, for: .<span class="s-dotAccess">normal</span>)
        button.<span class="s-property">backgroundColor</span> = .<span class="s-dotAccess">systemGreen</span>
        button.<span class="s-call">addTarget</span>(target, action: action, for: .<span class="s-dotAccess">touchUpInside</span>)
        <span class="s-keyword">return</span> button
    }
}</code></pre><p>The beauty of static factory methods is that they enable us to call our APIs in a way that‚Äôs similar to enums ‚Äî using Swift‚Äôs very lightweight <em>dot syntax</em>. If we‚Äôd also define similar methods as the above one for creating a <em>buy button</em>, then we could end up with a <code>viewDidLoad</code> implementation that simply looks like this:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">let</span> product: <span class="s-type">Product</span>
    
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()
        
        view.<span class="s-call">addSubview</span>(.<span class="s-call">buyButton</span>(
            withTarget: <span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(buyButtonTapped)
        ))
        
        view.<span class="s-call">addSubview</span>(.<span class="s-call">productDetailView</span>(
            for: product
        ))
        
        view.<span class="s-call">addSubview</span>(.<span class="s-call">relatedProductsView</span>(
            for: product.<span class="s-property">relatedProducts</span>,
            delegate: <span class="s-keyword">self</span>
        ))
    }
}</code></pre><p>That‚Äôs really neat! Gone are the local variables, and we can still fit all of our view setup code within one method, while also giving us a much greater degree of encapsulation ‚Äî and complete reusability, since we can now easily construct the above kind of views wherever we might need them.</p><h2>Multiple configuration steps</h2><p>While the above approach works great for UI configuration code that ideally should remain the same across our entire code base, such as setting up common components, we also often need to extend such configurations in a way that‚Äôs much more context-specific.</p><p>For example, we probably need to apply some form of layout to our views, to update or bind certain pieces of state to them, or otherwise customize their behaviors or appearance depending on the feature that they‚Äôre used in.</p><p>To make it easy to do so, let‚Äôs extend <code>UIView</code> with a convenience API ‚Äî that simply executes a closure after adding a given view as a subview, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">UIView</span> {
    <span class="s-keyword">@discardableResult
    func</span> add&lt;T: <span class="s-type">UIView</span>&gt;(<span class="s-keyword">_</span> subview: <span class="s-type">T</span>, then closure: (<span class="s-type">T</span>) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">T</span> {
        <span class="s-call">addSubview</span>(subview)
        <span class="s-call">closure</span>(subview)
        <span class="s-keyword">return</span> subview
    }
}</code></pre><p>With the above method in place, we can now keep using that nice dot syntax to create our views, while still enabling us to apply context-specific configurations as well ‚Äî for example in order to add a set of <a href="https://www.swiftbysundell.com/basics/layout-anchors">Auto Layout constraints</a>:</p><pre class="splash"><code><span class="s-keyword">class</span> ProductViewController: <span class="s-type">UIViewController</span> {
    ...

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        view.<span class="s-call">add</span>(.<span class="s-call">buyButton</span>(
            withTarget: <span class="s-keyword">self</span>,
            action: <span class="s-keyword">#selector</span>(buyButtonTapped)
        ), then: {
            <span class="s-type">NSLayoutConstraint</span>.<span class="s-call">activate</span>([
                $0.<span class="s-property">topAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">topAnchor</span>),
                $0.<span class="s-property">trailingAnchor</span>.<span class="s-call">constraint</span>(equalTo: view.<span class="s-property">trailingAnchor</span>)
                ...
            ])
        })
        
        ...
    }
}</code></pre><p>Although the above syntax might take a while to get used to, it does sort of give us the best of both worlds ‚Äî we‚Äôre now able to fully encapsulate both our global and local configurations, while also enforcing a certain degree of structure as well. It also lets us easily share view components among different screens, without requiring us to define any new <code>UIView</code> subclasses.</p><h2>A declarative structure</h2><p>What‚Äôs also interesting about the above approach is how it starts making our imperative UIKit-based code slightly more declarative ‚Äî as we‚Äôre no longer continuously setting up our various views within our view controllers, but rather declaring what sort of configuration we wish to use. That sort of moves us closer to the world of <a href="https://www.swiftbysundell.com/basics/swiftui">SwiftUI</a>, which could help ease our transition to that new world in the future.</p><p>Just compare how our <code>ProductViewController</code> might look if expressed as a SwiftUI view instead ‚Äî structurally, it‚Äôs really quite similar to our above UIKit-based approach:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">BuyButton</span> {
                <span class="s-comment">// Handling code</span>
                ...
            }
            <span class="s-type">ProductDetailView</span>(product: product)
            <span class="s-type">RelatedProductsView</span>(products: product.<span class="s-property">relatedProducts</span>) {
                <span class="s-comment">// Handling code</span>
                ...
            }
        }
    }
}</code></pre><p>That of course doesn‚Äôt mean that we‚Äôve automatically made our UIKit-based code SwiftUI-compatible, just by modifying its structure ‚Äî but by using a similar way of thinking around how we organize our various view configurations, we can at least start to become more familiar with increasingly declarative coding styles.</p><h2>Configuration closures</h2><p>Although much of the configuration code that we write when developing UI-based apps tends to be centered around the view layer, other parts of our code base often needs to be quite heavily configured as well ‚Äî especially logic that‚Äôs written directly on top of system APIs.</p><p>For example, let‚Äôs say that we‚Äôre building a type for parsing some form of metadata from a string, and that we‚Äôd like to use a shared <code>DateFormatter</code> among all instances of that type. To do that, we might define a private static property that is configured using a <em>self-executing closure</em>:</p><pre class="splash"><code><span class="s-keyword">struct</span> MetadataParser {
    <span class="s-keyword">private static let</span> dateFormatter: <span class="s-type">DateFormatter</span> = {
        <span class="s-keyword">let</span> formatter = <span class="s-type">DateFormatter</span>()
        formatter.<span class="s-property">dateFormat</span> = <span class="s-string">"yyyy-MM-dd HH:mm"</span>
        formatter.<span class="s-property">timeZone</span> = <span class="s-type">TimeZone</span>(secondsFromGMT: <span class="s-number">0</span>)
        <span class="s-keyword">return</span> formatter
    }()

    <span class="s-keyword">func</span> metadata(from string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Metadata</span> {
        ...
    }
}</code></pre><p>While self-executing closures are incredibly convenient, using them to configure properties can often ‚Äúpush‚Äù the core functionality of a type further and further down ‚Äî which in turn can make it harder to quickly get an overview of what a type is actually doing. To mitigate that problem, let‚Äôs see if we can do something to make such configuration closures as compact as possible, without sacrificing readability.</p><p>Let‚Äôs start by defining a function called <code>configure</code>, which simply takes any object or value, and lets us apply any sort of mutations to it inside of a closure, using the <code>inout</code> keyword ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">func</span> configure&lt;T&gt;(<span class="s-keyword">_</span> object: <span class="s-type">T</span>, using closure: (<span class="s-keyword">inout</span> <span class="s-type">T</span>) -&gt; <span class="s-type">Void</span>) -&gt; <span class="s-type">T</span> {
    <span class="s-keyword">var</span> object = object
    <span class="s-call">closure</span>(&amp;object)
    <span class="s-keyword">return</span> object
}</code></pre><p>To configure the shared <code>DateFormatter</code> for our metadata parsers, we can now simply pass it to the above function, and easily configure it using the <code>$0</code> closure argument shorthand ‚Äî leaving us with code that‚Äôs more compact, while still remaining just as readable:</p><pre class="splash"><code><span class="s-keyword">struct</span> MetadataParser {
    <span class="s-keyword">private static let</span> dateFormatter = <span class="s-call">configure</span>(<span class="s-type">DateFormatter</span>()) {
        $0.<span class="s-property">dateFormat</span> = <span class="s-string">"yyyy-MM-dd HH:mm"</span>
        $0.<span class="s-property">timeZone</span> = <span class="s-type">TimeZone</span>(secondsFromGMT: <span class="s-number">0</span>)
    }

    <span class="s-keyword">func</span> metadata(from string: <span class="s-type">String</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">Metadata</span> {
        ...
    }
}</code></pre><p>The above way of configuring properties is arguably even easier to understand than self-executing closures ‚Äî since by adding the call to <code>configure</code>, we‚Äôre making it crystal clear that the purpose of the accompanying closure is, in fact, to configure the instance that‚Äôs passed into it.</p><h2>Conclusion</h2><p>Just like any topic that relates to code style and structure, how to best configure objects and values will most likely always remain a matter of taste. However, regardless of how we actually end up configuring our code ‚Äî if we can do so in a way that‚Äôs fully encapsulated, then those configurations tend to be much easier to both reuse and manage.</p><p>Starting to adopt increasingly declarative coding styles and patterns can also further help ease the transition into the world of SwiftUI and Combine, even if we might expect that it‚Äôll take a year or two before we can actually start adopting those frameworks. Arguably, declarative programming is just as much about ways of thinking, as it is about APIs and syntax.</p><p>What do you think? How do you currently configure your views and other values and objects? Let me know ‚Äî along with your questions, comments or feedback ‚Äî either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/alternatives-to-protocols-in-swift</guid><title>Alternatives to protocols in Swift</title><description>Protocols are, without a doubt, a major part of Swift‚Äôs overall design. However, they also come with their own set of downsides and trade-offs. This week, let‚Äôs take a look at some of those characteristics, and explore a few alternative ways of abstracting code in Swift ‚Äî to see how they compare to using protocols.</description><link>https://www.swiftbysundell.com/articles/alternatives-to-protocols-in-swift</link><pubDate>Sun, 6 Oct 2019 17:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Protocols are, without a doubt, a major part of Swift‚Äôs overall design ‚Äî and can provide a great way to create abstractions, to separate concerns, and to improve the overall flexibility of a system or feature. By not strongly tying types together, but rather connecting the various parts of a code base through more abstract interfaces, we usually end up with a much more decoupled architecture that lets us iterate on each individual feature in isolation.</p><p>However, while protocols can be a great tool in many different situations, they also come with their own set of downsides and trade-offs. This week, let‚Äôs take a look at some of those characteristics, and explore a few alternative ways of abstracting code in Swift ‚Äî to see how they compare to using protocols.</p><h2>Single requirements using closures</h2><p>One of the advantages of abstracting code using protocols is that it lets us group multiple <em>requirements</em> together. For example, a <code>PersistedValue</code> protocol might require both a <code>save</code> and a <code>load</code> method ‚Äî which both enables us to enforce a certain degree of consistency among all such values, and to write shared utilities for saving and loading data.</p><p>However, not all abstractions involve multiple requirements, and it‚Äôs very common to end up with protocols that only have a single method or property ‚Äî such as this one:</p><pre class="splash"><code><span class="s-keyword">protocol</span> ModelProvider {
    <span class="s-keyword">associatedtype</span> Model: <span class="s-type">ModelProtocol</span>
    <span class="s-keyword">func</span> provideModel() -&gt; <span class="s-type">Model</span>
}</code></pre><p>Let‚Äôs say that the above <code>ModelProvider</code> protocol is used to abstract the way we load and provide models across our code base. It uses an associated type in order to let each implementation declare what type of model that it provides in a very type-safe way, which is great, as it enables us to write generic code to perform common tasks ‚Äî such as rendering a detail view for a given model:</p><pre class="splash"><code><span class="s-keyword">class</span> DetailViewController&lt;Model: <span class="s-type">ModelProtocol</span>&gt;: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> modelProvider: <span class="s-type">AnyModelProvider</span>&lt;<span class="s-type">Model</span>&gt;

    <span class="s-keyword">init</span>&lt;T: <span class="s-type">ModelProvider</span>&gt;(modelProvider: <span class="s-type">T</span>) <span class="s-keyword">where</span> <span class="s-type">T</span>.<span class="s-type">Model</span> == <span class="s-type">Model</span> {
        <span class="s-comment">// We wrap the injected provider in an AnyModelProvider
        // instance to be able to store a reference to it.</span>
        <span class="s-keyword">self</span>.<span class="s-property">modelProvider</span> = <span class="s-type">AnyModelProvider</span>(modelProvider)
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }
    
    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> model = modelProvider.<span class="s-call">provideModel</span>()
        ...
    }
    
    ...
}</code></pre><p>While the above code works, it illustrates one of the downsides of using a protocol with associated types ‚Äî we can‚Äôt store a reference to <code>ModelProvider</code> directly. Instead we first have to <em><a href="https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift">perform type erasure</a></em> to turn our protocol reference into a concrete type, which both clutters up our code, and requires us to implement additional types just to be able to use our protocol.</p><p>Since we‚Äôre dealing with a protocol that only has a single requirement, the question is ‚Äî do we <em>really</em> need it? After all, our <code>ModelProvider</code> protocol doesn‚Äôt add any additional grouping or structure, so let‚Äôs instead lift out its sole requirement and turn that into a closure ‚Äî which can then be injected directly, like this:</p><pre class="splash"><code><span class="s-keyword">class</span> DetailViewController&lt;Model: <span class="s-type">ModelProtocol</span>&gt;: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> modelProvider: () -&gt; <span class="s-type">Model</span>

    <span class="s-keyword">init</span>(modelProvider: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Model</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">modelProvider</span> = modelProvider
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        <span class="s-keyword">let</span> model = <span class="s-call">modelProvider</span>()
        ...
    }
    
    ...
}</code></pre><p class="info">To learn more about the above way of dependency injection, check out <a href="https://www.swiftbysundell.com/articles/simple-swift-dependency-injection-with-functions">‚ÄúSimple Swift dependency injection with functions‚Äù</a>, and <a href="https://www.swiftbysundell.com/articles/functional-networking-in-swift">‚ÄúFunctional networking in Swift‚Äù</a>.</p><p>By directly injecting the functionality that we need, rather than requiring a type to conform to a protocol, we‚Äôve also drastically improved the flexibility of our code ‚Äî since we‚Äôre now free to inject anything from a free function, to an inline defined closure, to an instance method. We also no longer have to perform any type erasure, leaving us with much simpler code.</p><h2>Using generic types</h2><p>While closures and functions can be a great way to model single-requirement abstractions, using them can get a bit messy if we‚Äôll start adding additional requirements. For example, let‚Äôs say that we‚Äôd like to extend our above <code>DetailViewController</code> to also support bookmarking and deleting models. If we were to stick with our closure-based approach, we‚Äôd end up with something like this:</p><pre class="splash"><code><span class="s-keyword">class</span> DetailViewController&lt;Model: <span class="s-type">ModelProtocol</span>&gt;: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> modelProvider: () -&gt; <span class="s-type">Model</span>
    <span class="s-keyword">private let</span> modelBookmarker: (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>
    <span class="s-keyword">private let</span> modelDeleter: (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>

    <span class="s-keyword">init</span>(modelProvider: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Model</span>,
         modelBookmarker: <span class="s-keyword">@escaping</span> (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>,
         modelDeleter: <span class="s-keyword">@escaping</span> (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">modelProvider</span> = modelProvider
        <span class="s-keyword">self</span>.<span class="s-property">modelBookmarker</span> = modelBookmarker
        <span class="s-keyword">self</span>.<span class="s-property">modelDeleter</span> = modelDeleter
        
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }
    
    ...
}</code></pre><p>Not only does the above setup require us to keep track of multiple stand-alone closures, we also end up with a lot of duplicated <em>‚Äúmodel‚Äù</em> prefixes ‚Äî which (using the <em><a href="https://www.swiftbysundell.com/articles/structuring-swift-code">‚ÄúRule of Threes‚Äù</a></em>) tells us that we have somewhat of a structural problem here. While we <em>could</em> go back to encapsulating all of the above closures into a protocol, that‚Äôd again require us to do type erasure, and to lose some of that flexibility that we gained when we started using closures.</p><p>Instead, let‚Äôs use a generic type to group our requirements together ‚Äî which both lets us retain the flexibility of using closures, while also adding some additional structure to our code:</p><pre class="splash"><code><span class="s-keyword">struct</span> ModelHandling&lt;Model: <span class="s-type">ModelProtocol</span>&gt; {
    <span class="s-keyword">var</span> provide: () -&gt; <span class="s-type">Model</span>
    <span class="s-keyword">var</span> bookmark: (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>
    <span class="s-keyword">var</span> delete: (<span class="s-type">Model</span>) -&gt; <span class="s-type">Void</span>
}</code></pre><p>Since the above is a concrete type, it doesn‚Äôt require any form of type erasure (in fact, it actually looks quite similar to the sort of type erased wrappers that we‚Äôre often forced to write when using protocols with associated types). So, just like a closure, it can be used and stored directly ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> DetailViewController&lt;Model: <span class="s-type">ModelProtocol</span>&gt;: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">private let</span> modelHandler: <span class="s-type">ModelHandling</span>&lt;<span class="s-type">Model</span>&gt;
    <span class="s-keyword">private lazy var</span> model = modelHandler.<span class="s-call">provide</span>()

    <span class="s-keyword">init</span>(modelHandler: <span class="s-type">ModelHandling</span>&lt;<span class="s-type">Model</span>&gt;) {
        <span class="s-keyword">self</span>.<span class="s-property">modelHandler</span> = modelHandler
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(nibName: <span class="s-keyword">nil</span>, bundle: <span class="s-keyword">nil</span>)
    }

    <span class="s-keyword">@objc private func</span> bookmarkButtonTapped() {
        modelHandler.<span class="s-call">bookmark</span>(model)
    }
    
    <span class="s-keyword">@objc private func</span> deleteButtonTapped() {
        modelHandler.<span class="s-call">delete</span>(model)
        <span class="s-call">dismiss</span>(animated: <span class="s-keyword">true</span>)
    }
    
    ...
}</code></pre><p>While protocols with associated types are incredibly useful when defining more high-level requirements (just like the standard library‚Äôs <code>Equatable</code> and <code>Collection</code> protocols do), when such a protocol needs to be used directly, using either a stand-alone closure or a generic type instead can often give us the same level of encapsulation ‚Äî but through a much simpler abstraction.</p><h2>Separating requirements using enums</h2><p>A common challenge when designing any sort of abstraction is to not <em>‚Äúover-abstract‚Äù</em> by adding too many requirements. For example, let‚Äôs now say that we‚Äôre working on an app that lets the user consume multiple kinds of media ‚Äî like articles, podcasts, videos, and so on ‚Äî and that we‚Äôd like to create a shared abstraction for all of those different formats. If we again start with the protocol-oriented approach, we might end up with something like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Media {
    <span class="s-keyword">var</span> id: <span class="s-type">UUID</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> description: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>? { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>? { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span>? { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> resolution: <span class="s-type">Resolution</span>? { <span class="s-keyword">get</span> }
}</code></pre><p>Since the above protocol needs to work with all different kinds of media, we end up with multiple properties that are only relevant for certain formats. For example, an <code>Article</code> type doesn‚Äôt have any concept of a <em>duration</em> or <em>resolution</em> ‚Äî leaving us with several properties that we simply have to implement because our protocol requires us to:</p><pre class="splash"><code><span class="s-keyword">struct</span> Article: <span class="s-type">Media</span> {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>
    <span class="s-keyword">var</span> text: <span class="s-type">String</span>?
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>? { <span class="s-keyword">return nil</span> }
    <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span>? { <span class="s-keyword">return nil</span> }
    <span class="s-keyword">var</span> resolution: <span class="s-type">Resolution</span>? { <span class="s-keyword">return nil</span> }
}</code></pre><p>Not only does the above setup require us to add unnecessary boilerplate to our conforming types, it could also be a source of ambiguity ‚Äî as there‚Äôs no way for us to enforce that an article actually contains text, or that the types that should support a URL, duration or resolution actually carries that data ‚Äî since all of those properties are optionals.</p><p>There are multiple ways that we could address the above problem, starting with splitting our protocol up into multiple ones, each with an <a href="https://www.swiftbysundell.com/articles/specializing-protocols-in-swift">increasing degree of specialization</a> ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">protocol</span> Media {
    <span class="s-keyword">var</span> id: <span class="s-type">UUID</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> title: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> description: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">protocol</span> ReadableMedia: <span class="s-type">Media</span> {
    <span class="s-keyword">var</span> text: <span class="s-type">String</span> { <span class="s-keyword">get</span> }
}

<span class="s-keyword">protocol</span> PlayableMedia: <span class="s-type">Media</span> {
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span> { <span class="s-keyword">get</span> }
    <span class="s-keyword">var</span> resolution: <span class="s-type">Resolution</span>? { <span class="s-keyword">get</span> }
}</code></pre><p>The above is definitely an improvement, as it would enable us to have types like <code>Article</code> conform to <code>ReadableMedia</code>, and playable types (like <code>Audio</code> and <code>Video</code>) conform to <code>PlayableMedia</code> ‚Äî reducing both ambiguity and boilerplate, as each type can pick which specialized version of <code>Media</code> that it wants to conform to.</p><p>However, since the above protocols are all about data, it would arguably make even more sense to model them using an <em>actual data type</em> instead ‚Äî which would both reduce the need for duplicate implementations, and would also let us work with any media format through a single, concrete type:</p><pre class="splash"><code><span class="s-keyword">struct</span> Media {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>
    <span class="s-keyword">var</span> content: <span class="s-type">Content</span>
}</code></pre><p>The above struct now only contains the data that‚Äôs shared among all of our media formats, except for its <code>content</code> property ‚Äî which is what we‚Äôll use for specialization. But this time, rather than making <code>Content</code> a protocol, let‚Äôs use an enum ‚Äî which will enable us to define a tailored set of properties for each format, through associated values:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Media</span> {
    <span class="s-keyword">enum</span> Content {
        <span class="s-keyword">case</span> article(text: <span class="s-type">String</span>)
        <span class="s-keyword">case</span> audio(<span class="s-type">Playable</span>)
        <span class="s-keyword">case</span> video(<span class="s-type">Playable</span>, resolution: <span class="s-type">Resolution</span>)
    }
    
    <span class="s-keyword">struct</span> Playable {
        <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
        <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span>
    }
}</code></pre><p>Gone are the optionals, and we‚Äôve now achieved a nice balance between having a shared abstraction and enabling format-specific specialization. The beauty of enums is also that they enable us to express data variance without having to use either generics or protocols ‚Äî everything can be encapsulated within the same, concrete type, as long as we know the number of variants up-front.</p><h2>Classes and inheritance</h2><p>Another approach that might not be as popular in Swift as in other languages, but is still definitely worth considering, is to create abstractions using classes that are specialized through inheritance. For example, rather than using a <code>Content</code> enum to implement our above media formats, we could‚Äôve used a <code>Media</code> base class that would then be subclassed in order to add format-specific properties ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">class</span> Media {
    <span class="s-keyword">let</span> id: <span class="s-type">UUID</span>
    <span class="s-keyword">var</span> title: <span class="s-type">String</span>
    <span class="s-keyword">var</span> description: <span class="s-type">String</span>

    <span class="s-keyword">init</span>(id: <span class="s-type">UUID</span>, title: <span class="s-type">String</span>, description: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">id</span> = id
        <span class="s-keyword">self</span>.<span class="s-property">title</span> = title
        <span class="s-keyword">self</span>.<span class="s-property">description</span> = description
    }
}

<span class="s-keyword">class</span> PlayableMedia: <span class="s-type">Media</span> {
    <span class="s-keyword">var</span> url: <span class="s-type">URL</span>
    <span class="s-keyword">var</span> duration: <span class="s-type">TimeInterval</span>

    <span class="s-keyword">init</span>(id: <span class="s-type">UUID</span>,
         title: <span class="s-type">String</span>,
         description: <span class="s-type">String</span>,
         url: <span class="s-type">URL</span>,
         duration: <span class="s-type">TimeInterval</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">url</span> = url
        <span class="s-keyword">self</span>.<span class="s-property">duration</span> = duration
        <span class="s-keyword">super</span>.<span class="s-keyword">init</span>(id: id, title: title, description: description)
    }
}</code></pre><p>However, while the above approach makes total sense from a structural perspective ‚Äî it does come with a few downsides. First, since classes don‚Äôt yet support memberwise initializers, we have to define all initializers ourselves ‚Äî and we also have to manually pass data upwards through our inheritance tree by calling <code>super.init</code>. But perhaps more importantly is that classes are <a href="https://www.swiftbysundell.com/basics/value-and-reference-types">reference types</a>, which means that we‚Äôd have to be careful not to perform any unexpected mutations when sharing <code>Media</code> instances across our code base.</p><p>But that doesn‚Äôt mean that there are no valid use cases for inheritance in Swift. For example, in <em><a href="https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift">‚ÄúUnder the hood of Futures &amp; Promises in Swift‚Äù</a></em>, inheritance provided a great way to expose a read-only <code>Future</code> type to API users ‚Äî while still enabling such an instance to be privately mutated through a <code>Promise</code> subclass:</p><pre class="splash"><code><span class="s-keyword">class</span> Future&lt;Value&gt; {
    <span class="s-keyword">fileprivate var</span> result: <span class="s-type">Result</span>&lt;<span class="s-type">Value</span>, <span class="s-type">Error</span>&gt;? {
        <span class="s-keyword">didSet</span> { result.<span class="s-call">map</span>(report) }
    }
    
    ...
}

<span class="s-keyword">class</span> Promise&lt;Value&gt;: <span class="s-type">Future</span>&lt;<span class="s-type">Value</span>&gt; {
    <span class="s-keyword">func</span> resolve(with value: <span class="s-type">Value</span>) {
        result = .<span class="s-call">success</span>(value)
    }

    <span class="s-keyword">func</span> reject(with error: <span class="s-type">Error</span>) {
        result = .<span class="s-call">failure</span>(error)
    }
}

<span class="s-keyword">func</span> loadCachedData() -&gt; <span class="s-type">Future</span>&lt;<span class="s-type">Data</span>&gt; {
    <span class="s-keyword">let</span> promise = <span class="s-type">Promise</span>&lt;<span class="s-type">Data</span>&gt;()
    cache.<span class="s-call">load</span> { promise.<span class="s-call">resolve</span>(with: $0) }
    <span class="s-keyword">return</span> promise
}</code></pre><p>Using the above setup, we can enable the same instance to expose a different set of APIs in different contexts, which is really useful when we want to only allow one of those contexts to mutate a given object. That‚Äôs especially true when working with generic code, as we‚Äôd again run into the associated types problem if we were to try to achieve the same thing using a protocol instead.</p><h2>Conclusion</h2><p>Protocols are great, and will most likely remain the most common way of defining abstractions in Swift for the foreseeable future. However, that doesn‚Äôt mean that using a protocol will always be the best solution ‚Äî sometimes looking beyond the popular <em>‚Äúprotocol-oriented programming‚Äù</em> mantra can result in code that‚Äôs both simpler and more robust ‚Äî especially if the protocol we‚Äôre looking to define requires us to use associated types.</p><p>What do you think? Besides protocols, what are your favorite ways of creating abstractions in Swift? Let me know ‚Äî along with any questions, comments or feedback that you might have ‚Äî either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/computing-dates-in-swift</guid><title>Computing dates in Swift</title><description>Let‚Äôs take a look at Foundation‚Äôs date handling APIs ‚Äî how they can enable us to easily make the way we compute dates more correct, and how we can build our own lightweight abstractions on top of them to make dealing with dates in Swift a lot easier.</description><link>https://www.swiftbysundell.com/articles/computing-dates-in-swift</link><pubDate>Sun, 29 Sep 2019 18:00:00 +0200</pubDate><content:encoded><![CDATA[<p>The task of computing various dates and timestamps is something that at first may seem deceptively simple. We all know that a minute consists of sixty seconds, an hour of sixty minutes and that there are twenty-four hours in a day ‚Äî however, correctly computing and modifying dates often requires a far more complex model.</p><p>Thankfully, Apple ships a complete set of date and calendar APIs as part of Foundation, and while some of those APIs may seem a bit complex at first glance ‚Äî they enable us to write date handling code that takes all sorts of anomalies and cultural differences into account, without requiring us to know about any of those conditions ourselves.</p><p>This week, let‚Äôs take a look at a few examples of how we might use those APIs ‚Äî how they can enable us to easily make the way we compute dates more correct, and how we can build our own lightweight abstractions on top of them to make dealing with dates in Swift a lot easier.</p><h2>Not always a time interval away</h2><p>The <code>TimeInterval</code> type (which is actually just a <a href="https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift">type alias</a> for <code>Double</code>) enables us to express time as an interval of seconds ‚Äî which is incredibly useful when we want to compute a date within the very near future, such as in this example, in which we‚Äôre scheduling a notification to be shown after 20 seconds:</p><pre class="splash"><code><span class="s-keyword">let</span> date = <span class="s-type">Date</span>().<span class="s-call">addingTimeInterval</span>(<span class="s-number">20</span>)
<span class="s-call">schedule</span>(notification, for: date)</code></pre><p>However, the above way of computing dates breaks down quite quickly as our time interval grows ‚Äî as simply adding a number of seconds to the current date won‚Äôt account for things like leap seconds, changes in daylight savings time, or other time corrections and adjustments.</p><p>For example, although the following code might give us a date that‚Äôs technically 24 hours away in terms of number of seconds, it won‚Äôt always be <em>‚Äútomorrow‚Äù</em> ‚Äî as a time adjustment might either push the resulting date into the following or previous day, or otherwise affect the perceived time of day:</p><pre class="splash"><code><span class="s-keyword">let</span> tomorrow = <span class="s-type">Date</span>().<span class="s-call">addingTimeInterval</span>(<span class="s-number">60</span> * <span class="s-number">60</span> * <span class="s-number">24</span>)</code></pre><p>While absolute precision isn‚Äôt always required when handling dates, using manually computed time intervals can lead to some really tricky bugs if our code assumes that <code>tomorrow</code> doesn‚Äôt simply mean <em>‚Äú24 hours away in terms of absolute time‚Äù</em>, but rather <em>‚Äúthe same time as now, but tomorrow‚Äù</em>.</p><p>To compute the latter in a way that‚Äôs a lot more robust, let‚Äôs instead use Foundation‚Äôs <code>Calendar</code> type, which enables us to manipulate dates according to a specific calendar (the most common of which is the <em>Gregorian Calendar</em>) ‚Äî with nanosecond-level precision:</p><pre class="splash"><code><span class="s-comment">// Calendar.current gives us access to a calendar that‚Äôs
// configured according to the user‚Äôs system settings:</span>
<span class="s-keyword">let</span> calendar = <span class="s-type">Calendar</span>.<span class="s-property">current</span>
<span class="s-keyword">let</span> date = <span class="s-type">Date</span>()

<span class="s-comment">// Define which date components that we want to be considered
// when looking for tomorrow‚Äôs date. This essentially decides
// what level of precision that we‚Äôd like:</span>
<span class="s-keyword">let</span> components = calendar.<span class="s-call">dateComponents</span>(
    [.<span class="s-dotAccess">hour</span>, .<span class="s-dotAccess">minute</span>, .<span class="s-dotAccess">second</span>, .<span class="s-dotAccess">nanosecond</span>],
    from: date
)

<span class="s-keyword">let</span> tomorrow = calendar.<span class="s-call">nextDate</span>(
    after: date,
    matching: components,
    matchingPolicy: .<span class="s-dotAccess">nextTime</span>
)</code></pre><p class="info">If we were planning to store the above <code>Calendar</code> value for further use, it‚Äôd be much better to access it using <code>Calendar.autoupdatingCurrent</code>, since that‚Äôll track any changes that the user might make to their system-wide calendar preferences.</p><p>While the above will truly give us a date that‚Äôs equivalent to the same time as right now but tomorrow, writing all of that code each time we want to perform such a date calculation can quickly get repetitive ‚Äî so let‚Äôs move it into an extension on <code>Date</code> instead:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Date</span> {
    <span class="s-keyword">func</span> sameTimeNextDay(
        inDirection direction: <span class="s-type">Calendar</span>.<span class="s-type">SearchDirection</span> = .<span class="s-dotAccess">forward</span>,
        using calendar: <span class="s-type">Calendar</span> = .<span class="s-dotAccess">current</span>
    ) -&gt; <span class="s-type">Date</span> {
        <span class="s-keyword">let</span> components = calendar.<span class="s-call">dateComponents</span>(
            [.<span class="s-dotAccess">hour</span>, .<span class="s-dotAccess">minute</span>, .<span class="s-dotAccess">second</span>, .<span class="s-dotAccess">nanosecond</span>],
            from: <span class="s-keyword">self</span>
        )
        
        <span class="s-keyword">return</span> calendar.<span class="s-call">nextDate</span>(
            after: <span class="s-keyword">self</span>,
            matching: components,
            matchingPolicy: .<span class="s-dotAccess">nextTime</span>,
            direction: direction
        )!
    }
}</code></pre><p class="info"><code>Calendar</code> very often returns an optional <code>Date</code> from its various APIs, since the <code>DateComponents</code> used might contain an invalid combination of units (for example specifying the 31st of February as a date). However, in the above example we‚Äôre sure that our input is valid, so we force unwrap the result.</p><p>Above we also add support for specifying a <code>SearchDirection</code>, which enables us to move either forward or backward in time when calculating the next date ‚Äî which in turn enables us to create two convenience APIs, one for accessing the current time tomorrow, and one for doing the same thing but for yesterday instead:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Date</span> {
    <span class="s-keyword">static var</span> currentTimeTomorrow: <span class="s-type">Date</span> {
        <span class="s-keyword">return</span> <span class="s-type">Date</span>().<span class="s-call">sameTimeNextDay</span>()
    }
    
    <span class="s-keyword">static var</span> currentTimeYesterday: <span class="s-type">Date</span> {
        <span class="s-keyword">return</span> <span class="s-type">Date</span>().<span class="s-call">sameTimeNextDay</span>(inDirection: .<span class="s-dotAccess">backward</span>)
    }
}</code></pre><p>With the above in place, we can now simply pass <code>.currentTimeTomorrow</code> or <code>.currentTimeYesterday</code> to any API that accepts a <code>Date</code>, which is actually <em>simpler</em> than manually computing a date by adding a time interval ‚Äî while also being much more robust as well.</p><h2>From time intervals to date intervals</h2><p>Apart from moving a date forwards or backwards in time, <code>Calendar</code> also contains a suite of APIs for dealing with dates in terms of intervals. While a <code>Date</code> value represents a single point in time, our perception of time often revolves more around intervals like days, weeks, and years ‚Äî rather than absolute timestamps.</p><p>For example, let‚Äôs say that we‚Äôre working on an app that refreshes the content shown to each user at midnight within the user‚Äôs current timezone. So rather than constantly trying to fetch new content from our server, we‚Äôll cache any loaded content until midnight that day ‚Äî to only perform a new request once the next day has begun.</p><p>Rather than having to manually calculate the exact <code>Date</code> that corresponds to the start of the next day, let‚Äôs call the <code>startOfDay</code> method on our <code>Calendar</code>, in combination with our newly added <code>currentTimeTomorrow</code> convenience API ‚Äî like this:</p><pre class="splash"><code><span class="s-keyword">func</span> contentDidLoad(<span class="s-keyword">_</span> content: <span class="s-type">Content</span>) {
    <span class="s-keyword">let</span> refreshDate = calendar.<span class="s-call">startOfDay</span>(for: .<span class="s-dotAccess">currentTimeTomorrow</span>)
    <span class="s-call">cache</span>(content, until: refreshDate)
}</code></pre><p>However, while the above will give us the exact date at which our new content <em>should</em> be ready, all clocks aren‚Äôt perfectly synchronized ‚Äî meaning that if we‚Äôd perform our network request at that exact date, we might still end up getting yesterday‚Äôs content back as a response, in case our server‚Äôs clock is slightly behind our client-side one.</p><p>To fix that problem, let‚Äôs again enlist the help of <code>TimeInterval</code>, and simply add 100 seconds to our refresh date in order to give us a <em>‚Äúbuffer‚Äù</em> that should be enough to account for any differences between our client and server-side clocks:</p><pre class="splash"><code><span class="s-keyword">func</span> contentDidLoad(<span class="s-keyword">_</span> content: <span class="s-type">Content</span>) {
    <span class="s-keyword">let</span> refreshDate = calendar.<span class="s-call">startOfDay</span>(for: .<span class="s-dotAccess">currentTimeTomorrow</span>)
    <span class="s-call">cache</span>(content, until: refreshDate.<span class="s-call">addingTimeInterval</span>(<span class="s-number">100</span>))
}</code></pre><p class="info">The above is a great use case for a <code>TimeInterval</code>-based date manipulation, since we‚Äôre looking to shift our date in terms of absolute seconds, rather than retrieving a human-readable one.</p><p>Besides computing the start of a given interval, such as a day, <code>Calendar</code> also enables us to search for complete intervals as well ‚Äî such as the next weekend that‚Äôll come after a given date:</p><pre class="splash"><code><span class="s-keyword">let</span> nextWeekend = calendar.<span class="s-call">nextWeekend</span>(startingAfter: <span class="s-type">Date</span>())!

<span class="s-call">showPartySchedulingView</span>(
    withStartDate: nextWeekend.<span class="s-property">start</span>,
    endDate: nextWeekend.<span class="s-property">end</span>
)</code></pre><p>Finally, we can also use <code>Calendar</code> to retrieve an interval that a given date is a part of. For example, here‚Äôs how we could retrieve the start and end dates of the current day, month, and year:</p><pre class="splash"><code><span class="s-keyword">let</span> date = <span class="s-type">Date</span>()
<span class="s-keyword">let</span> today = calendar.<span class="s-call">dateInterval</span>(of: .<span class="s-dotAccess">day</span>, for: date)
<span class="s-keyword">let</span> currentMonth = calendar.<span class="s-call">dateInterval</span>(of: .<span class="s-dotAccess">month</span>, for: date)
<span class="s-keyword">let</span> currentYear = calendar.<span class="s-call">dateInterval</span>(of: .<span class="s-dotAccess">year</span>, for: date)</code></pre><p>Along the same lines, here‚Äôs how we could compute the date interval for the following year, by adding one year to the current date, and then using that date to retrieve our interval:</p><pre class="splash"><code><span class="s-keyword">let</span> components = <span class="s-type">DateComponents</span>(year: <span class="s-number">1</span>)
<span class="s-keyword">let</span> todayNextYear = calendar.<span class="s-call">date</span>(byAdding: components, to: <span class="s-type">Date</span>())!
<span class="s-keyword">let</span> nextYear = calendar.<span class="s-call">dateInterval</span>(of: .<span class="s-dotAccess">year</span>, for: todayNextYear)</code></pre><p>Above we use <code>DateComponents</code> to manipulate the current date, which we also used in the initial example to specify the granularity of a date search. Just like how <code>URLComponents</code> can be used to <a href="https://www.swiftbysundell.com/articles/constructing-urls-in-swift">define the individual components</a> that make up a URL, a <code>DateComponents</code> value can be used to refer to various units of time ‚Äî such as hours, days, and years ‚Äî when either searching for a date, or when mutating one.</p><h2>Conclusion</h2><p>The differences in how time is represented within various cultures around the world (and throughout history), as well as how each of our calendar and time measurement systems include correcting mechanisms ‚Äî such as leap days and daylight savings time ‚Äî makes computing dates a lot more complex than what it first might seem like.</p><p>However, most of those complexities can be handled for us by the system, as long as we use the right APIs to perform our date calculations ‚Äî and while this article didn‚Äôt cover <em>all</em> such APIs ‚Äî I hope that it can act as a reference for when your code next needs to travel either forwards or backwards in time.</p><p>If you have any questions, comments, or feedback ‚Äî then feel free to contact me either <a href="https://twitter.com/johnsundell">via Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/making-types-expressible-by-string-interpolation</guid><title>Tip: Making types expressible by string interpolation</title><description>How to enable a type to be expressed by strings that contain interpolated values.</description><link>https://www.swiftbysundell.com/tips/making-types-expressible-by-string-interpolation</link><pubDate>Fri, 27 Sep 2019 16:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Creating wrapper types for raw values, such as strings and integers, can be a great way to make our code a bit more type-safe and self-documenting ‚Äî and also gives us dedicated types on which we can implement domain-specific convenience APIs.</p><p>For example, here‚Äôs such a type that represents a file system path, which can be used to do things like load the contents of a file:</p><pre class="splash"><code><span class="s-keyword">struct</span> Path {
    <span class="s-keyword">var</span> string: <span class="s-type">String</span>
}

<span class="s-keyword">func</span> loadFile(at path: <span class="s-type">Path</span>) <span class="s-keyword">throws</span> -&gt; <span class="s-type">File</span> {
    ...
}</code></pre><p>However, while having that dedicated <code>Path</code> type does give us several benefits, it could also make our APIs a bit more cumbersome to use. For example, anytime we want to specify a path using a string literal, we now have to wrap it first:</p><pre class="splash"><code><span class="s-keyword">try</span> <span class="s-call">loadFile</span>(at: <span class="s-type">Path</span>(string: <span class="s-string">"~/documents/article.md"</span>))</code></pre><p>To fix that, we can make <code>Path</code> conform to <code>ExpressibleByStringLiteral</code>, which enables us to directly pass a string literal to any API that accepts a <code>Path</code>:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Path</span>: <span class="s-type">ExpressibleByStringLiteral</span> {
    <span class="s-keyword">init</span>(stringLiteral value: <span class="s-type">String</span>) {
        <span class="s-keyword">self</span>.<span class="s-property">string</span> = value
    }
}

<span class="s-keyword">try</span> <span class="s-call">loadFile</span>(at: <span class="s-string">"~/documents/article.md"</span>)</code></pre><p>That‚Äôs really nice, however, the above won‚Äôt work if we‚Äôre using any form of interpolation within our string ‚Äî such as in this case:</p><pre class="splash"><code><span class="s-comment">// Since this string literal contains interpolation, it won't
// be automatically converted to a Path, and we'll get an error:</span>
<span class="s-keyword">try</span> <span class="s-call">loadFile</span>(at: <span class="s-string">"/users/</span>\(username)<span class="s-string">/file.txt"</span>)</code></pre><p>Thankfully, the above problem is easily fixed. All we have to do is to declare that our <code>Path</code> also conforms to <code>ExpressibleByStringInterpolation</code> ‚Äî and the compiler will be able to infer the rest:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Path</span>: <span class="s-type">ExpressibleByStringInterpolation</span> {}</code></pre><p>We can now express our <code>Path</code> type using any kind of string literal ‚Äî which makes it much more convenient to use, while still giving us all of the benefits of stronger typing.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/closures</guid><title>Basics: Closures</title><description>A look at a few different ways that closures can be defined and used in Swift, the flexibility of Swift‚Äôs closure syntax, and how behaviors like escaping and capturing may impact our code.</description><link>https://www.swiftbysundell.com/basics/closures</link><pubDate>Wed, 25 Sep 2019 17:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Just like functions, closures enable us to define a group of code statements that can be called as one unit, which can both accept input and produce output. The difference, however, is that closures can be defined <em>inline</em> ‚Äî right at the point where we want to use them ‚Äî which is incredibly useful in a number of different situations.</p><p>Closures can both be stored as properties and local variables, and can also be passed as arguments to functions (or other closures), like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> IntToStringConverter {
    <span class="s-comment">// A closure property that takes an Int as input
    // and produces a String as output:</span>
    <span class="s-keyword">var</span> body: (<span class="s-type">Int</span>) -&gt; <span class="s-type">String</span>
}

<span class="s-comment">// A closure defined as an inline variable, which
// takes no input and produces an Int as output:</span>
<span class="s-keyword">let</span> intProvider: () -&gt; <span class="s-type">Int</span> = { <span class="s-keyword">return</span> <span class="s-number">7</span> }

<span class="s-comment">// A closure function argument that takes no input
// and also doesn't produce any output:</span>
<span class="s-keyword">func</span> performOperation(then closure: () -&gt; <span class="s-type">Void</span>) {
    ...
}</code></pre><p>To take a look at how closures can be really useful in practice, let‚Äôs say that we wanted to extend Swift‚Äôs <code>String</code> type with a function that enables us to transform each word that appears within a string. By using a closure, we can enable the callers of our new function to freely decide <em>exactly how</em> to perform each transform:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">String</span> {
    <span class="s-keyword">func</span> transformWords(
        using closure: (<span class="s-type">Substring</span>) -&gt; <span class="s-type">String</span>
    ) -&gt; <span class="s-type">String</span> {
        <span class="s-comment">// Split the current string up into word substrings:</span>
        <span class="s-keyword">let</span> words = <span class="s-call">split</span>(separator: <span class="s-string">" "</span>)
        <span class="s-keyword">var</span> results = [<span class="s-type">String</span>]()

        <span class="s-comment">// Iterate through each word and transform it:</span>
        <span class="s-keyword">for</span> word <span class="s-keyword">in</span> words {
            <span class="s-comment">// We can call the closure that was passed into our
            // function just like how we'd call a function:</span>
            <span class="s-keyword">let</span> transformed = <span class="s-call">closure</span>(word)
            results.<span class="s-call">append</span>(transformed)
        }

        <span class="s-comment">// Join our results array back into a string:</span>
        <span class="s-keyword">return</span> results.<span class="s-call">joined</span>(separator: <span class="s-string">" "</span>)
    }
}</code></pre><p class="info">Note that the above sample code is just an example, as it‚Äôs not a very efficient way to transform strings. To learn more about strings and how the above <code>Substring</code> type works, check out the <a href="https://www.swiftbysundell.com/basics/strings">‚ÄúStrings‚Äù article</a>.</p><p>We can now call the above function with any closure that we want, as long as it takes a <code>Substring</code> as input, and produces a <code>String</code> as output. For example, here‚Äôs how we could transform each word within a string into lowercase:</p><pre class="splash"><code><span class="s-keyword">let</span> string = <span class="s-string">"Hello, world!"</span>.<span class="s-call">transformWords</span>(using: { word <span class="s-keyword">in
    return</span> word.<span class="s-call">lowercased</span>()
})

<span class="s-call">print</span>(string) <span class="s-comment">// "hello, world!"</span></code></pre><p class="info">The <code>in</code> keyword that we use above is, among other things, used to name the arguments that our closure accepts.</p><p>Compared to most other language features, Swift‚Äôs closure syntax is quite flexible, and there‚Äôs a number of features that we can take advantage of in order to make the above code a bit more compact:</p><ul><li>Using <em>trailing closure syntax</em>, we can simply append our closure to the name of the function that we‚Äôre calling, rather than having to type out the parentheses and the parameter label.</li><li>We can replace <code>word in</code> with the <code>$0</code> <em>closure argument shorthand</em>, which lets us refer to the first (and in our case, only) argument passed into the closure.</li><li>We can remove the <code>return</code> keyword, which is not required for single-expression closures (a feature that, starting with Swift 5.1, also applies to functions and computed properties).</li></ul><p>By applying all of the above, our code will now look like this instead:</p><pre class="splash"><code><span class="s-keyword">let</span> string = <span class="s-string">"Hello, world!"</span>.<span class="s-call">transformWords</span> { $0.<span class="s-call">lowercased</span>() }</code></pre><p class="info">When using a more compact syntax, we always have to be careful not to reduce the readability of our code too much ‚Äî so for more complex closures, using a more verbose syntax variant may be more appropriate.</p><p>Not only can newly defined closures be passed as function arguments, we can also pass an existing closure on to another function as well. For example, here‚Äôs how we could go back to the implementation of our <code>transformWords</code> function, and simply pass the given closure to <code>map</code> ‚Äî rather than having write a manual iteration:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">String</span> {
    <span class="s-keyword">func</span> transformWords(
        using closure: (<span class="s-type">Substring</span>) -&gt; <span class="s-type">String</span>
    ) -&gt; <span class="s-type">String</span> {
        <span class="s-keyword">let</span> words = <span class="s-call">split</span>(separator: <span class="s-string">" "</span>)
        <span class="s-keyword">let</span> results = words.<span class="s-call">map</span>(closure)
        <span class="s-keyword">return</span> results.<span class="s-call">joined</span>(separator: <span class="s-string">" "</span>)
    }
}</code></pre><p class="info">To learn more about <code>map</code>, check out the <a href="https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap">‚ÄúMap, FlatMap and CompactMap‚Äù article</a>.</p><p>So far, we‚Äôve only used closures that are immediately executed and then discarded ‚Äî but it‚Äôs also very common to want to store a closure for later use. For example, let‚Äôs say that we wanted to write a <code>delay</code> function, that lets us delay the execution of any closure by a certain amount of seconds. To do that, we‚Äôll use <a href="https://www.swiftbysundell.com/basics/grand-central-dispatch">Grand Central Dispatch</a>‚Äôs <code>asyncAfter</code> API ‚Äî however, since passing our closure to that API will cause it to be stored until our delay time interval has passed, we‚Äôll need to mark it as <code>@escaping</code>, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> delay(by seconds: <span class="s-type">TimeInterval</span>,
           on queue: <span class="s-type">DispatchQueue</span> = .<span class="s-dotAccess">main</span>,
           closure: <span class="s-keyword">@escaping</span> () -&gt; <span class="s-type">Void</span>) {
    queue.<span class="s-call">asyncAfter</span>(
        deadline: .<span class="s-call">now</span>() + seconds,
        execute: closure
    )
}</code></pre><p>When a closure is marked as <code>@escaping</code>, it both means that it can be stored for later use, and it also means that we‚Äôll need to explicitly use <code>self</code> whenever we‚Äôre accessing an instance property or method within it:</p><pre class="splash"><code><span class="s-keyword">class</span> ProfileViewController: <span class="s-type">UIViewController</span> {
    <span class="s-keyword">override func</span> viewWillAppear(<span class="s-keyword">_</span> animated: <span class="s-type">Bool</span>) {
        <span class="s-keyword">super</span>.<span class="s-call">viewWillAppear</span>(animated)

        <span class="s-call">delay</span>(by: <span class="s-number">2</span>) {
            <span class="s-comment">// We need to use 'self' here to be able to call our
            // method, since we're inside an escaping closure.</span>
            <span class="s-keyword">self</span>.<span class="s-call">showTutorialIfNeeded</span>()
        }
    }

    <span class="s-keyword">private func</span> showTutorialIfNeeded() {
        ...
    }
}</code></pre><p>However, there‚Äôs something that we need to be very careful with when writing code like the above ‚Äî and that‚Äôs <em>capturing</em>. The reason we have to explicitly use <code>self</code> within escaping closures is that it causes that object to be captured, meaning that it‚Äôll be retained in memory for as long as the closure itself remains in memory, which can cause memory leaks if we‚Äôre not careful.</p><p>Like we took a look at in the <a href="https://www.swiftbysundell.com/basics/memory-management"><em>‚ÄúMemory Management‚Äù</em> article</a>, one way to prevent a strong capture from happening is to use a <em>capture list</em> to specify that we‚Äôd like to capture <code>self</code> weakly ‚Äî which won‚Äôt cause it to be strongly retained:</p><pre class="splash"><code><span class="s-call">delay</span>(by: <span class="s-number">2</span>) { [<span class="s-keyword">weak self</span>] <span class="s-keyword">in
    self</span>?.<span class="s-call">showTutorialIfNeeded</span>()
}</code></pre><p class="info">Note that in the above example, it‚Äôs not <strong>really</strong> a big deal that we capture <code>self</code> strongly, as our closure will only be retained for 2 seconds. However, as we might increase that time interval in the future, it can still be a good idea to use <code>weak</code> ‚Äî especially since there‚Äôs no reason for <code>self</code> to be retained strongly in this case anyway.</p><p>Finally, let‚Äôs take a look at how the line between functions and closures gets even more blurred as we start utilizing Swift‚Äôs <a href="https://www.swiftbysundell.com/articles/first-class-functions-in-swift">first class function</a> capabilities. Going back to our earlier example of transforming words, let‚Äôs say that we‚Äôve defined a standard function that capitalizes any word passed to it:</p><pre class="splash"><code><span class="s-keyword">func</span> capitalize(word: <span class="s-type">Substring</span>) -&gt; <span class="s-type">String</span> {
    <span class="s-keyword">return</span> word.<span class="s-property">capitalized</span>
}</code></pre><p>Since Swift supports first class functions, we can actually pass the above function just as if it was a <code>(Substring) -&gt; String</code> closure ‚Äî which in turn lets us use it as an argument when calling our previous <code>transformWords</code> function, since it accepts a closure with that exact shape:</p><pre class="splash"><code><span class="s-keyword">let</span> name = <span class="s-string">"swift by sundell"</span>.<span class="s-call">transformWords</span>(using: capitalize)
<span class="s-call">print</span>(name) <span class="s-comment">// "Swift By Sundell"</span></code></pre><p>Pretty cool! There‚Äôs of course a huge number of other things that we can do with closures in Swift, some of which can take us deeper into the realm of functional programming ‚Äî but I hope that this article has given you a quick basic overview of how closures can be used in Swift.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/5-small-but-significant-improvements-in-swift-5-1</guid><title>5 small but significant improvements in Swift 5.1</title><description>Swift 5.1 has now been officially released, and despite being a minor release, it contains a substantial number of changes and improvements. This week, let‚Äôs take a look at five of those features, and what kind of situations they could be useful in.</description><link>https://www.swiftbysundell.com/articles/5-small-but-significant-improvements-in-swift-5-1</link><pubDate>Sun, 22 Sep 2019 17:30:00 +0200</pubDate><content:encoded><![CDATA[<p>Swift 5.1 has now been officially released, and despite being a minor release, it contains a substantial number of changes and improvements ‚Äî ranging from fundamental new features, like module stability (which enables SDK vendors to ship pre-compiled Swift frameworks), to all of the <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">new syntax features that power SwiftUI</a>, and beyond.</p><p>Besides its headlining new features, Swift 5.1 also contains a number of smaller ‚Äî but still highly significant ‚Äî new capabilities and improvements. It‚Äôs the sort of changes that at first may seem really minor, or even unnecessary, but can turn out to have a quite major impact on how we write and structure our Swift code. This week, let‚Äôs take a look at five of those features, and what kind of situations they could be useful in.</p><h2>Memberwise initializers with default values</h2><p>One of the many things that make structs so appealing in Swift is their auto-generated <em>‚Äúmemberwise‚Äù</em> initializers ‚Äî which enable us to initialize any struct (that doesn‚Äôt contain private stored properties) simply by passing values corresponding to each of its properties, like this:</p><pre class="splash"><code><span class="s-keyword">struct</span> Message {
    <span class="s-keyword">var</span> subject: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body: <span class="s-type">String</span>
}

<span class="s-keyword">let</span> message = <span class="s-type">Message</span>(subject: <span class="s-string">"Hello"</span>, body: <span class="s-string">"From Swift"</span>)</code></pre><p>These synthesized initializers have been significantly improved in Swift 5.1, since they now take default property values into account, and automatically translate those values into default initializer arguments.</p><p>Let‚Äôs say that we wanted to expand the above <code>Message</code> struct with support for attachments, but that we‚Äôd like the default value to be an empty array ‚Äî and at the same time, we‚Äôd also like to enable a <code>Message</code> to be initialized without having to specify a <code>body</code> up-front, so we‚Äôll give that property a default value as well:</p><pre class="splash"><code><span class="s-keyword">struct</span> Message {
    <span class="s-keyword">var</span> subject: <span class="s-type">String</span>
    <span class="s-keyword">var</span> body = <span class="s-string">""</span>
    <span class="s-keyword">var</span> attachments: [<span class="s-type">Attachment</span>] = []
}</code></pre><p>In Swift 5.0 and earlier, we‚Äôd still have to pass initializer arguments for all of the above properties anyway, regardless of whether they have a default value. However, in Swift 5.1, that‚Äôs no longer the case ‚Äî meaning that we can now initialize a <code>Message</code> by only passing a <code>subject</code>, like this:</p><pre class="splash"><code><span class="s-keyword">var</span> message = <span class="s-type">Message</span>(subject: <span class="s-string">"Hello, world!"</span>)</code></pre><p>That‚Äôs really cool, and it makes using structs even more convenient than before. But perhaps even cooler is that, just like when using standard default arguments, we can still override any default property value by passing an argument for it ‚Äî which gives us a ton of flexibility:</p><pre class="splash"><code><span class="s-keyword">var</span> message = <span class="s-type">Message</span>(
    subject: <span class="s-string">"Hello, world!"</span>,
    body: <span class="s-string">"Swift 5.1 is such a great update!"</span>
)</code></pre><p>However, while memberwise initializers are incredibly useful within an app or module, they‚Äôre still not exposed as part of a module‚Äôs public API ‚Äî meaning that if we‚Äôre building some form of library or framework, we still have to define our public-facing initializers manually (for now).</p><h2> to refer to enclosing types</h2><p>Swift‚Äôs <code>Self</code> keyword (<em>or type, really</em>) has previously enabled us to dynamically refer to a type in contexts where the actual concrete type isn‚Äôt known ‚Äî for example by referring to a protocol‚Äôs implementing type within a protocol extension:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">Numeric</span> {
    <span class="s-keyword">func</span> incremented(by value: <span class="s-type">Self</span> = <span class="s-number">1</span>) -&gt; <span class="s-type">Self</span> {
        <span class="s-keyword">return self</span> + value
    }
}</code></pre><p>While that‚Äôs still possible, the scope of <code>Self</code> has now been extended to also include concrete types ‚Äî like enums, structs and classes ‚Äî enabling us to use <code>Self</code> as a sort of alias referring to a method or property‚Äôs <em>enclosing</em> type, like this:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TextTransform</span> {
    <span class="s-keyword">static var</span> capitalize: <span class="s-type">Self</span> {
        <span class="s-keyword">return</span> <span class="s-type">TextTransform</span> { $0.<span class="s-property">capitalized</span> }
    }

    <span class="s-keyword">static var</span> removeLetters: <span class="s-type">Self</span> {
        <span class="s-keyword">return</span> <span class="s-type">TextTransform</span> { $0.<span class="s-call">filter</span> { !$0.<span class="s-property">isLetter</span> } }
    }
}</code></pre><p>The fact that we can now use <code>Self</code> above, rather than the full <code>TextTransform</code> type name, is of course purely <em>syntactic sugar</em> ‚Äî but it can help make our code a bit more compact, especially when dealing with long type names. We can even use <code>Self</code> inline within a method or property as well, further making the above code even more compact:</p><pre class="splash"><code><span class="s-keyword">extension</span> <span class="s-type">TextTransform</span> {
    <span class="s-keyword">static var</span> capitalize: <span class="s-type">Self</span> {
        <span class="s-keyword">return</span> <span class="s-type">Self</span> { $0.<span class="s-property">capitalized</span> }
    }

    <span class="s-keyword">static var</span> removeLetters: <span class="s-type">Self</span> {
        <span class="s-keyword">return</span> <span class="s-type">Self</span> { $0.<span class="s-call">filter</span> { !$0.<span class="s-property">isLetter</span> } }
    }
}</code></pre><p>Besides referring to an enclosing type itself, we can now also use <code>Self</code> to access static members within an instance method or property ‚Äî which is quite useful in situations when we want to reuse the same value across all instances of a type, such as the <code>cellReuseIdentifier</code> in this example:</p><pre class="splash"><code><span class="s-keyword">class</span> ListViewController: <span class="s-type">UITableViewController</span> {
    <span class="s-keyword">static let</span> cellReuseIdentifier = <span class="s-string">"list-cell"</span>

    <span class="s-keyword">override func</span> viewDidLoad() {
        <span class="s-keyword">super</span>.<span class="s-call">viewDidLoad</span>()

        tableView.<span class="s-call">register</span>(
            <span class="s-type">ListTableViewCell</span>.<span class="s-keyword">self</span>,
            forCellReuseIdentifier: <span class="s-type">Self</span>.<span class="s-property">cellReuseIdentifier</span>
        )
    }
}</code></pre><p>Again, we could‚Äôve simply typed out <code>ListViewController</code> above when accessing our static property, but using <code>Self</code> does arguably improve the readability of our code ‚Äî and will also enable us to rename our view controller without having to update the way we access its static members.</p><h2>Switching on optionals</h2><p>Next, let‚Äôs take a look at how Swift 5.1 makes it easier to perform pattern matching on optionals, which really comes in handy when switching on an optional value. As an example, let‚Äôs say that we‚Äôre working on a music app that contains a <code>Song</code> model ‚Äî which has a <code>downloadState</code> property that lets us keep track of whether a song has been downloaded, if it‚Äôs currently being downloaded, and so on:</p><pre class="splash"><code><span class="s-keyword">struct</span> Song {
    ...
    <span class="s-keyword">var</span> downloadState: <span class="s-type">DownloadState</span>?
}</code></pre><p class="info">The reason the above property is an optional is that we want <code>nil</code> to represent the lack of a download state, that is, if a song hasn‚Äôt been downloaded at all.</p><p>Like we took a look at in <em><a href="https://www.swiftbysundell.com/articles/pattern-matching-in-swift">‚ÄúPattern matching in Swift‚Äù</a></em>, Swift‚Äôs advanced pattern matching capabilities enable us to directly switch on an optional value ‚Äî without having to unwrap it first ‚Äî however, before Swift 5.1, doing so required us to append a question mark to each matching case, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> songDownloadStateDidChange(<span class="s-keyword">_</span> song: <span class="s-type">Song</span>) {
    <span class="s-keyword">switch</span> song.<span class="s-property">downloadState</span> {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloadInProgress</span>?:
        <span class="s-call">showProgressIndiator</span>(for: song)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloadFailed</span>(<span class="s-keyword">let</span> error)?:
        <span class="s-call">showDownloadError</span>(error, for: song)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloaded</span>?:
        <span class="s-call">downloadDidFinish</span>(for: song)
    <span class="s-keyword">case nil</span>:
        <span class="s-keyword">break</span>
    }
}</code></pre><p>In Swift 5.1, those trailing question marks are no longer needed, and we can now simply refer to each case directly ‚Äî just like when switching on a non-optional value:</p><pre class="splash"><code><span class="s-keyword">func</span> songDownloadStateDidChange(<span class="s-keyword">_</span> song: <span class="s-type">Song</span>) {
    <span class="s-keyword">switch</span> song.<span class="s-property">downloadState</span> {
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloadInProgress</span>:
        <span class="s-call">showProgressIndiator</span>(for: song)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloadFailed</span>(<span class="s-keyword">let</span> error):
        <span class="s-call">showDownloadError</span>(error, for: song)
    <span class="s-keyword">case</span> .<span class="s-dotAccess">downloaded</span>:
        <span class="s-call">downloadDidFinish</span>(for: song)
    <span class="s-keyword">case nil</span>:
        <span class="s-keyword">break</span>
    }
}</code></pre><p>While the above is a really welcome change in terms of further reducing the syntax required to implement common patterns, it does come with a slight side-effect, that could potentially be source-breaking for certain enums and switch statements.</p><p>Since Swift optionals are implemented using the <code>Optional</code> enum under the hood, we‚Äôre no longer able to perform the above kind of optional pattern matching on any enum that contains either a <code>some</code> or <code>none</code> case ‚Äî since those will now conflict with the cases that <code>Optional</code> contains.</p><p>However, it can be argued that any enum that contains such cases (especially <code>none</code>), should instead be implemented using an optional ‚Äî since representing potentially missing values is essentially what optionals do.</p><h2> protocol</h2><p>Originally introduced as part of the initial release of SwiftUI, the new <code>Identifiable</code> protocol has now made its way into the Swift standard library ‚Äî and provides a simple and unified way to mark any type as having a stable, unique identifier.</p><p>To conform to this new protocol, we simply have to declare an <code>id</code> property, which can contain any <code>Hashable</code> type ‚Äî for example <code>String</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> User: <span class="s-type">Identifiable</span> {
    <span class="s-keyword">typealias</span> ID = <span class="s-type">String</span>

    <span class="s-keyword">var</span> id: <span class="s-type">ID</span>
    <span class="s-keyword">var</span> name: <span class="s-type">String</span>
}</code></pre><p>Similar to when <a href="https://www.swiftbysundell.com/articles/the-power-of-result-types-in-swift"><code>Result</code></a> was added to the standard library as part of Swift 5.0, a major benefit of now having <code>Identifable</code> accessible to any Swift module is that it can be used to share requirements across different code bases.</p><p>For example, using a constrained protocol extension, we could add a convenience API for transforming any <code>Sequence</code> that contains identifiable elements into a dictionary ‚Äî and then vend that extension as part of a library, without requiring us to define any protocol of our own:</p><pre class="splash"><code><span class="s-keyword">public extension</span> <span class="s-type">Sequence</span> <span class="s-keyword">where</span> <span class="s-type">Element</span>: <span class="s-type">Identifiable</span> {
    <span class="s-keyword">func</span> keyedByID() -&gt; [<span class="s-type">Element</span>.<span class="s-type">ID</span> : <span class="s-type">Element</span>] {
        <span class="s-keyword">var</span> dictionary = [<span class="s-type">Element</span>.<span class="s-type">ID</span> : <span class="s-type">Element</span>]()
        <span class="s-call">forEach</span> { dictionary[$0.<span class="s-property">id</span>] = $0 }
        <span class="s-keyword">return</span> dictionary
    }
}</code></pre><p class="info">The above API is implemented as a method, rather than as a computed property, since its time complexity is <code>O(n)</code>. For more on picking between a method and a computed property, see <a href="https://www.swiftbysundell.com/articles/computed-properties-in-swift">this article</a>.</p><p>However, while the standard library‚Äôs new <code>Identifiable</code> protocol is really useful when dealing with collections of values that each have a stable identifier, it doesn‚Äôt do much to improve the actual type safety of our code.</p><p>Since all that <code>Identifiable</code> does is requiring us to define any hashable <code>id</code> property, it won‚Äôt protect us from accidentally mixing up identifiers ‚Äî such as in this situation, when we‚Äôre mistakenly passing a <code>User</code> ID to a function that accepts a <code>Video</code> ID:</p><pre class="splash"><code><span class="s-call">postComment</span>(comment, onVideoWithID: user.<span class="s-property">id</span>)</code></pre><p>So there‚Äôs still quite a lot of strong use cases for a proper <code>Identifier</code> type and a more robust <code>Identifiable</code> protocol ‚Äî such as the ones we took a look at in <em><a href="https://www.swiftbysundell.com/articles/type-safe-identifiers-in-swift">‚ÄúType-safe identifiers in Swift‚Äù</a></em>, which prevents the above kind of mistakes from happening. However, it‚Äôs still really nice to now have <em>some</em> version of an <code>Identifiable</code> protocol in the standard library, even if it is a bit more limited.</p><h2>Ordered collection diffing</h2><p>Finally, let‚Äôs take a look at a brand new standard library API that‚Äôs being introduced as part of Swift 5.1 ‚Äî ordered collection diffing. As we, as a community, move closer and closer to the world of declarative programming with tools like Combine and SwiftUI ‚Äî being able to calculate the difference between two states is something that becomes increasingly important.</p><p>After all, declarative UI development is all about continuously rendering new snapshots of state ‚Äî and while SwiftUI and the new <a href="https://wwdcbysundell.com/2019/diffable-data-sources-first-look">diffable data sources</a> will probably do most of the heavy lifting to make that happen ‚Äî being able to calculate a diff between two states ourselves could be incredibly useful.</p><p>For example, let‚Äôs say that we‚Äôre building a <code>DatabaseController</code> that‚Äôll let us easily update our on-disk database with an array of in-memory models. To be able to figure out whether a model should be inserted or deleted, we can now simply call the new <code>difference</code> API to calculate the diff between our old array and the new one ‚Äî and then iterate through the changes within that diff in order to perform our database operations:</p><pre class="splash"><code><span class="s-keyword">class</span> DatabaseController&lt;Model: <span class="s-type">Hashable</span> &amp; <span class="s-type">Identifiable</span>&gt; {
    <span class="s-keyword">private let</span> database: <span class="s-type">Database</span>
    <span class="s-keyword">private(set) var</span> models: [<span class="s-type">Model</span>] = []
    
    ...

    <span class="s-keyword">func</span> update(with newModels: [<span class="s-type">Model</span>]) {
        <span class="s-keyword">let</span> diff = newModels.<span class="s-call">difference</span>(from: models)

        <span class="s-keyword">for</span> change <span class="s-keyword">in</span> diff {
            <span class="s-keyword">switch</span> change {
            <span class="s-keyword">case</span> .<span class="s-dotAccess">insert</span>(<span class="s-keyword">_</span>, <span class="s-keyword">let</span> model, <span class="s-keyword">_</span>):
                database.<span class="s-call">insert</span>(model)
            <span class="s-keyword">case</span> .<span class="s-dotAccess">remove</span>(<span class="s-keyword">_</span>, <span class="s-keyword">let</span> model, <span class="s-keyword">_</span>):
                database.<span class="s-call">delete</span>(model)
            }
        }

        models = newModels
    }
}</code></pre><p>However, the above implementation does not account for moved models ‚Äî since moves will, by default, be treated as separate insertions and removals. To fix that, let‚Äôs also call the <code>inferringMoves</code> method when computing our diff ‚Äî and then look at whether each insert was associated with a removal, and if so treat it as a move instead, like this:</p><pre class="splash"><code><span class="s-keyword">func</span> update(with newModels: [<span class="s-type">Model</span>]) {
    <span class="s-keyword">let</span> diff = newModels.<span class="s-call">difference</span>(from: models).<span class="s-call">inferringMoves</span>()
    
    <span class="s-keyword">for</span> change <span class="s-keyword">in</span> diff {
        <span class="s-keyword">switch</span> change {
        <span class="s-keyword">case</span> .<span class="s-dotAccess">insert</span>(<span class="s-keyword">let</span> index, <span class="s-keyword">let</span> model, <span class="s-keyword">let</span> association):
            <span class="s-comment">// If the associated index isn't nil, that means
            // that the insert is associated with a removal,
            // and we can treat it as a move.</span>
            <span class="s-keyword">if</span> association != <span class="s-keyword">nil</span> {
                database.<span class="s-call">move</span>(model, toIndex: index)
            } <span class="s-keyword">else</span> {
                database.<span class="s-call">insert</span>(model)
            }
        <span class="s-keyword">case</span> .<span class="s-dotAccess">remove</span>(<span class="s-keyword">_</span>, <span class="s-keyword">let</span> model, <span class="s-keyword">let</span> association):
            <span class="s-comment">// We'll only process removals if the associated
            // index is nil, since otherwise we will already
            // have handled that operation as a move above.</span>
            <span class="s-keyword">if</span> association == <span class="s-keyword">nil</span> {
                database.<span class="s-call">delete</span>(model)
            }
        }
    }
    
    models = newModels
}</code></pre><p>The fact that diffing is now built into the standard library (and also into UIKit and AppKit) is fantastic news ‚Äî as writing an efficient, flexible, and robust diffing algorithm can be incredibly difficult.</p><h2>Conclusion</h2><p>Not only is Swift 5.1 a key enabler for SwiftUI and Combine, it‚Äôs also big news for any team that vends pre-compiled frameworks, as Swift is now not only ABI stable, but also module stable. On top of that, Swift 5.1 also includes many small but welcome changes and tweaks that should be applicable to almost any code base ‚Äî and while we‚Äôve taken a look at five of those changes in this article, we‚Äôll keep diving deeper into more aspects of Swift 5.1 within the coming weeks and months.</p><p>The reason no SwiftUI-related features were included in this article is that those were covered in <em><a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">‚ÄúThe Swift 5.1 features that power SwiftUI‚Äôs API‚Äù</a></em>. The same is also true for static subscripts, which were covered in <em><a href="https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift">‚ÄúThe power of subscripts in Swift‚Äù</a></em>.</p><p>What do you think? Have you already migrated your projects to Swift 5.1, and if so, what‚Äôs your favorite new feature? Let me know ‚Äî along with any questions, comments or feedback that you might have ‚Äî either via <a href="https://twitter.com/johnsundell">Twitter</a> or <a href="https://www.swiftbysundell.com/contact">email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/tips/gathering-test-coverage-in-xcode</guid><title>Tip: Gathering test coverage in Xcode</title><description>How to enable and use test coverage in Xcode.</description><link>https://www.swiftbysundell.com/tips/gathering-test-coverage-in-xcode</link><pubDate>Wed, 18 Sep 2019 15:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Measuring the degree to which a project‚Äôs suite of unit tests covers its code base can be a great way to identify code paths that aren‚Äôt yet tested. While coverage data doesn‚Äôt tell us anything about the <em>quality</em> of our tests, it can still be an incredibly useful tool ‚Äî especially when retrofitting a code base with tests, or when we‚Äôre unsure whether a certain condition or state is actually being tested.</p><p>However, Xcode won‚Äôt gather test coverage by default, but thankfully it‚Äôs really easy to enable. Start by pressing <code>‚å•‚åòU</code> to bring up the current target‚Äôs test settings. Then open the <em>Options</em> tab, and check the <em>Code Coverage</em> checkbox, like this:</p><img src="https://www.swiftbysundell.com/images/tips/enabling-code-coverage.png" alt="How to enable code coverage"/><p>That‚Äôs it! Next, let‚Äôs actually make use of the coverage data that from now on will be generated each time we run our tests. One way to do that is to open up the <em>Report Navigator</em> (<code>‚åò9</code>), which will now show a coverage report for each subsequent testing session:</p><img src="https://www.swiftbysundell.com/images/tips/accessing-code-coverage-reports.png" alt="How to access code coverage reports"/><p>Finally, we can also enable our new coverage data to be shown inline as we‚Äôre coding. While some developers might find that distracting, it can be a great way to quickly spot code paths that need testing. To turn that on, use the <em>Adjust Editor Options</em> button located in the top-right corner of each editor:</p><img src="https://www.swiftbysundell.com/images/tips/showing-code-coverage-inline.png" alt="How to display code coverage inline"/><p>As you can see above, any code paths that aren‚Äôt yet tested will now be highlighted using a red bar, and the iteration count will also be shown for all other paths. Really nice!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager</guid><title>Managing dependencies using the Swift Package Manager</title><description>Starting with Xcode 11, the Swift Package Manager is becoming a true first class citizen within Apple‚Äôs suite of developer tools. Let‚Äôs take a look at how it can be used to manage a project‚Äôs various dependencies.</description><link>https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager</link><pubDate>Sun, 15 Sep 2019 21:00:00 +0200</pubDate><content:encoded><![CDATA[<p>When Swift was open sourced at the end of 2015, one of the most surprising and interesting new projects that was introduced along with it, was the <em>Swift Package Manager</em>. While it wasn‚Äôt the first dependency manager for Swift projects, it was the first that was officially provided and supported by Apple, which many developers saw as really good news.</p><p>However, while the server-side Swift community quickly embraced the Swift Package Manager as the go-to tool for managing dependencies when building server applications, it‚Äôs taken quite a while for it to become fully integrated into the rest of Apple‚Äôs developer toolchains.</p><p>But now, starting with Xcode 11, the Swift Package Manager is finally becoming a true <em>first class citizen</em> within Apple‚Äôs suite of developer tools ‚Äî so this week, let‚Äôs take a look at how it can be used to manage a project‚Äôs various dependencies ‚Äî both internal and external ones.</p><h2>The anatomy of a Swift package</h2><p>A <em>Swift Package</em> is essentially a group of Swift source files that are compiled together to form a <em>Module</em> ‚Äî which can then be shared and imported into other projects as one unit. Packages can either be public libraries that are shared using services like GitHub, or internal tools and frameworks that are only shared within a small number of projects.</p><p>The contents of a package is declared using a <code>Package.swift</code> <em>manifest file</em>, which is placed in the root directory of each package. Rather than using a data format, like JSON or XML, Swift package manifest files are written using actual Swift code ‚Äî with a <code>Package</code> instance representing the declaration of the package.</p><p>As an example, let‚Äôs say that we‚Äôre working on a todo list app, and that we want to create a <code>TodoKit</code> package for all of our core logic that‚Äôs shared across the app ‚Äî including things like our database layer, our model code, and so on. To get started, we‚Äôll create a new folder (with a name that matches what we want our package to be called), and we‚Äôll then run <code>swift package init</code> within it to create our package:</p><pre><code class="no-highlight">$ mkdir TodoKit
$ cd TodoKit
$ swift package init</code></pre><p class="info">In Xcode 11, we can also perform the above setup using the <code>File &gt; New &gt; Swift Package</code> menu command.</p><p>By doing the above, the Swift Package Manager will now have created an initial structure for our new package ‚Äî which includes a <code>Package.swift</code> manifest file that looks something like this:</p><pre class="splash"><code><span class="s-comment">// swift-tools-version:5.1</span>

<span class="s-keyword">import</span> PackageDescription

<span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    name: <span class="s-string">"TodoKit"</span>,
    products: [
        <span class="s-comment">// The external product of our package is an importable
        // library that has the same name as the package itself:</span>
        .<span class="s-call">library</span>(
            name: <span class="s-string">"TodoKit"</span>,
            targets: [<span class="s-string">"TodoKit"</span>]
        )
    ],
    targets: [
        <span class="s-comment">// Our package contains two targets, one for our library
        // code, and one for our tests:</span>
        .<span class="s-call">target</span>(name: <span class="s-string">"TodoKit"</span>),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"TodoKitTests"</span>,
            dependencies: [<span class="s-string">"TodoKit"</span>]
        )
    ]
)</code></pre><p class="info">The <code>swift-tools-version</code> comment at the top of the file isn‚Äôt just a comment, it also tells the Swift Package Manager what version of the Swift toolchain to use when building our package.</p><p>By default, the Swift Package Manager will match the names of the targets defined within our manifest file with corresponding folders on disk in order to determine what Swift files that belong to each target. That behavior, along with other defaults ‚Äî such as build settings, target platforms, etc. ‚Äî can be overridden by passing additional parameters to the APIs used above.</p><h2>Adding remote dependencies</h2><p>Besides facilitating the creation of packages, one of the Swift Package Manager‚Äôs core use cases is enabling remote dependencies ‚Äî such as third party libraries ‚Äî to be added to a project. Any package that can be fetched through Git can be added simply by specifying its URL, as well as the <em>version constraint</em> that we wish to apply to it:</p><pre class="splash"><code><span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    ...
    dependencies: [
        <span class="s-comment">// Here we define our package's external dependencies
        // and from where they can be fetched:</span>
        .<span class="s-call">package</span>(
            url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>, 
            from: <span class="s-string">"4.0.0"</span>
        )
    ],
    targets: [
        .<span class="s-call">target</span>(
            name: <span class="s-string">"TodoKit"</span>,
            <span class="s-comment">// Here we add our new dependency to our main target,
            // which lets us import it within that target's code:</span>
            dependencies: [<span class="s-string">"Files"</span>]
        ),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"TodoKitTests"</span>,
            dependencies: [<span class="s-string">"TodoKit"</span>]
        )
    ]
)</code></pre><p>Above we‚Äôre importing <em>any version</em> of the <a href="https://github.com/JohnSundell/Files">Files package</a> between <code>4.0.0</code> and <code>5.0.0</code> ‚Äî leaving it up to the Swift Package Manager to resolve the most appropriate version that satisfies our overall dependency graph, while defaulting to the latest version within that range.</p><p>Using such a broad version constraint can be really powerful, since if we were to add another dependency that requires a specific version of Files, the package manager would be free to pick that version (as long as it‚Äôs within our allowed version range) ‚Äî making it less likely that we‚Äôll end up with an unresolvable dependency graph.</p><p>However, sometimes we might want to lock onto a specific version of one of our dependencies ‚Äî perhaps to avoid a regression that was introduced in a later version, or to be able to keep using an API that was later removed. To do that, we can replace the above <code>from:</code> parameter with the <code>.exact</code> version requirement ‚Äî like this:</p><pre class="splash"><code>.<span class="s-call">package</span>(
    url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
    .<span class="s-call">exact</span>(<span class="s-string">"4.0.0"</span>)
)</code></pre><p>On the other hand, we might instead want to use a dependency revision that‚Äôs <em>further ahead</em> than the latest official release ‚Äî for example to include a bug fix or a new API that hasn‚Äôt been properly released yet. To do that, we have two options.</p><p>The first option is to point our dependency to a specific Git branch (which can be quite risky if that branch is rapidly changing), or to lock onto a specific commit hash (which is less risky, but also less flexible, since we‚Äôll have to manually change that hash each time we want to update that dependency):</p><pre class="splash"><code><span class="s-comment">// Depending on a branch (master in this case):</span>
.<span class="s-call">package</span>(
    url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
    .<span class="s-call">branch</span>(<span class="s-string">"master"</span>)
)

<span class="s-comment">// Depending on an exact commit:</span>
.<span class="s-call">package</span>(
    url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
    .<span class="s-call">revision</span>(<span class="s-string">"0e0c6aca147add5d5750ecb7810837ef4fd10fc2"</span>)
)</code></pre><p>Being able to specify dependencies not only by version, but by Git revision as well, can also be really useful in order to temporarily fetch a dependency from a forked repository, rather than from its original one.</p><p>For example, let‚Äôs say that we‚Äôve discovered a bug in one of our external dependencies, and that we‚Äôve implemented a fix for it within our fork of that project. Rather than having to wait for that fix to be merged into the original repository, and then released ‚Äî we can simply point that dependency to the URL of our fork, and then specify <code>master</code> as our branch target, to be able to directly use our patched version.</p><h2>Using local packages</h2><p>When working on several different packages in parallel, for example when splitting a project up into multiple smaller libraries, using <em>local dependencies</em> can sometimes be really useful ‚Äî and drastically improve iteration times.</p><p>Rather than being downloaded from a URL, local package dependencies are simply added directly from a folder on disk ‚Äî which both lets us import our own packages without having to worry about versioning, and also enables us to directly edit a dependency‚Äôs source files within the project that‚Äôs using it.</p><p>For example, here‚Äôs how we could add a local <code>CalendarKit</code> package as a dependency to <code>TodoKit</code> ‚Äî simply by specifying its relative folder path:</p><pre class="splash"><code><span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    ...
    dependencies: [
        .<span class="s-call">package</span>(
            url: <span class="s-string">"https://github.com/johnsundell/files.git"</span>,
            .<span class="s-call">exact</span>(<span class="s-string">"4.0.0"</span>)
        ),
        <span class="s-comment">// Using 'path', we can depend on a local package that's
        // located at a given path relative to our package's folder:</span>
        .<span class="s-call">package</span>(path: <span class="s-string">"../CalendarKit"</span>)
    ],
    targets: [
        .<span class="s-call">target</span>(
            name: <span class="s-string">"TodoKit"</span>,
            dependencies: [<span class="s-string">"Files"</span>, <span class="s-string">"CalendarKit"</span>]
        ),
        .<span class="s-call">testTarget</span>(
            name: <span class="s-string">"TodoKitTests"</span>,
            dependencies: [<span class="s-string">"TodoKit"</span>]
        )
    ]
)</code></pre><p>Besides being able to directly edit dependencies, local package references are also really useful when building custom developer tools. For example, we could use the Swift Package Manager to <a href="https://www.swiftbysundell.com/articles/building-a-command-line-tool-using-the-swift-package-manager">build a command line tool</a> within an app‚Äôs repository, and then use a local dependency to import some of our app code into that tool ‚Äî like our model or networking code, for example.</p><h2>Platform and OS version constraints</h2><p>Apart from the internal packages and third party libraries that we‚Äôve explicitly added to a project, our code will most likely also depend on a specific range of platforms and operating system versions ‚Äî in order to have access to the right APIs and system frameworks.</p><p>While all Swift packages are assumed to be cross-platform (and version agnostic) by default, by adding the <code>platform</code> parameter when initializing our <code>Package</code> within our manifest file, we can constrain our code to only support a given set of platforms and OS versions ‚Äî like this, if we wanted to build a package that contains iOS 13-specific code:</p><pre class="splash"><code><span class="s-comment">// swift-tools-version:5.1</span>

<span class="s-keyword">import</span> PackageDescription

<span class="s-keyword">let</span> package = <span class="s-type">Package</span>(
    name: <span class="s-string">"TodoSwiftUIComponents"</span>,
    platforms: [.<span class="s-call">iOS</span>(.<span class="s-dotAccess">v13</span>)],
    ...
)</code></pre><p>Just like when picking a minimum deployment target for an app in Xcode, using the <code>platforms</code> parameter enables us to use APIs that are only available on a subset of platforms or OS versions ‚Äî such as SwiftUI or Combine. We can of course also specify multiple platforms and version as well ‚Äî for example, we could append <code>.macOS(.v10_15)</code> to the above array to also add support for macOS Catalina.</p><h2>Adding packages to an Xcode project</h2><p>Starting with Xcode 11, Swift packages can now be directly added and imported into an app project using Xcode‚Äôs new <code>Swift Packages</code> option, which is located within the <code>File</code> menu. Using this new integration both enables us to easily import third party libraries as Swift packages, and it can also let us leverage the power of the Swift Package Manager to improve the modularity of our code base.</p><p>By creating separate packages for different parts of our code base ‚Äî just like the <code>TodoKit</code>, <code>CalendarKit</code>, and <code>TodoSwiftUIComponents</code> examples from before ‚Äî we can both improve the separation of concerns within our app, and also enable our code to be easily reused across different platforms or extensions.</p><p>For example, by defining our UI components in a separate package from our model code, there‚Äôs no risk of accidentally <a href="https://www.swiftbysundell.com/articles/preventing-views-from-being-model-aware-in-swift">mixing view code with model code</a> ‚Äî which can help us maintain a much more solid architecture over time ‚Äî and it also enables us to easily share our core UI components between multiple targets.</p><h2>Conclusion</h2><p>While the Swift Package Manager isn‚Äôt really a brand new tool anymore, the fact that it can now be used for apps on all of Apple‚Äôs platforms gives it a much wider appeal ‚Äî and kind of feels like a <em>‚Äúnew beginning‚Äù</em> for Swift packages as a concept. Being able to use the same package manager to build anything from server-side applications, to command line tools and scripts, to iOS apps, is also incredibly powerful ‚Äî and could potentially enable parts of our code to be reused in even more contexts.</p><p>What do you think? Have you used the Swift Package Manager before, or will you try it out now that it‚Äôs integrated into Xcode? Let me know ‚Äî along with your questions, comments or feedback ‚Äî either <a href="https://twitter.com/johnsundell">on Twitter</a> or <a href="https://www.swiftbysundell.com/contact">via email</a>.</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.swiftbysundell.com/basics/swiftui</guid><title>Basics: SwiftUI</title><description>A recap of the basics of SwiftUI, Apple‚Äôs declarative new UI framework for building apps across all of their platforms. How to build custom views and modify existing ones, how to manage local state within a view, and how to compose multiple views to form new ones.</description><link>https://www.swiftbysundell.com/basics/swiftui</link><pubDate>Thu, 12 Sep 2019 21:20:00 +0200</pubDate><content:encoded><![CDATA[<p>Apple‚Äôs new declarative UI framework, SwiftUI, offers a brand new way to construct views across all Apple platforms. Rather than explicitly programming instructions as to how each view should be rendered, with SwiftUI, we‚Äôre instead <em>declaring</em> what we want the end result of our UI to be ‚Äî letting us leverage the framework to do most of the actual rendering work for us.</p><p>When using SwiftUI, each view is essentially a description of a single piece of our UI ‚Äî both in terms of how it‚Äôll look and behave in terms of layout, as well as how it should handle user interactions and other events. As an example, here‚Äôs a <code>ProductView</code> that shows information about a product within a shopping app ‚Äî by conforming to SwiftUI‚Äôs <code>View</code> protocol, and then returning its subviews through its computed <code>body</code> property:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-comment">// We'll render our product view as a vertical stack
        // containing the product's image, name, and price:</span>
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(uiImage: product.<span class="s-property">image</span>)
            <span class="s-type">Text</span>(product.<span class="s-property">name</span>)
            <span class="s-type">Text</span>(product.<span class="s-property">price</span>)
        }
    }
}</code></pre><p class="info">The syntax used above may at first seem a bit unfamiliar. That‚Äôs because SwiftUI makes heavy use of a few key new features introduced in Swift 5.1. To learn more about those, check out <a href="https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api">‚ÄúThe Swift 5.1 features that power SwiftUI‚Äôs API‚Äù</a>.</p><p>What‚Äôs interesting about the above implementation, especially if compared to UI code written using Apple‚Äôs older frameworks (like UIKit and AppKit), is that it doesn‚Äôt contain any layout instructions, apart from its <code>VStack</code>. That‚Äôs really one of the core advantages of SwiftUI ‚Äî since we‚Äôre no longer dealing with view objects that need to be explicitly positioned and sized, but rather with view descriptions, it lets the system make many different kinds of layout decisions on our behalf.</p><p>Besides <code>VStack</code>, SwiftUI offers two other main stack types that can be used to leverage its automatic layout system ‚Äî <code>HStack</code> and <code>ZStack</code>. For example, here‚Äôs how we could wrap our <em>name</em> and <em>price</em> labels in an <code>HStack</code> to render them side-by-side, rather than stacking them vertically:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(uiImage: product.<span class="s-property">image</span>)
        
            <span class="s-type">HStack</span> {
                <span class="s-type">Text</span>(product.<span class="s-property">name</span>)
                <span class="s-type">Text</span>(product.<span class="s-property">price</span>)
            }
        }
    }
}</code></pre><p>Finally, the <code>ZStack</code> type can be used to stack views in terms of depth ‚Äî which comes very much in handy when adding some form of background to a view. For example, here‚Äôs how we could give our <code>ProductView</code> a gradient background, by placing a <code>LinearGradient</code> on top of our previous <code>VStack</code>, and then wrapping both within a <code>ZStack</code>:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            <span class="s-type">LinearGradient</span>(
                gradient: <span class="s-type">Gradient</span>(colors: [.<span class="s-dotAccess">red</span>, .<span class="s-dotAccess">blue</span>]),
                startPoint: .<span class="s-dotAccess">topLeading</span>,
                endPoint: .<span class="s-dotAccess">bottomTrailing</span>
            ).<span class="s-call">edgesIgnoringSafeArea</span>(.<span class="s-dotAccess">all</span>)
            
            <span class="s-type">VStack</span> {
                <span class="s-type">Image</span>(uiImage: product.<span class="s-property">image</span>)
            
                <span class="s-type">HStack</span> {
                    <span class="s-type">Text</span>(product.<span class="s-property">name</span>)
                    <span class="s-type">Text</span>(product.<span class="s-property">price</span>)
                }
            }
        }
    }
}</code></pre><p class="info">The reason we call <code>edgesIgnoringSafeArea</code> above is to make our gradient extend beyond the safe area insets of our view, which will make it fill the entire screen on all devices.</p><p>While it‚Äôs really convenient to be able to quickly add all of our views in one place, doing so tends to get a bit messy once we reach a certain number of views or levels of indentation. Thankfully, since SwiftUI is all about building views as separate component-like building blocks, extracting parts of a view into its own type is often quite trivial.</p><p>Let‚Äôs do exactly that, and split our <code>ProductView</code> up into two separate subviews instead ‚Äî one for our gradient, and one for displaying our product info:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductGradientView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">LinearGradient</span>(
            gradient: <span class="s-type">Gradient</span>(colors: [.<span class="s-dotAccess">red</span>, .<span class="s-dotAccess">blue</span>]),
            startPoint: .<span class="s-dotAccess">topLeading</span>,
            endPoint: .<span class="s-dotAccess">bottomTrailing</span>
        ).<span class="s-call">edgesIgnoringSafeArea</span>(.<span class="s-dotAccess">all</span>)
    }
}

<span class="s-keyword">struct</span> ProductInfoView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">VStack</span> {
            <span class="s-type">Image</span>(uiImage: product.<span class="s-property">image</span>)
        
            <span class="s-type">HStack</span> {
                <span class="s-type">Text</span>(product.<span class="s-property">name</span>)
                <span class="s-type">Text</span>(product.<span class="s-property">price</span>)
            }
        }
    }
}</code></pre><p>With those two new views in place, we can now simply make <code>ProductView</code> <em><a href="https://www.swiftbysundell.com/articles/composing-types-in-swift">compose them</a></em> into our final UI, making our code a lot easier to read:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            <span class="s-type">ProductGradientView</span>()
            <span class="s-type">ProductInfoView</span>(product: product)
        }
    }
}</code></pre><p>Another way that SwiftUI enables us to create custom views is by applying <em>modifiers</em> to existing ones. For example, here‚Äôs how we could use modifiers to turn our product label bold, as well as limit its text to two lines ‚Äî and also change the text color of our price label:</p><pre class="splash"><code><span class="s-type">HStack</span> {
    <span class="s-type">Text</span>(product.<span class="s-property">name</span>).<span class="s-call">bold</span>().<span class="s-call">lineLimit</span>(<span class="s-number">2</span>)
    <span class="s-type">Text</span>(product.<span class="s-property">price</span>).<span class="s-call">foregroundColor</span>(.<span class="s-dotAccess">white</span>)
}</code></pre><p>Besides defining what our views will look like in terms of visuals, another important aspect of any kind of UI development is keeping track of state ‚Äî both when it comes to handling user input, and to ensure that our UI gets properly updated as our state changes. While we‚Äôll explore all of SwiftUI‚Äôs various state handling APIs in much more detail in upcoming articles, let‚Äôs start by taking a look at how the new <code>@State</code> property wrapper can be used to manage <em>local state</em> within a view.</p><p>Let‚Äôs say that we wanted to add a stepper to our product view that lets the user pick the number of items to order. To do that, we both need to display the current quantity of items, and also modify it whenever the user interacted with our stepper ‚Äî in order words, we need to establish a <em>two-way binding</em> between our UI and the state (the quantity of items) that it depends on.</p><p>Since our state will only be read and modified within our view, let‚Äôs define it using a <code>@State</code> property, which will enable us to establish such a two-way binding between our new property and the stepper that‚Äôll render and modify it:</p><pre class="splash"><code><span class="s-keyword">struct</span> ProductView: <span class="s-type">View</span> {
    <span class="s-keyword">var</span> product: <span class="s-type">Product</span>

    <span class="s-comment">// Using the '@State' property wrapper we can define pieces
    // of state that are local (private) to the current view:</span>
    <span class="s-keyword">@State private var</span> quantity = <span class="s-number">1</span>

    <span class="s-keyword">var</span> body: <span class="s-keyword">some</span> <span class="s-type">View</span> {
        <span class="s-type">ZStack</span> {
            <span class="s-type">ProductGradientView</span>()

            <span class="s-type">VStack</span> {
                <span class="s-type">ProductInfoView</span>(product: product)

                <span class="s-comment">// Here we can both directly interpolate our value
                // into the stepper's label, and also bind it to
                // the stepper itself, enabling it to be modified:</span>
                <span class="s-type">Stepper</span>(<span class="s-string">"Quantity:</span> \(quantity)<span class="s-string">"</span>,
                    value: $quantity,
                    in: <span class="s-number">1</span>...<span class="s-number">99</span>
                ).<span class="s-call">padding</span>()
            }
        }
    }
}</code></pre><p class="info">The reason we prefix our <code>quantity</code> property with <code>$</code> when injecting it as our stepper‚Äôs <code>value</code> above is because we want to pass a reference to the wrapped <code>@State</code> property, rather than its current <code>Int</code> value.</p><p>It‚Äôs quite clear that SwiftUI isn‚Äôt <em>just</em> a new UI framework ‚Äî it‚Äôs a substantial paradigm shift in terms of how apps are built for Apple‚Äôs platforms. It‚Äôll definitely take a while to get used to, and it‚Äôll also take some time for common patterns and best practices to emerge, given that many of the patterns we might have used in the past won‚Äôt be directly compatible with SwiftUI‚Äôs very declarative structure. But it‚Äôs a really exciting time to be an Apple platforms developer, isn‚Äôt it?</p><p>Thanks for reading! üöÄ</p>]]></content:encoded></item></channel></rss>